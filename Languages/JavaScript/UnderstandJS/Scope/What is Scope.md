
## 编译原理
* JavaSccipt实际上也是编译语言，但并不是提前编译的，编译结果也不能在分布式系统中进行移植。
* 尽管如此，JavaScript引擎进行编译的步骤和传统的编译语言非常相似，在某些环节可能比预想的要复杂。

### 传统编译过程

#### 第一步：分词/词法分析（Tokenizing/Lexing）
1. 这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。
例如，考虑程序var a = 2;。这段程序通常会被分解成为下面这些词法单元：var、a、=、2 、;。
2. 空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。
3. 分词（tokenizing）和词法分析（Lexing）之间的区别
    主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断a是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。不懂

#### 第二步： 解析/语法分析（Parsing）
1. 这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。
var a = 2; 的抽象语法树中可能会有一个叫作VariableDeclaration的顶级节点，接下来是一个叫作Identifier（它的值是a）的子节点，以及一个叫作AssignmentExpression的子节点。AssignmentExpression节点有一个叫作NumericLiteral（它的值是2）的子节点。

#### 第三部： 代码生成
1. 将AST转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。
抛开具体细节，简单来说就是有某种方法可以将var a = 2;的AST转化为一组机器指令，用来创建一个叫作a的变量（包括分配内存等），并将一个值储存在a中。


###  JavaScript引擎的编译要复杂得多

1. JavaScript引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因为与其他语言不同，JavaScript的编译过程不是发生在构建之前的。JavaScript引擎用尽了各种办法来保证性能最佳。
2. 对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短）的时间内。
3. 在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。




## 理解作用域

### 一. 涉及到的三个对象：
1. 引擎 ：从头到尾负责整个JavaScript程序的编译及执行过程。
2. 编译器 ：负责语法分析及代码生成等。
3. 作用域 ：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

### 二. 以代码 var a = 2; 为例讲解引擎编译代码时的作用域概念
对于引擎来说，这里有两个完全不同的过程，一个由编译器在编译时处理，另一个则由引擎在运行时处理。即，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。详见如下过程：
1. 首先由引擎解析为词法单元
2. 然后将词法单元解析为一个树结构然后进入开始代码生成阶段。
3. 对于var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。
4. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2这个赋值操作。
引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a的变量。如果是，引擎就会使用这个变量；如果不是，引擎会继续查找该变量。
5. 如果引擎最终找到了a变量，就会将2赋值给它。否则引擎就会举手示意并抛出一个异常。

### 三. LHS 和 RHS
1. 编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量a来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。
2. 当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。
    RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。
    可以将RHS理解成retrieve his source value（取到它的源值），这意味着“得到某某的值”。
3. 考虑以下代码：
    ```console.log( a );```

    其中对a的引用是一个RHS引用，因为这里a并没有赋予任何值（其实也可以理解为将a的值赋给log()方法的参数）。相应地，需要查找并取得a的值，这样才能将值传递给`console.log(..)`。
    相比之下，例如：  
    
    ```a = 2;```
    这里对a的引用则是LHS引用，因为实际上我们并不关心当前的值是什么，只是想要为= 2这个赋值操作找到一个目标。
4. 函数声明并不是LHS查询  

    ```function foo(a) {}```
    编译器可以在代码生成的同时处理声明和值的定义。在引擎执行代码时，并不会有线程专门用来将一个函数值“分配给”foo。


### 四. 引擎对作用域的查找过程
    ```
    function foo(a) {
        console.log( a ); // 2
    }
    foo( 2 );
    ```
1. 引擎执行到 foo( 2 ); 时， 需要对 foo 进行RHS，因此查询作用域
2. 因为之前编译器在正确的作用域里声明了该函数，因此引擎可以查询到该函数的值
3. 引擎执行该函数
4. 执行该函数时因为进行了2的传参，因此要进行LHS，看看把2赋值给了谁
5. 因为编译器在正确的作用域里创建了该形参，因此引擎得以找到该变量，成功传参。
6. 函数内部存在一个 console 引擎不知道是什么，需要到作用域中进行RHS查询
7. 作用域中存在该内置对象，引擎找到该对象并从中找到了 log() 方法
8. 将a传给该方法的参数时，还要进行一次RHS来确定a的值。








































































