# 原型规划和实现提纲


## 设计时规划原型
1. 设计任何不是很快就能想清楚的东西时，都应该进行原型规划。
2. 大的目标自不必说，小到一个函数的设计，在编码之前，列清楚要做哪些事情，有哪些依赖，有哪些特殊情况，有哪些边界条件，这样在实际编码的时候才会条理清晰。


## 实现时的列出提纲
1. 而且在实现时，对于逻辑复杂的情况，也应该有清晰的提纲，保证自己知道每一部分再干什么，不会混乱、遗漏或重复。
2. 比如一个函数在编写时，可能涉及复杂的逻辑，那完全靠思维的临时内存整理就很容易乱或者遗漏。这时如果能用注释描述清楚逻辑步骤，就会清晰很多。例如下面这个 BST 删除节点的方法
    ```js
    delete (node) {
        let left = node.left;
        let right = node.right;
        let p = node.parent;

        if ( !left && !right ) { // node 是叶节点，没有子节点
            if (p === null) { // node 是根节点，整个树就这一个节点
                this.root = null;
            }
            else if (p.left === node) { // node 是左叶节点
                p.left = null;
            }
            else { // node 是右叶节点
                p.right = null;
            }
        }
        else if (left === null) { // node 只有右子节点
            // 右子节点直接跳过 node 和 node 的父级连接
            if (p === null) {
                this.root = right;
            }
            else if (p.left === node) {
                p.left = right;
            }
            else {
                p.right = right;
            }
            right.parent = p;
        }
        else if (right === null) { // node 只有左子节点
            // 左子节点直接跳过 node 和 node 的父级连接
            if (p === null) {
                this.root = left;
            }
            else if (p.left === node) {
                p.left = left;
            }
            else {
                p.right = left;
            }
            left.parent = p;
        }
        else { // node 有两侧子节点
            let s = this.successor(node);
            if (s === node.right) { // 后继节点是 node 的右子节点
                // 右子节点直接跳过 node 和 node 的父节点和左子节点建立关系
                // 和 node 父节点建立关系
                if (p === null) {
                    this.root = s;
                }
                else if (p.left === node) {
                    p.left = s;
                }
                else {
                    p.right = s;
                }
                s.parent = p;
                // 和 node 的左子节点建立关系
                s.left = node.left;
                node.left.parent = s;
            }
            else { // 后继节点不是 node 的右子节点
                // 后继节点如果有右子节点，覆盖后继节点，也就是和后继节点的父节点建立关系
                s.parent.left = s.right;
                if (s.right) {
                    s.right.parent = s.parent;
                }
                // 后继节点覆盖被删除节点，也就是分别和被删除节点的父节点、两个子节点建立关系
                // 后继节点和被删除节点的父节点建立关系
                if (p === null) {
                    this.root = s;
                }
                else if (p.left === node) {
                    p.left = s;
                }
                else {
                    p.right = s;
                }
                s.parent = p;
                // 后继节点和被删除节点的左子节点建立关系
                s.left = node.left;
                node.left.parent = s;
                // 后继节点和被删除节点的右子节点建立关系
                s.right = node.right;
                node.right.parent = s;
            }
        }
    }
    ```