# 登录逻辑


<!-- TOC -->

- [登录逻辑](#登录逻辑)
    - [0. 思考](#0-思考)
        - [功能边界——SRP 和 语义化](#功能边界srp-和-语义化)
        - [业务逻辑明确，代码逻辑才有可能明确](#业务逻辑明确代码逻辑才有可能明确)
    - [1. 前三个版本的登录功能逻辑随着需求的演进](#1-前三个版本的登录功能逻辑随着需求的演进)
        - [第一版：只在企业微信应用中使用，无需登录](#第一版只在企业微信应用中使用无需登录)
        - [第二版：需要支持在其他环境使用，添加手机号登录](#第二版需要支持在其他环境使用添加手机号登录)
        - [第三版：需要支持同源的外部登录请求，使用手机号登录](#第三版需要支持同源的外部登录请求使用手机号登录)
    - [2. 第四版的登录逻辑](#2-第四版的登录逻辑)
        - [2.1 需求](#21-需求)
        - [2.2 该需求的特殊之处](#22-该需求的特殊之处)
        - [2.3 功能边界破坏](#23-功能边界破坏)
        - [2.4 是否应该支持微信授权](#24-是否应该支持微信授权)
        - [2.5 是否应该支持手机号鉴权](#25-是否应该支持手机号鉴权)
        - [2.6 现状](#26-现状)
        - [2.7 第四版新增的登录逻辑详情](#27-第四版新增的登录逻辑详情)
            - [URL 参数要求](#url-参数要求)
            - [先微信授权，再处理后续登录逻辑](#先微信授权再处理后续登录逻辑)
    - [3. 第五版的登录逻辑](#3-第五版的登录逻辑)
    - [4. 需要改进的地方](#4-需要改进的地方)

<!-- /TOC -->


## 0. 思考
### 功能边界——SRP 和 语义化
1. 登录模块就是负责登录，不要负责鉴权。
2. 如果一定要负责鉴权，那就要把这个模块重新设计成负责登录和鉴权的架构，而不要再原有架构上兼容。

### 业务逻辑明确，代码逻辑才有可能明确
1. 如果业务逻辑明确，那代码按照业务逻辑实现，就可以保证明确。
2. 如果业务逻辑混乱，那代码实现可以有两个选择来兼容业务逻辑的混乱：
    * 忠实于业务逻辑，那么代码逻辑就一样混乱了。
    * 在混乱的业务逻辑上包装一层，虽然底层的包装还是很奇怪，但外层的代码逻辑看起来比较顺畅了。
3. 无论哪一种兼容的方法，都挺混乱。


## 1. 前三个版本的登录功能逻辑随着需求的演进
### 第一版：只在企业微信应用中使用，无需登录
1. 因为是企业微信应用，所以可以通过静默授权获得 code，再请求后端获得用户 token，所以不需要一个用户登录的界面。
2. 进应用后，判断 localStorage 是否有 token，有的话则可以获得用户信息。
3. 如果没有 token，则跳转授权链接，获取 code，再请求 token 并保存。

### 第二版：需要支持在其他环境使用，添加手机号登录
1. 增加环境判断。
2. 进应用后，如果不是企业微信应用，判断 localStorage 是否有 token，有的话则可以获得用户信息。
2. 如果没有 token，则跳转到手机号登录页面，手机号登录后获得 token。

### 第三版：需要支持同源的外部登录请求，使用手机号登录
1. 通过 URL `referrer` 判断链接为外部登录请求，直接跳转到手机号登录页。
2. 登录成功后 token 保存进 cookie，然后通过 `referrer` 重定向。
3. 系统 token 和上面说到的 token 不一样，是用于外部登录请求的。
4. 截至这一版，逻辑分支判断如下
    ```js
    if (是否为外部登录) {

    }
    else {
        if (是否为企业微信应用环境) {

        }
        else {
            // 其他环境
        }
    }
    ```


## 2. 第四版的登录逻辑
### 2.1 需求
1. 微信授权获得 code。
2. 使用 code 向后端 token。如果该用户之前绑定过 phone，还会返回 phone
    * 无 phone：跳转到手机号登录页面。
    * 有 phone：进入手机号鉴权。
3. 手机号鉴权鉴权：
    * 鉴权成功：鉴权接口会返回一个系统 token，通过 `referrer` 重定向并传递获得的系统 token。  
    * 鉴权失败：抛出错误，提示没有权限，终止程序。
4. 这里的需求方是非同源的，运维又没有进行相应的配置，所以 token 直接在 URL 里传递。

### 2.2 该需求的特殊之处
1. 之前三版的登录，都是为了获取 token 而进行手机号登录。
2. 如果加上微信授权，即使本地没有保存 token，也可以通过授权的 code 请求到 token，免去了填写手机号的步骤。这样是没什么问题的。
3. 但这个业务需求的怪异之处在于，在微信授权获得了 token 也不会直接重定向返回，而是还要进行手机号鉴权。
4. 实际上，这个需求的目的就是要进行手机号鉴权，但它又想如果之前有记录手机号的话，用户不需要自己填手机号，只在之前没有记录手机号的时候，才让用户填。
5. 那么，获取之前记录的手机号，就要通过微信授权，code 换 token 并在数据库里找到该 token 对应的用户。
6. 所以，第四版的需求是要做两件事：获取用户手机号，使用获取到的手机号进行鉴权。

### 2.3 功能边界破坏
1. 第一版和第二版的时候，登录模块还都是属于当前应用内部的一个模块，边界正常。
2. 第三版的时候，因为这里已经有了一个手机号登录的功能，所以其他应用也想使用。
3. 但现在这个模块只是当前应用内部的一个登录模块，并没有被设计为公共的登录。
4. 在这个时候，就已经考虑是否应该把该模块作为一个独立的登录应用，处理所有的手机号登录请求。如果抽离为一个单独的应用，那么在处理第三版需求时，就是名正言顺的。因为现在任何需求都是外部登录了。
5. 因为业务需求饱和的原因，并没有时间把它独立出来。然后又出现了第四版的需求。
6. 现在，即使之前已经把登录独立为单独的应用，也无法满足第四版的要求了。
7. 上面说到，如果给这个登录模块加上微信授权，让之前绑定过手机号的用户不需要再填写，这个是符合逻辑的。
8. 但现在还有了手机号鉴权这么一个需求。在现有的设计下，手机号鉴权这个功能，是和整个登录逻辑没有关系的。

### 2.4 是否应该支持微信授权
1. 第四版的需求是另外一个项目组提出的，而这个鉴权也只是要鉴定它们的应用体系里的权限。
2. 正如前面说的，给整个登录功能加上微信授权功能也是可以的，甚至可以说是必要的。
3. 但这个微信授权应该作为整个登录模块的功能，而不是为了解决鉴权的功能。
4. 放在项目里说，微信授权应该是刚进入登录逻辑时进行的，而不是在判断有手机号鉴权逻辑时才进行的。
5. 但是当前因为着急要实现第四版功能，微信授权只是在判定到有手机号鉴权的场景时才会执行。如果之后想在一开始就统一微信授权，就要进行一个搬移、合并的重构。

### 2.5 是否应该支持手机号鉴权
1. 从当前的设计来看，手机号鉴权的工作就是应该有提出需求的那个项目组自己做。这里可以做微信授权，但也只是应该在微信授权获取到手机号之后就通过 `referrer` 返回手机号。
2. 不过最后这个需求还是很奇怪的放到了这里来做。权限管理应该由谁来做？
3. 不同的应用，在用户登录后，有的确实是需要鉴权功能的。那么，这里涉及两种思路
    * 登录模块只提供获取用户手机号，返回给请求方，请求方自己鉴权。
    * 登录模块获取到用户手机号之后，根据请求来源，替请求方进行不同类型的鉴权或者不需要鉴权。
5. 权限管理应该由谁来做？我觉得在一般情况，一个应用的业务变动，可能导致权限管理的变动。那么，权限管理应该是内聚在应用内部，而不应该由公共的登录模块处理。
6. 毕竟，“登录” 和 “鉴权”，从语义上来说，就是两个独立的部分。你要先登录，才能鉴权。比如说你要先登录进去，才能判断你是普通用户权限还是会员权限还是管理员权限。

### 2.6 现状
1. 在前三版的基础上，第四版的需求作为一个平级分支存在，逻辑结构如下
    ```js
    if (需要微信授权) { // 第四版新增的登录逻辑

    }
    else { // 第三版的登录逻辑
        if (是否为外部登录) {

        }
        else {
            if (是否为企业微信应用环境) {

            }
            else {
                // 其他环境
            }
        }
    }
    ```
2. 由于开发时间不够，所以这里的缺陷很明显：**微信授权和手机号鉴权耦合在一起了**。

### 2.7 第四版新增的登录逻辑详情
#### URL 参数要求
* `needWeixinAuth=true`：标记需要进行微信授权则照此设置。
* `referrer`：用户登录成功后的重定向。

#### 先微信授权，再处理后续登录逻辑
1. 如果是 url 带参数 `needWeixinAuth=true` 进入登录页，由 `handleWeixinAuth` 方法接管。
2. 检查当前 url 是否有 `code` 参数：
    * 无：说明初次进来，生成授权链接并跳转。
    * 有：说明是授权之后重定向回来的
        1. 使用 `code` 调用后端接口获得用户 token 和可能的其他信息。
        2. 保存用户 token 和可能的其他信息。
        3. 移除参数中的 `code` 参数，防止之后误判为刚授权重定向回来。
3. 判断获取到的用户信息中是否有 `phone`：
    * 无：跳转到手机号登录页面
    * 有：调用 `authenticateByPhone` 对手机号进行鉴权
4. 手机号鉴权：
    * 鉴权成功：鉴权成功会获得第三方需要的系统 token，使用 `referrer` 重定向并传递系统 token。
    * 鉴权失败：抛出错误，程序终止。


## 3. 第五版的登录逻辑
1. 第四版刚上线的第二天，新的需求就来了。因为有人发现在非微信环境没有手机号鉴权……然后说手机号鉴权也要支持非微信环境……
2. 第四版留下的微信授权和手机号鉴权耦合的缺陷就现世报了。
3. 现在的问题是，我既没有时间把微信授权完全独立出来，但又要把手机号鉴权和微信授权解耦。
4. 看上面的逻辑结构，在第四版的时候，需要鉴权的流程只会出现在需要微信授权的分支里
    ```js
    if (需要微信授权) {
       
    }
    else {
        if (是否为外部登录) {

        }
        else {
            if (是否为企业微信应用环境) {

            }
            else {
               
            }
        }
    }
    ```
5. 但现在需要把鉴权的逻辑单独抽出来，然后在微信授权和不授权的情况下都加上。逻辑结构如下
    ```js
    if (需要微信授权) {
        if (需要手机号鉴权) {

        }
    }
    else {
        if (是否为外部登录) {
            if (需要手机号鉴权) {
                
            }
        }
        else {
            if (是否为企业微信应用环境) {

            }
            else {
                
            }
        }
    }
    ```


## 4. 需要改进的地方
* 登录模块拆分为独立的登录工程，保证 token 存入 cookie 中之后可以被指定的源读取。
* 解耦微信授权和手机号鉴权，进入登录项目时统一微信授权。
* 移除为第三方鉴权的功能，只返回 token 和（或）手机号，第三方自己鉴权。最终逻辑结构会变为
    ```js
    if (需要微信授权) {
        授权获得 token 存入 cookie，`referrer` 重定向回请求方
    }
    else {
        进入登录页，通过手机号换 token
        token 存入 cookie，`referrer` 重定向回请求方
    }
    ```