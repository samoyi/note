# Vue 大组件拆分时 ref 的处理逻辑


<!-- TOC -->

- [Vue 大组件拆分时 ref 的处理逻辑](#vue-大组件拆分时-ref-的处理逻辑)
    - [拆分前的状态](#拆分前的状态)
    - [拆分时 ref 的问题](#拆分时-ref-的问题)
    - [改进思路](#改进思路)

<!-- /TOC -->


## 拆分前的状态
1. 整个个人中心的代码在同一个 Vue 组件里，形成了一个很大的文件。
2. 有几个按钮，点击之后会显示出不同的 dialog，dialog 内部也有着一些不算很少的逻辑。
3. 这些 dialog 并没有写在这个大组件里面的，而是分别作为独立的组件。
4. 在这个大组件里引用这些 dialog 组件，然后通过 `ref` 引用并操作这些 dialog。


## 拆分时 ref 的问题
1. 拆分的时候就是根据不同的管理模块分出子组件，然后也整理出 mixin。
2. 但是因为 `refs` 不能作为 mixin 被公用，所以必须在各个子组件里面引用相应的 dialog，然后通过 `ref` 引用。
3. 这里产生的问题就是，dialog 和具体的子组件耦合了。
4. 刚开始也不会发现有什么问题，但是后续遇到了产品说把一个按钮从一个模块移到另一个模块。而这个模块正好复杂打开一个 dialog。
5. 现在，你不仅要把这个按钮及其方法移到另一个子组件，还要把对应的 dialog 的引用移到那个子组件。 


## 改进思路
1. 从产品逻辑上来说，A 模块里面的按钮既然可以移到 B 模块，那就是说这个按钮从逻辑关系上来说，并不是和 A 模块强相关的，或者说，把它放在 B 模块也是合理的。
2. 既然按钮这样，那么这个按钮触发的 dialog，从逻辑上来说，也不是必须属于 A 模块或者 B 模块的。
3. 因此，dialog 是比较公共的。那么，这些 dialog 就可以放在这些子组件的父组件里面。
4. 现在，dialog 和子模块解耦了。接下来的问题是，子模块怎么控制 dialog。
5. dialog 现在在父组件里面，子组件可以通过 `this.$parent.$refs` 引用到。
6. 不过，如果是可以通过状态来控制的，还是应该通过 store。