# 闹钟


## 数据获取
获得设置了时间且为打开状态的闹钟。
```xml
<ContentProviderBinder name="DeskClockProvider" whereFormat="enabled=='%d'" whereParas="1"
    columns="message,enabled,hour,minutes,alarmtime,daysofweek"
    uri="content://com.android.deskclock/alarm" countName="hasdeskclock">
    <!-- 备注 -->
    <Variable name="clock_message" type="string[]" column="message" />
    <!-- 开关 -->
    <Variable name="clock_enabled" type="string[]" column="enabled" />
    <!-- 时 -->
    <Variable name="clock_hour" type="string[]" column="hour" />
    <!-- 分 -->
    <Variable name="clock_minute" type="string[]" column="minutes" />
    <!-- 响铃时间 -->
    <Variable name="clock_alarmtime" type="string[]" column="alarmtime" />
    <!-- 重复方式 -->
    <!-- 0: 一次性 -->
    <!-- 1: 周一 -->
    <!-- 2: 周二 -->
    <!-- 4: 周三 -->
    <!-- 8: 周四 -->
    <!-- 16: 周五 -->
    <!-- 32: 周六 -->
    <!-- 64: 周日 -->
    <!-- 128: 法定工作日 -->
    <!-- 256: 法定节假日 -->
    <Variable name="clock_daysofweek" type="string[]" column="daysofweek" />
</ContentProviderBinder>
```
```xml
<!-- 接口刷新命令 -->
<BinderCommand name="DeskClockProvider" command="refresh" />
```


## 字段说明
### `clock_enabled`
1. `clock_enabled` 是 0 和 1，文档给的类型是字符串，无法通过设置 `type` 为 `int[]` 或 `number[]` 来获取数值类型。
2. `clock_enabled` 作为字符串，判定时和普通字符串有所区别。在 `clock_enabled[0]` 是 1 的情况下，判定如下
	* `!@clock_enabled[0]` 值是空值，既不是 0 也不是 1，不符合预期。
	* `strIsEmpty(@clock_enabled[0])` 值是 0，符合预期。
	* `strIsEmpty(!@clock_enabled[0])` 是空值，既不是 0 也不是 1 ，不符合预期。
    * `!strIsEmpty(@clock_enabled[0])` 值是 1，符合预期。
3. 所以是不要直接对 `clock_enabled` 取反运算。

### `clock_hour` 和 `clock_minute`
1. 都是字符串类型。
2. `clock_hour` 闹钟的小时数，24 小时制，和系统 12 小时制还是 24 小时制无关。
3. `clock_hour` 和 `clock_minute` 如果是 10 以内，都没有前导零。
4. 如果要显示为带前导零的，可以使用 `DateTime`。但因为 `DateTime` 的 `value` 是要指定时间戳，而不是小时数或分钟数。但可以传给 `value` 时间戳起点那天的 `clock_hour` 小时 `clock_minute` 分钟的时间戳来得到预期的格式，也就是 `@clock_hour[0]*3600000 + @clock_minute[0]*60000`
    ```xml
    <DateTime
        formatExp="'HH:mm'"
        value="(@clock_hour[0])*3600000 + @clock_minute[0]*60000"
    />
    ```
5. 不过注意，这里直接传数字的话，是格林威治时间，所以如果手机设置的是东八区，获得的小时数会再加上 8 小时。比如闹钟设置的是 9 点，那么格式化之后的小时数就是 17 点。所以还要减去 8 小时来获得正确的小时数
    ```xml
    <DateTime
        formatExp="'HH:mm'"
        value="(@clock_hour[0] - 8)*3600000 + @clock_minute[0]*60000"
    />
    ```

## 根据 `clock_hour` 和 `clock_minute` 获得带有前导零的闹钟时间
```xml
<DateTime
    formatExp="'HH:mm'"
    value="(@clock_hour[0] - 8)*3600000 + @clock_minute[0]*60000"
/>
```


## 最近一次闹钟
最近一次闹钟的时间在全局变量 `@next_alarm_time`。如果系统为 12 小时制，格式为 `周一上午11:00`截；如果系统为 24 小时制，格式为 `周一11:00`。截取前面的日期和后面的时间如下
```xml
<Var name="next_alarm_dateStr" type="string"
    expression="substr(@next_alarm_time, 0, ifelse(#time_format, 2, 4))" />
<Var name="next_alarm_timeStr" type="string"
    expression="substr(@next_alarm_time, ifelse(#time_format, 2, 4))" />
```


## 闹钟重复模式的数值字符串（`@clock_daysofweek`）转换为中文字符串
### 下面是错误的
`ceil(@clock_daysofweek[idx]/100)` 的结果会是 0~3，对应下面 `clockTypes` 数组中的字符串中的字符串
```xml
<Var name="clockTypes" type="string[]" expression="''"
    values="'一次性', '自定义', '工作日', '节假日'"
/>

<Text 
    textExp="ifelse(@clock_enabled[0], @clockTypes[ceil(@clock_daysofweek[0]/100)], '未设置')"
/>
```

### 正确的
```xml
<Text 
    textExp="ifelse(@clock_enabled[0], 
        ifelse(
            eqs(@clock_daysofweek[0], '0'), '一次性',
            eqs(@clock_daysofweek[0], '128'), '工作日',
            eqs(@clock_daysofweek[0], '256'), '节假日',
            '自定义'
        ), 
        '未设置'
    )"
/>
```

#### 跳转
```xml
<IntentCommand action="android.intent.action.MAIN"
    package="com.android.deskclock"
    class="com.android.deskclock.DeskClockTabActivity" />
```
