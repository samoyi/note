# 主题


<!-- TOC -->

- [主题](#主题)
    - [TODO](#todo)
    - [基础功能](#基础功能)
        - [文本](#文本)
        - [图片](#图片)
        - [视频](#视频)
        - [串联图片](#串联图片)
        - [帧解锁视图](#帧解锁视图)
            - [loop](#loop)
        - [遮罩](#遮罩)

<!-- /TOC -->



## TODO

## 基础功能
### 文本
* `showStyle` 为 0 是灯从左到右不断重复，为 1 时 灯到了右边再返回左边。如果为 1 且有多个灯，则要到最左边的灯到右边时才返回。
* `tileMode` 为 `STRETCH` 时，文本再长也只有一个灯；为 `LOOP` 时，会根据文本长度增加灯的数量。
* `<PathItem>` 中的坐标都是相对于 `<Text>` 中的 x 和 y 的。

### 图片
* 图片作为背景时，设置 `isBackground="true"` 和 `scaleType="center_crop"`，图片会按照屏幕宽高的比例进行缩放，使图片居中充满整个屏幕，多余部分裁剪，实现多机型的适配
* 动态图片的 `save` 属性为 1 时就会保存至手机，虽然文档写的是要大于 1

### 视频
* 视频作为背景时，设置 `isBackground="true"` 和 `scaleType="center_crop"`，图片会按照屏幕宽高的比例进行缩放，使图片居中充满整个屏幕，多余部分裁剪，实现多机型的适配

### 串联图片
1. 比如你想用图片来组合成字符串 `"Aa/Bb/Cc/Dd/"`，也就是其中每个字符都用一张对应的图片来显示，那么一共需要 9 张图片。
2. 实现如下
    ```xml
    <ImageSeries x="200" y="750" space="10" 
        src="letter.png" string="Aa/Bb/Cc/Dd/" mapList="aa,bb,cc,dd,Aaa,Bbb,Ccc,Ddd,/dot" />
    ```
    * `string` 属性：要用图片显示的字符串；
    * `src` 属性：9 张图片的文件名需要用共同的前缀 `letter_` 且都是 `png`  格式。
    * `mapList` 属性：每个字符和图片名的映射关系，用逗号分割每一项：
        1. 每项的首字母是要转换为图片的那个字符，后面的一个或多个字符是对应的图片的名称后缀；
        2. 例如 `aa` 表示把字符 `a` 映射为图片 `letter_a.png`， `Aaa` 表示把字符 `A` 映射为图片 `letter_aa.png`， `/dot` 表示把字符 `/` 映射为图片 `letter_dot.png`。
        3. 这里没有把字符 `A` 映射为图片 `letter_A.png`，是因为在目录中不区分文件名字母大小写，所以不能和 `letter_a.png` 混淆。
    
### 帧解锁视图
TODO，逻辑混乱

#### loop
* `loop` 为 `false` 时：
    * 如果不点击或长按屏幕
    * 在当前帧数小于 `unlockTo` 设置的帧数时点击屏幕，以每次 3 帧的速度回退，如果不能刚好退到首帧，则会停在第二或第三帧。例如首帧是 0 时：
        * 如果从 8 帧回退，会依次显示 5 帧、2 帧，并停在 2 帧；
        * 如果从 7 帧回退，会依次显示 4 帧、1 帧，并停在 1 帧；
        * 如果从 6 帧回退，会依次显示 3 帧、0 帧，并停在 0 帧；
    * 在当前帧数大于等于 `unlockTo` 设置的帧数时点击屏幕，立刻停止。
    * 在当前帧数小于 `unlockTo` 设置的帧数时长按屏幕，则序列帧会继续进行并停留在  `unlockTo`；
    * 在当前帧数大于等于 `unlockTo` 设置的帧数时长按屏幕，立刻停止。
* `loop` 为 `true` 时：
    * 如果不点击或长按屏幕，动画会一直进行



### 遮罩
1. TODO 和文档说的不一样
2. 用一下代码测试，`hybridMode` 测试不同模式
    ```xml
    <Image x="0" y="400" w="400" h="400"
        src="test/tumblr.jpg">
        <Mask x="50" y="50" w="400" h="400" src="test/mask.png" align="relative"
            hybridMode="6" />
    </Image>
    ```
3. 第一张图的第一列是 0~2，第二列是 3~5，第二张图的第一列是 6~8，第二列是 9~11
    <img src="./images/mask0-5.jpg" width="600" style="display: block; margin: 5px 0 10px;" />
    <img src="./images/mask6-11.jpg" width="600" style="display: block; margin: 5px 0 10px;" />
4. 区分图片重叠和像素重叠：如果遮罩是没有透明部分的，则图片重叠部分和像素重叠部分是一样的；如果有透明部分，则像素重叠部分只是遮罩中有像素的区域与源图片重叠的区域。
    * clear：遮罩图片不显示，源图片中图片重叠部分不显示。
    * ori：遮罩图片正常显示，源图片中图片重叠部分不显示。
    * tgt：遮罩图片不显示
    * oriOver：遮罩图片渲染到源图片之上。
    * rgtOver：源图片渲染到遮罩图片之上。
    * oriIn：源图片图片重叠部分被删除，遮罩图片正藏显示。
    * tgtIn：遮罩图片不显示；遮罩图片和源图片的重叠部分中，遮罩图片有像素的区域，源图片保留该区域，其他区域删除
    * oriOut：遮罩图片不显示；源图片图片重叠部分直接删除。
    * gtgOut：遮罩图片不显示；源图片像素重叠部分不显示。
    * oriATop：遮罩图片直接覆盖到源图片上
    * rgtATop：遮罩图片不显示；遮罩图片和源图片的重叠部分中，遮罩图片有像素的区域，源图片保留该区域，其他区域删除
    * xor：遮罩图片不显示；源图片像素重叠部分不显示。