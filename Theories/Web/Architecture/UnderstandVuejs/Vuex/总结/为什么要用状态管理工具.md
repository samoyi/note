# 为什么要用状态管理工具


## 一个很简单的状态模式
```js
new Vue({

    // state
    data () {
        return {
            count: 0
        };
    },

    // view
    template: `
        <div @click="increment">{{ count }}</div>
    `,

    // actions
    methods: {
        increment () {
            this.count++;
        },
    },
}).$mount('#app');
```
1. 这个应用的状态管理模式包含以下三个组成部分：
    * **state**，驱动应用的数据源。也就是这里的`count`
    * **view**，以声明方式将 state 映射到视图。也就是这里的`{{ count }}`
    * **actions**，响应在 view 上的用户输入导致的状态变化。也就是这里的`increment`
2. 状态管理模式原理上是很简单的：
    1. 用 state 的值更新 view
    2. view 得到输入后，触发相应的 action
    3. action 修改 state
    4. 进一步的循环，state 再更新 view
3. 对于本例来说，实际上的状态模式也是如此简单：
    1. 用 `count` 的值更新 `{{ count }}`
    2. view 得到输入后，触发`increment`
    3. `increment` 修改 `count`
    4. `count` 再更新 `{{ count }}`

<img src="../image/flow.png" alt="最简单状态管理模式" width="600" />


## 复杂的状态模式
### 多层结构下的状态依赖
1. 假如现在是一个5层嵌套的组件结构，你要把最外层的状态传递到最内层，应该怎么做呢？
2. 通过 prop 只能给子组件传参，你只能逐层使用 prop 传递。对于中间3层组件来说，它们添加
这个 prop 的意义完全是帮忙传递数据。甚至，你并不是总能修改中间那些组件，因为那或许是公用
组件。
3. 或者你定义了一个方法，通过4次引用`ref`来找到最能层的实例。这本身就够复杂的了，而如果
日后中间的3层又少了一层或多了一层，你还得重新修改你的那个方法，让它重新引用到正确的实例。
4. 还有[依赖注入](https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5)
可以方便的跨层，但它传递的数据却是非响应的。

### 多层结构下的状态变更
还是上面的5层嵌套结构，如果最内层想改变最外层的一个数据，要么一层一层向外 emit，要么一
层一层引用`$parent`。但显然从上面的描述来看，这两个方法都是很麻烦甚至不可行的。


## 全局单例状态管理 —— Vuex 模式
1. 每个组件维护自己组件的状态是很好的，但是如果自己组件的状态并不是独有的，而是要和子组
件或者兄弟组件共享的话，那还放在自己组件内部维护，并且像上面描述的很复杂的去共享和共同改
变，就是不现实的。
2. 因此，需要一个第三方来统一维护这些共享的状态。这个第三方可以统一分发依赖给需要的组件，
而不需要组件之间使用复杂的方法传递；每个组件对共享状态的修改，也都会直接提交给第三方，同
样不再需要在组件之间复杂的传递修改。
3. 这个第三方，就成了一个独立的**state**；而去除了共享状态的组件们，就共同组成了一个
**view**（一些组件内部只包含一些私有的 state）；这个独立的 state 会提供一套状态更新接
口，即一套**actions**，view 中的组件如果要修改共享状态，调用这些更新接口提交 action 来
修改共享状态。

<img src="../image/vuex.png" alt="vuex 状态管理模式" width="600" />
