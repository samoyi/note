# MVVM 框架解决的核心问题


<!-- TOC -->

- [MVVM 框架解决的核心问题](#mvvm-框架解决的核心问题)
    - [设计思想](#设计思想)
    - [命令式视图更新的问题](#命令式视图更新的问题)
        - [增加从 Model 层到 View 的映射复杂度](#增加从-model-层到-view-的映射复杂度)
        - [向响应式靠近](#向响应式靠近)
        - [实现响应式](#实现响应式)
    - [关注点分离和单一职责原则](#关注点分离和单一职责原则)
    - [MVVM 框架适用场景](#mvvm-框架适用场景)
    - [References](#references)

<!-- /TOC -->


## 设计思想
* 意图与实现分离：隐藏更新视图的具体操作，只暴露给用户简单的指令。
* OCP：数据是变化的，但渲染机制可以不变。


## 命令式视图更新的问题
1. 命令式视图更新是直接用 JavaScript 操作 DOM，视图更新必须通过明确的命令进行，也就是手动的修改 DOM。
2. 考虑一个购物车物品数量的情况：Model 层有一个购物车物品数量的变量，这个变量会决定 View 层三处渲染：
    * 购物车角标中的数字
    * 结算按钮是否可点击
    * 购物车页面是显示商品列表还是显示购物提醒
3. 有三种情况可以更新购物车商品数量，分别是：
    * 页面初始渲染时需要从服务端加载一个商品数；
    * 用户添加商品会增加商品数；
    * 用户从购物车移除商品会减少商品数。
4. 如果使用命令式视图更新，处理上述各种可能的情况，会有哪些不便之处呢？

### 增加从 Model 层到 View 的映射复杂度
1. 在这个例子中，逻辑上来讲，Model 层的商品数量到 View 层的三处渲染，是简单的一到三的映射关系的。对于整个应用来说，单纯的看从 Model 层到 View 的映射都是比较简单的，可以清晰的看出整个应用的逻辑关系。
2. 但是，要实现为可用的应用，就不是映射关系这么简单了，尤其是在使用命令式视图更新时。因为我们并不是修改了 Model 层的数据后 View 层就自动变化了，我们必须要编写命令来操作 DOM 去修改 View 层。
3. 具体来说，在 Model 层的商品数量变化后，根据当前商品数，我们需要进行如下操作：
    * 更新角标中的数字；
    * 根据商品数是否大于零，确定结算按钮能否点击；
    * 根据商品数是否大于零，确定页面显示商品列表还是购物提醒。
4. 我们的意图很明显，为了实现从 Model 层到 View 层的更新，但实现很复杂。关键是没有做到意图与实现分离。
5. 上面的代码实现可能会是这样的
    ```js
    const cart = document.querySelector(".cart");

    // 根据商品数量来确定能否点击结算按钮
    cart.querySelector(".settle").addEventListener("click", () => {
        if (count === 0) {
            return;
        }
        else {
            settle();
        }
    });

    // 更新角标数字
    cart.querySelector(".badge").innerText = count;

    // 根据商品数量确定按钮颜色以及显示商品列表还是购物体型
    if (count === 0) {
        cart.querySelector(".settle").style.backgroundColor = "gray";
        cart.querySelector(".content .tip").style.display = "block";
        cart.querySelector(".content .list").style.display = "none";
    }
    else {
        cart.querySelector(".settle").style.backgroundColor = "red";
        cart.querySelector(".content .tip").style.display = "none";
        cart.querySelector(".content .list").style.display = "block";
    }
    ```
6. 使用 jQuery 会简单一些，但本质上还是一样的，都是直接暴露了意图的具体实现。
7. 为了实现这样的更新要编写很多命令代码，对于整个应用来说，大量的代码都是为了实现本来简单的映射更新。渐渐地，上面简单的映射关系就淹没在这些具体的命令代码中了，我们也越难越理解程序的逻辑。

### 向响应式靠近
1. 面对上面复杂的情况，我们会想到的优化就是对更新 View 的操作进行封装。比如在 Model 层的商品数变化后要执行的操作封装为一个函数，这个函数保存在其他地方，我们不用看它也不用管它，只要在商品数量变化是调用这个函数就行了。
2. 例如我们把上面的代码封装为一个函数 `updateByCartCount`，然后保存到其他文件里。在上面说到的三个更新商品数量的地方分别调用这个函数就行了
    ```js
    updateByCartCount(count);
    ```
3. 看起来很不错，很好的将意图和实现分离。虽然我们没有彻底的实现 Model 层变化后 View 层自动更新，但现在只需要一行代码了。虽然没有完全做到响应式，但已经很好了。
4. 如果这个程序中每个从 Model 层到 View 的映射都这样实现，程序的逻辑就会清晰很多：我们理解程序业务逻辑的不需要去看哪些封装的代码，只看这些命名良好意图明确的接口函数就行了。
5. 但是我们的工作量其实并没有减轻很多，因为 `updateByCartCount` 的内部逻辑并没有简化，只不过是封装起来并提供了接口而已。
6. 之后的每一组映射关系我们依然要做这么多事情，之后的每个项目也依然要做这么多事情。能不能把这个这些被封装的 DOM 操作通用化，使得我们不用再编写具体的操作，而直接调用通用的接口？

### 实现响应式
1. 要实现通用的接口，显然内部实现不能依赖具体的环境，不能像上面的封装那样，在实现的内部直接使用 `cart` 节点、业务相关的颜色等。这些数据必须是通过类似于参数的方式传递给内部实现。
2. 而且，一个功能越要通用，它就越要简单。例如 `updateByCartCount` 这个功能显然不能通用，毕竟不是大部分应用都要根据购物车数量来更新角标数、按钮状态和页面内容。
3. 所以我们必须要拆分出简单通用的功能。例如，`updateByCartCount` 可以拆分为以下简单通用的功能：
    * 根据数据更新某个节点的文本：可以实现根据商品数量更新角标中数字；
    * 根据数据更新某个节点的样式：可以实现根据商品数量更新颜色；
    * 根据数据更新某个节点是否隐藏：可以实现根据商品数量确定显示列表还是提醒。
4. 上面这三个功能都是很通用的，实际上 jQuery 都进行了这样的 DOM 操作封装。但是 jQuery 只能说是简化了原生的 DOM 操作的语法，并没有性质上的改变。如果使用 jQuery 改写上面的那段代码，其实总的行数少不了多少，只不过每行的代码变少了。
5. 如果实现了真正的响应式，用户就不需要再操作 DOM，只需要进行一次 View 到 Model 的绑定，之后数据变化就会自动更新 View。
6. 例如，把一个节点的 `innerText` 绑定到一个数据上，则数据是什么，该节点的 `innerText` 就显示什么。这种绑定在 Vue 中就是通过 `{{}}` 语法。
7. 具体的流程，以上面购物车为例，简单的说就是
    1. 在 HTML 中进行绑定 `<span>{{ count }}</span>`。
    2. Vue 在编译 HTML 时会发现上述绑定，就会把 `{{ count }}` 替换成 `count` 对应的数字。同时会记下来这个节点的 `innerText` 绑定到了 `count` 变量，以便后序更新。
    3. 之后 Vue 发现 `count` 变化时，就把新的值更新到上面节点的 `innerText`。
    4. Vue 之所以能发现 `count` 变化并获得 `count` 新的值，是通过 `Object.defineProperty()` 将数据变为响应式的。


## 关注点分离和单一职责原则
1. 命令式编程中，你除了要处理 Model 层的数据，还要去处理的 View 层。
2. 而从 Model 到 View 的映射常常是一对多的关系，就像上面一个购物车商品数对应三处页面渲染一样。所以在这种情况下开发过程中主要的精力是花在 View 层。
3. 现在有了响应式编程，对 View 层的处理就只是一些简单的绑定工作，相比于命令式大大节省了精力。
4. 这里不仅仅是简单的关注点分离，不仅仅是把 Model 层操作和 View 层操作分离，更重要的是直接把 View 层操作分离给了第三方框架。
5. 以前连接 Model 层和 View 层的是用户自己编写的 DOM 操作代码，现在负责这部分工作的是第三方框架，也就是 MVVM（Model–View–ViewModel）架构中的 ViewModel
<img src="../images/VueMVVM.png" width="600" style="display: block; margin: 5px 0 10px;" />


## MVVM 框架适用场景
1. 从上面的分析可以看出来，框架解决的就是根据 Model 层来更新 View 层的问题。
2. 所以，如果应用中从 Model 层到 View 层的映射越多、越复杂，就越适合使用框架。
3. 映射数量越多就是 Model 层中影响 View 层的数据越多；
4. 映射越复杂就是 Model 从中的一个数据可能会影响 View 层中的多个地方。


## References
* [Does your web app need a front-end framework?](https://stackoverflow.blog/2020/02/03/is-it-time-for-a-front-end-framework/)