# Performance


<!-- TOC -->

- [Performance](#performance)
    - [概述](#概述)
    - [页面加载优化​](#页面加载优化​)
        - [是否要前端渲染](#是否要前端渲染)
        - [包体积与 Tree-shaking 优化​](#包体积与-tree-shaking-优化​)
            - [尽可能地采用构建（build）步骤](#尽可能地采用构建build步骤)
            - [谨慎引入依赖](#谨慎引入依赖)
            - [如果需要渐进式使用 Vue](#如果需要渐进式使用-vue)
        - [代码分割​](#代码分割​)
    - [更新优化​](#更新优化​)
        - [Props 稳定性](#props-稳定性)
        - [`v-once`](#v-once)
        - [`v-memo`](#v-memo)
    - [通用优化](#通用优化)
        - [虚拟列表](#虚拟列表)
        - [减少大型不可变数据的响应性开销​](#减少大型不可变数据的响应性开销​)
        - [避免不必要的组件抽象​](#避免不必要的组件抽象​)
    - [References](#references)

<!-- /TOC -->


## 概述
1. 首先，让我们区分一下 web 应用性能的两个主要方面：
    * **页面加载性能**：首次访问时，应用展示出内容与达到可交互状态的速度。这通常会用 Google 所定义的一系列 Web 指标 (Web Vitals) 来进行衡量，如最大内容绘制 (Largest Contentful Paint，缩写为 LCP) 和首次输入延迟 (First Input Delay，缩写为 FID)。
    * **更新性能**：应用响应用户输入更新的速度。比如当用户在搜索框中输入时结果列表的更新速度，或者用户在一个单页面应用 (SPA) 中点击链接跳转页面时的切换速度。
2. 虽然最理想的情况是将两者都最大化，但是不同的前端架构往往会影响到在这些方面是否能达到更理想的性能。此外，你所构建的应用的类型极大地影响了你在性能方面应该优先考虑的问题。因此，优化性能的第一步是为你的应用类型确定合适的架构。


## 页面加载优化​
页面加载优化有许多跟框架无关的方面 - 这份 [web.dev 指南](https://web.dev/fast/) 提供了一个全面的总结。这里，我们将主要关注和 Vue 相关的技巧。

### 是否要前端渲染
1. 如果你的用例对页面加载性能很敏感，请避免将其部署为纯客户端的 SPA，而是让服务器直接发送包含用户想要查看的内容的 HTML 代码。
2. 纯客户端渲染存在首屏加载缓慢的问题，这可以通过服务器端渲染 (SSR) 或静态站点生成 (SSG) 来缓解。
3. 如果应用对交互性要求不高，你还可以使用传统的后端服务器来渲染 HTML，并在客户端使用 Vue 对其进行增强。
4. 如果你的主应用必须是 SPA，但还有其他的营销相关页面 (落地页、关于页、博客等)，请单独部署这些页面。理想情况下，营销页面应该是包含尽可能少 JS 的静态 HTML，并用 SSG 方式部署。

### 包体积与 Tree-shaking 优化​
一个最有效的提升页面加载速度的方法就是压缩 JavaScript 打包产物的体积。当使用 Vue 时有下面一些办法来减小打包产物体积。

#### 尽可能地采用构建（build）步骤
1. 如果使用的是相对现代的打包工具，许多 Vue 的 API 都是可以被 tree-shake 的。举例来说，如果你根本没有使用到内置的 `<Transition>` 组件，它将不会被打包进入最终的产物里。
2. Tree-shaking 也可以移除你源代码中其他未使用到的模块。
3. 当使用了构建步骤时，模板会被预编译，因此我们无须在浏览器中载入 Vue 编译器。这在同样最小化加上 gzip 优化下会相对缩小 14kb 并避免运行时的编译开销。

#### 谨慎引入依赖
1. 在引入新的依赖项时要小心包体积膨胀。在现实的应用中，包体积膨胀通常因为无意识地引入了过重的依赖导致的。
2. 如果使用了构建步骤，应当尽量选择提供 ES 模块格式的依赖，它们对 tree-shaking 更友好。举例来说，选择 lodash-es 比 lodash 更好。
3. 查看依赖的体积，并评估与其所提供的功能之间的性价比。如果依赖对 tree-shaking 友好，实际增加的体积大小将取决于你从它之中导入的 API。像 bundlejs.com 这样的工具可以用来做快速的检查，但是根据实际的构建设置来评估总是最准确的。

#### 如果需要渐进式使用 Vue
如果你只在渐进式增强的场景下使用 Vue，并想要避免使用构建步骤，请考虑使用 petite-vue (只有 6kb) 来代替。

### 代码分割​
1. 代码分割是指构建工具将构建后的 JavaScript 包拆分为多个较小的，可以按需或并行加载的文件。
2. 通过适当的代码分割，页面加载时需要的功能可以立即下载，而额外的块只在需要时才加载，从而提高性能。
3. 像 Rollup (Vite 就是基于它之上开发的) 或者 webpack 这样的打包工具可以通过分析 ESM 动态导入的语法来自动进行代码分割：
    ```js
    // lazy.js 及其依赖会被拆分到一个单独的文件中
    // 并只在 `loadLazy()` 调用时才加载
    function loadLazy() {
        return import('./lazy.js')
    }
    ```
4. 懒加载对于页面初次加载时的优化帮助极大，它帮助应用暂时略过了那些不是立即需要的功能。在 Vue 应用中，这可以与 Vue 的异步组件搭配使用，为组件树创建分离的代码块：
    ```js
    import { defineAsyncComponent } from 'vue'

    // 会为 Foo.vue 及其依赖创建单独的一个块
    // 它只会按需加载
    //（即该异步组件在页面中被渲染时）
    const Foo = defineAsyncComponent(() => import('./Foo.vue'))
    ```
5. 对于使用了 Vue Router 的应用，强烈建议使用异步组件作为路由组件。Vue Router 已经显性地支持了独立于 defineAsyncComponent 的懒加载。查看 [路由懒加载](https://router.vuejs.org/zh/guide/advanced/lazy-loading.html)了解更多细节。   


## 更新优化​
### Props 稳定性
减少非必要的 props 导致的组件更新

### `v-once`
静态组件

### `v-memo`
注意和 React 中 `memo` 有所不同：
* 不是根据 props，而是根据设定的数组项
* 还可用于普通元素


## 通用优化
### 虚拟列表
使用社区库

### 减少大型不可变数据的响应性开销​
1. 如果只想让对象顶层实现响应式，而不需要让它的各层内部属性实现响应式，可以使用 `shallowRef()` 和 `shallowReactive()` 来绕开深度响应。
2. 但只有在处理超大型数组或层级很深的对象时，例如一次渲染需要访问 100,000+ 个属性时，才值得做这种优化。

### 避免不必要的组件抽象​
1. 有些时候我们会去创建无渲染组件或高阶组件 (用来渲染具有额外 props 的其他组件) 来实现更好的抽象或代码组织。2. 虽然这并没有什么问题，但请记住，组件实例比普通 DOM 节点要昂贵得多，而且为了逻辑抽象创建太多组件实例将会导致性能损失。
3. 需要提醒的是，只减少几个组件实例对于性能不会有明显的改善，所以如果一个用于抽象的组件在应用中只会渲染几次，就不用操心去优化它了。考虑这种优化的最佳场景还是在大型列表中。想象一下一个有 100 项的列表，每项的组件都包含许多子组件。在这里去掉一个不必要的组件抽象，可能会减少数百个组件实例的无谓性能消耗。


## References
* [Vue 性能优化](https://cn.vuejs.org/guide/best-practices/performance.html)
* [快速加载](https://zh-hans.legacy.reactjs.org/docs/optimizing-performance.html)