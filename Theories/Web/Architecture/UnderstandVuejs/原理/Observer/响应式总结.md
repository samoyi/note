# 响应式总结


<!-- TOC -->

- [响应式总结](#响应式总结)
    - [Observe 阶段：实现响应式、创建发布者](#observe-阶段实现响应式创建发布者)
    - [订阅阶段：创建订阅者、订阅依赖数据](#订阅阶段创建订阅者订阅依赖数据)
        - [创建订阅者](#创建订阅者)
        - [订阅依赖数据](#订阅依赖数据)
        - [本阶段其他工作](#本阶段其他工作)
    - [数据更新阶段](#数据更新阶段)
        - [异步更新](#异步更新)
        - [更新防抖](#更新防抖)
    - [`Observer`、`Dep` 和 `Watcher` 三者关系总结](#observerdep-和-watcher-三者关系总结)
    - [其他问题](#其他问题)
        - [有几个数组方法是怎么实现响应式的](#有几个数组方法是怎么实现响应式的)
    - [References](#references)

<!-- /TOC -->


<img src="../../images/ReactivitySystem.png" width="600" style="display: block; margin: 5px 0 10px;" />
<img src="../images/01.awebp" width="800" style="display: block; margin: 5px 0 10px;" />


## Observe 阶段：实现响应式、创建发布者
1. `Observer` 构造函数会遍历 `data`，为每一条数据创建一个 `Dep` 实例 `dep`，该实例代表着 view 层所依赖的数据。
2. `dep` 是 发布-订阅 模式中的发布者。`dep` 会有一个订阅者列表属性，用来保存依赖自己的订阅者（`Watcher` 实例）；还有一个添加订阅者的方法，以及在数据更新后通知订阅者更新的方法。
3. `Observer` 同时会把调动相关函数把该数据转换为访问器属性，其中的 setter 函数中会调用该数据的 `dep` 的通知订阅者更新的方法。
4. 同时也会定义数据的 getter，之后在模板对应的渲染函数被调用时进行依赖订阅。下述。


## 订阅阶段：创建订阅者、订阅依赖数据
1. 在模板编译时，会记录每个节点上面的 Vue 指令，以及指令依赖的数据。
2. 之后模板被编译为渲染函数，渲染函数被调用时，在生成虚拟 DOM 的同时，也会遍历所有的节点，并读取到每个节点的执行和指令值。
3. 在这个阶段，会为每个依赖数据的节点创建订阅者，并且订阅依赖数据。

### 创建订阅者
1. 当扫描到某个节点有依赖数据的指令时，会为给节点创建一个 `Watcher` 实例 `watcher`，之后会作为订阅者注册到它依赖的数据的 `dep` 里。
2. 传给 `Watcher` 构造函数是根据指令类型编译生成的一个渲染表达式，这个表达式中会包含依赖的数据，之后依赖如果更新，可以调用该表达式对节点进行更新渲染。
3. 然后通过指令中依赖的数据，找到数据对应的 `dep`，把 `watcher` 注册到该 `dep` 上。

### 订阅依赖数据
1. 但问题是，模板里只有数据的名称字符串，根据该字符串并不能找到数据对应的 `dep`。
2. 上面说到 observe 阶段为每个数据定义 getter，而 getter 引用了该数据的 `dep`。
3. 创建 `watcher` 后会对渲染表达式首次调用，里面就会访问到依赖数据，触发依赖数据的 getter，而 getter 里面就有绑定 `watcher` 的逻辑。
4. 不过问题还是没解决，因为虽然 getter 里面有 `dep`，但是访问不到这里的 `watcher`，并不能把 `watcher` 传递到 getter 里面。
5. Vue 的解决方法是，定义了一个可以公共访问的静态属性 `Dep.target` 来保存当前 `watcher`，这样在 `dep` 的 getter 被调用时就可以通过 `Dep.target` 拿到当前正在求值的 `watcher`。
6. 具体来说，`Watcher` 构造函数调用的最后，会调用一个 `get` 方法，该方法会把 `this`（也就是当前 `watcher`）设置为 `Dep.target` 并调用刚才接收到的渲染表达式，这样就会访问到依赖的数据，也就是调用依赖数据的 getter。
7. 依赖数据的 getter 内部读取到 `Dep.target`，把它加入到自己 `dep` 的订阅列表里。
8. `get` 方法的最后会删掉 `Dep.target` 指向的 `watcher`，不影响后续的绑定。

### 本阶段其他工作
1. 如果扫描到某个节点有比如 `'v-on'` 事件绑定指令时，会使用原生 JavaScript 方法为该节点绑定指令中的事件类型和处理函数。
2. 另外，上面在订阅依赖的时候会首次调用渲染表达式，因此可以将带 Vue 指令的节点转换为的真实 HTML 节点，并完成页面渲染。
3. 这两个工作不涉及响应式。


## 数据更新阶段
1. 依赖的数据更新后，触发数据的 setter。setter 回检查更新的值是否和以前的一样，如果不一样，最后会调用 `dep` 的 `notify` 方法通知更新。
2. `notify` 方法会依次调用每个 `watcher` 的 `update` 方法。`update` 方法最终会调用 `watcher` 的 `get` 方法重新调用渲染表达式。

### 异步更新
1. `watcher` 的 `update` 方法有两种更新情况，一种是立刻的同步更新，不过多数场景下是异步更新。
2. 异步更新的方法是把当前 `watcher` 加入到一个更新队列里，然后等到 nextTick，再按一定顺序调用队列里每个 `watcher` 的 `get` 方法进行更新。

### 更新防抖
1. 在一个事件循环里一个数据多次更新，但 nextTick 实际更新渲染时只会用最后一次更新的值进行。
2. 这里的机制上，虽然每次更新都会更新当前数据的值，但是每一轮一个 `watcher` 只能加入一次异步更新队列（根据 `watcher.id` 判断）。


## `Observer`、`Dep` 和 `Watcher` 三者关系总结
1. `Observer` 负责响应式的整体工作，它发起为数据创建 `Dep` 实例，并设置数据的 getter 和 setter。
2. `Dep` 是作为数据的发布者对象，负责收集、维护订阅者和更新通知的工作。
3. `Watcher` 是节点的订阅者对象，它接收节点的渲染表达式，在数据更新后调用表达式更新节点。
4. 时间顺序是：初始化 Vue 实例的时候会对 `data` 进行 observe，此时创建  `Dep` 实例并设置  getter 和 setter；编译模板生成的渲染函数被调用的时候访问节点、创建订阅者并绑定依赖。


## 其他问题
### 有几个数组方法是怎么实现响应式的
1. 因为数组方法并不是直接对数组的修改，所以即使一个数组实现了响应式，它的方法也不是响应式。
2. 但 Vue 对几个数组方法进行了包装，并组成了一个对象，作为被 observe 的数组的原型对象。源码在 `/src/core/observer/array.js`。
3. 具体的包装方法，是在调用了一个数组方法的原始方法之后，再通过 `this.__ob__` 获得数组的 `Observer` 实例，进而找到数组的 `dep`，调用其上的 `notify` 方法通知更新。


## References
* [剖析 Vue.js 内部运行机制](https://juejin.cn/book/6844733705089449991/section/6844733705211084808)