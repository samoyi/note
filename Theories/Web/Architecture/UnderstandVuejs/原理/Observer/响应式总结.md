# 响应式总结


<!-- TOC -->

- [响应式总结](#响应式总结)
    - [Observe 阶段：实现响应式、创建发布者](#observe-阶段实现响应式创建发布者)
    - [模板编译阶段：创建订阅者、订阅依赖数据](#模板编译阶段创建订阅者订阅依赖数据)
        - [创建订阅者](#创建订阅者)
        - [订阅依赖数据](#订阅依赖数据)
        - [本阶段其他工作](#本阶段其他工作)
    - [数据更新阶段](#数据更新阶段)
    - [其他问题](#其他问题)
        - [有几个数组方法是怎么实现响应式的](#有几个数组方法是怎么实现响应式的)

<!-- /TOC -->


<img src="../../images/ReactivitySystem.png" width="600" style="display: block; margin: 5px 0 10px;" />


## Observe 阶段：实现响应式、创建发布者
1. `Observer` 模块会遍历 `data`，为每一条数据创建一个 `Dep` 实例 `dep`，该实例代表着 view 层所依赖的数据。
2. `dep` 是 发布-订阅 模式中的发布者。`dep` 会有一个订阅者列表属性，用来保存依赖自己的订阅者（`Watcher` 实例）；还有一个添加订阅者的方法，以及在数据更新后通知订阅者更新的方法。
3. `Observer` 同时会把该数据转换为访问器属性，其中的 setter 函数中会调用该数据的 `dep` 的通知订阅者更新的方法。
4. 同时也会定义数据的 getter，之后在编译模板时进行依赖订阅。下述。


## 模板编译阶段：创建订阅者、订阅依赖数据
### 创建订阅者
1. 当扫描到某个节点有依赖数据的指令时，会为给节点创建一个 `Watcher` 实例 `watcher`，之后会作为订阅者注册到它依赖的数据的 `dep` 里。
2. 传给 `Watcher` 构造函数是根据指令类型编译生成的一个渲染表达式，这个表达式中会包含依赖的数据，之后依赖如果更新，可以调用该表达式对节点进行更新渲染。
3. 然后通过指令中依赖的数据，找到数据对应的 `dep`，把 `watcher` 注册到该 `dep` 上。

### 订阅依赖数据
1. 但问题是，模板里只有数据的名称字符串，根据该字符串并不能找到数据对应的 `dep`。
2. 上面说到 observe 阶段为每个数据定义 getter，而 getter 引用了该数据的 `dep`。
3. 创建 `watcher` 后会对渲染表达式首次调用，里面就会访问到依赖数据，触发依赖数据的 getter，而 getter 里面就有绑定 `watcher` 的逻辑。
4. 不过问题还是没解决，因为虽然 getter 里面有 `dep`，但是访问不到这里的 `watcher`，并不能把 `watcher` 传递到 getter 里面。
5. Vue 的解决方法是，定义了一个可以公共访问的静态属性 `Dep.target` 来保存当前 `watcher`，这样在 `dep` 的 getter 被调用时就可以通过 `Dep.target` 拿到当前正在求值的 `watcher`。
6. 具体来说，`Watcher` 构造函数调用的最后，会调用一个 `get` 方法，该方法会把 `this`（也就是当前 `watcher`）设置为 `Dep.target` 并调用刚才接收到的渲染表达式，这样就会访问到依赖的数据，也就是调用依赖数据的 getter。
7. 依赖数据的 getter 内部读取到 `Dep.target`，把它加入到自己 `dep` 的订阅列表里。
8. `get` 方法的最后会删掉 `Dep.target` 指向的 `watcher`，不影响后续的绑定。

### 本阶段其他工作
1. 编译模板的过程中，如果扫描到某个节点有比如 `'v-on'` 事件绑定指令时，会使用原生 JavaScript 方法为该节点绑定指令中的事件类型和处理函数。
2. 另外，上面在订阅依赖的时候会首次调用渲染表达式，因此可以将带 Vue 指令的节点转换为的真实 HTML 节点，并完成页面渲染。
3. 这两个工作不涉及响应式，放在模板编译的地方分析。


## 数据更新阶段
1. 依赖的数据更新后，触发数据的 setter。setter 回检查更新的值是否和以前的一样，如果不一样，最后会调用 `dep` 的 `notify` 方法通知更新。
2. `notify` 方法会依次调用每个 `watcher` 的 `update` 方法。`update` 方法会调用 `watcher` 的 `get` 方法重新调用渲染表达式。


## 其他问题
### 有几个数组方法是怎么实现响应式的
1. 因为数组方法并不是直接对数组的修改，所以即使一个数组实现了响应式，它的方法也不是响应式。
2. 但 Vue 对几个数组方法进行了包装，并组成了一个对象，作为被 observe 的数组的原型对象。源码在 `/src/core/observer/array.js`。
3. 具体的包装方法，是在调用了一个数组方法的原始方法之后，再通过 `this.__ob__` 获得数组的 `Observer` 实例，进而找到数组的 `dep`，调用其上的通知更新方法。