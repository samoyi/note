# 异步更新


<!-- TOC -->

- [异步更新](#异步更新)
    - [相关信息](#相关信息)
    - [设计思想](#设计思想)
    - [Vue 默认是异步更新 DOM](#vue-默认是异步更新-dom)
        - [`waiting` 和 `flushing` 的区别](#waiting-和-flushing-的区别)
    - [为什么要异步更新视图](#为什么要异步更新视图)
    - [watcher queue](#watcher-queue)
    - [References](#references)

<!-- /TOC -->


## 相关信息
* 源码版本：2.5.21


## 设计思想


## Vue 默认是异步更新 DOM
1. 例子
    ```html
    <template>
        <div>
            <div ref="test">{{test}}</div>
            <button @click="handleClick">tet</button>
        </div>
    </template>
    ```
    ```js
    export default {
        data () {
            return {
                test: 'begin'
            };
        },
        methods () {
            handleClick () {
                this.test = 'end';
                console.log(this.$refs.test.innerText); // 打印 “begin”
            }
        }
    }
    ```
2. 因为 `Watcher` 的 `update` 是如下执行的
    ```js
    // /src/core/observer/watcher.js
    update() {
        if (this.lazy) {
            this.dirty = true;
        } 
        else if (this.sync) {
            this.run();
        } 
        else {
            // 如果没有指定同步更新，那就加入队列等待执行更新
            queueWatcher(this);
        }
    }
    ```
3. `queueWatcher` 默认情况下会把需要更新 watcher 加入一个队列里，然后等到下个 tick 异步更新该队列的所有 watcher
    ```js
    // /src/core/observer/scheduler.js
    export function queueWatcher(watcher: Watcher) {
        const id = watcher.id;
        if ( has[id] == null ) {
            has[id] = true;

            // 加入队列
            if ( !flushing ) {
                queue.push(watcher);
            } 
            else { 
                // if already flushing, splice the watcher based on its id
                // if already past its id, it will be run next immediately.
                let i = queue.length - 1;
                while (i > index && queue[i].id > watcher.id) {
                    i--;
                }
                queue.splice(i + 1, 0, watcher);
            }

            // queue the flush
            if ( !waiting ) {
                waiting = true;

                if (process.env.NODE_ENV !== "production" && !config.async) {
                    flushSchedulerQueue();
                    return;
                }

                // 等到下一个 tick 执行队列里每个 watcher 的更新
                nextTick(flushSchedulerQueue);
            }
        }
    }
    ```

### `waiting` 和 `flushing` 的区别
1. 同步 flush watcher 队列之前，或者把 watcher 队里加入到 nextTick 之前，会进入 waiting 状态。
2. 正式 flush 之前，会进入 flushing 状态。
3. 因此：
    * 如果是同步 flush，是先进入 waiting 状态再紧接着进入 flushing 状态，所以是一起进入状态的；
    * 如果是通过 nextTick 异步 flush，则是在本次 tick 进入 waiting 状态，而在下个 tick 才进入 flushing 状态。
4. flush 结束后，会同时退出 waiting 和 flushing 状态。


## 为什么要异步更新视图
1. 来看一下下面这一段代码
    ```html
    <template>
        <div>
            <div>{{test}}</div>
        </div>
    </template>
    ```
    ```js
    export default {
        data () {
            return {
                test: 0
            };
        },
        mounted () {
            for(let i = 0; i < 1000; i++) {
                this.test++;
            }
        }
    }
    ```
2. 现在有这样的一种情况，mounted 的时候 `test` 的值会循环更新 1000 次。 每次都会根据响应式触发 setter->Dep->Watcher->update->patch。如果这时候没有异步更新视图，那么每次都会直接操作 DOM 更新视图，这是非常消耗性能的。
3. 所以 Vue.js 实现了一个 watcher 队列，在下一个 tick 的时候会统一执行队列中 Watcher 的更新。同时，拥有相同 id 的 watcher 不会被重复加入到队列中去。最终更新视图只会直接将 `test` 对应的 DOM 的 从 0 变成 1000。


## watcher queue
1. 依赖更新后，依赖的 dep 会通过 `notify` 方法调用每个的订阅者（watcher）的 `update` 方法。如果不是明确要同步进行更新，那就会被加入队列等待更新
    ```js
    // core/observer/watcher.js
    
    update () {
        /* istanbul ignore else */
        if (this.lazy) {
            this.dirty = true
        }
        // sync 更新立刻执行
        else if (this.sync) {
            this.run()
        }
        else {
            // 加入队列等待执行
            queueWatcher(this)
        }
    }
    ```
2. 但是如果，一个周期内多次的修改了依赖，那对应的 watch 的 `update` 多次调用，但实际上中间的值都是不需要的，只需要更新为最后一次修改的值就行了。这就需要类似于函数防抖的机制，`queueWatcher` 方法会实现这一机制。看一下 `queueWatcher` 方法
    ```js
    // core/observer/scheduler.js
    
    /**
     * Push a watcher into the watcher queue.
     * Jobs with duplicate IDs will be skipped unless it's
     * pushed when the queue is being flushed.
     */
    export function queueWatcher (watcher: Watcher) {
        const id = watcher.id
        if (has[id] == null) {
            has[id] = true
            if (!flushing) {
                queue.push(watcher)
            }
            else {
                // if already flushing, splice the watcher based on its id
                // if already past its id, it will be run next immediately.
                let i = queue.length - 1
                while (i > index && queue[i].id > watcher.id) {
                    i--
                }
                queue.splice(i + 1, 0, watcher)
            }
            // queue the flush
            if (!waiting) {
                waiting = true
                nextTick(flushSchedulerQueue)
            }
        }
    }
    ```
3. 注意 `if (has[id] == null)`，`has` 是一个 map，里面存放 `id -> null/true` 的形式，用来判断某个 `id` 对应的 watcher 是否已经被添加进队列。默认是 `null`，如果添加后某个 watcher 后，对应 `id` 的值会变成 `true`，因此不会重复添加。
4. `waiting` 是一个标记位，标记是否已经向 `nextTick` 传递了 `flushSchedulerQueue` 方法，在下一个 tick 的时候执行 `flushSchedulerQueue` 方法来 flush 队列 queue，执行它里面的所有 Watcher 对象的 `run` 方法
    ```js
    // core/observer/scheduler.js

    /**
     * Flush both queues and run the watchers.
     */
    function flushSchedulerQueue () {
    flushing = true
    let watcher, id

    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort((a, b) => a.id - b.id)

    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index = 0; index < queue.length; index++) {
        watcher = queue[index]
        id = watcher.id
        has[id] = null
        watcher.run()
        // in dev build, check and stop circular updates.
        if (process.env.NODE_ENV !== 'production' && has[id] != null) {
        circular[id] = (circular[id] || 0) + 1
        if (circular[id] > MAX_UPDATE_COUNT) {
            warn(
            'You may have an infinite update loop ' + (
                watcher.user
                ? `in watcher with expression "${watcher.expression}"`
                : `in a component render function.`
            ),
            watcher.vm
            )
            break
        }
        }
    }

    // keep copies of post queues before resetting state
    const activatedQueue = activatedChildren.slice()
    const updatedQueue = queue.slice()

    resetSchedulerState()

    // call component updated and activated hooks
    callActivatedHooks(activatedQueue)
    callUpdatedHooks(updatedQueue)

    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
        devtools.emit('flush')
    }
    }
    ```
4. 其中还会调用 `resetSchedulerState` 来重置状态
    ```js
    // core/observer/scheduler.js

    /**
     * Reset the scheduler's state.
     */
    function resetSchedulerState () {
    index = queue.length = activatedChildren.length = 0
    has = {}
    if (process.env.NODE_ENV !== 'production') {
        circular = {}
    }
    waiting = flushing = false
    }
    ```
    
    
## References
* [Vue.js异步更新DOM策略及nextTick](https://github.com/answershuto/learnVue/blob/master/docs/Vue.js异步更新DOM策略及nextTick.MarkDown)
