# Cross-Site Request Forgery 跨站点请求伪造


<!-- TOC -->

- [Cross-Site Request Forgery 跨站点请求伪造](#cross-site-request-forgery-跨站点请求伪造)
    - [防御思路](#防御思路)
    - [原理](#原理)
    - [示例](#示例)
        - [伪造转账请求](#伪造转账请求)
        - [Gmail 的 CSRF 漏洞](#gmail-的-csrf-漏洞)
    - [同域或跨域](#同域或跨域)
    - [防御攻击的手段](#防御攻击的手段)
        - [检查来源首部——验证来源](#检查来源首部验证来源)
        - [Anti CSRF Token——验证来源](#anti-csrf-token验证来源)
        - [`SameSite` cookies——禁止或限制第三方请求携带身份信息](#samesite-cookies禁止或限制第三方请求携带身份信息)
        - [验证码——发送请求前让用户知道](#验证码发送请求前让用户知道)
    - [预防攻击的发生](#预防攻击的发生)
    - [References](#references)

<!-- /TOC -->


## 防御思路
1. 先观察问题：跨站请求伪造。分析其中的特征：跨站和伪造。
2. 根据问题特征，可以从跨站和伪造两方面入手来防御。分为一下几个思路：
    * 验证来源：验证是否请求发起自第三方。
    * 禁止或限制第三方请求携带身份信息：第三方请求不能发送 cookie，或者只有指定域才能发送。
    * 发送请求前让用户知道：而不是不明不白就发了请求


## 原理
1. 向服务器提交请求需要 cookie 中验证身份。
2. cookie 的原理是只要往生成该 cookie 的域名发请求就会自动带上 cookie，而不关心这个请求是由谁、在哪儿发起的。
3. 所以攻击者可以在某个地方构造一个用户不期望的请求，诱骗用户进来。
4. 用户进来后该请求自动发送，或者触发用户点击后发送，或者自动加载一个图片，而该图片链接就是一个 get 请求，或者诱使用户点击某个链接而该链接就是一个 get 请求，等等。
5. 请求发送时会自动带上了用户 cookie 中的身份信息。请求成功提交。


## 示例
### 伪造转账请求
1. 由于很多的用户请求是需要通过 cookie 验证身份的，例如发帖、转账等，因此想要伪造这些请求，必须要让请求成功的发送 cookie。
2. 攻击者想要伪造受害者转账给攻击者的请求，该请求是要发送给银行网站 `http://www.bank.com/transfer` 的，银行网站接到该请求的时候会验证 cookie 中的身份信息。
3. 攻击者制作一个网页 `http://www.evil.com`，该网页会自动发送一个转账请求到 `http://www.bank.com/transfer`
4. 诱导受害者进入 `http://www.evil.com`，转账请求就会被发出，同时也会带上受害者的银行 cookie。

### Gmail 的 CSRF 漏洞
1. 一个 Gmail 用户在邮箱里点击了一个攻击者的链接，进入到攻击者网页。
2. 攻击者网页向 Gmail 发送了一个转发邮件的请求，请求 Gmail 把该用户的邮件转发一份到攻击者的服务器。
3. 因为攻击者网页发起的请求也会自动携带 Gmail 的 cookie，所以 Gmail 就同意了这个转发邮件的请求。
4. 之后该用户的邮件都会转发一份到攻击者的服务器。


## 同域或跨域
1. CSRF 一般发生在跨域网站上，因为比较方便随意构造。
2. 但也可以利用同域网站的漏洞发起攻击。
3. 比如同域网站有个发布文章的功能，可以插入第三方图片、链接甚至直接执行脚本。
4. 那攻击者就可以发布一篇文章，当有其他用户进入这篇文章时，就会发送请求。


## 防御攻击的手段
### 检查来源首部——验证来源
1. 请求可能会带上 `Origin` 和 `Referer` 的 header，这两个 header 都含有请求发起的域。
2. 但是这两个 header 都有可能不被发送，甚至被伪造。

### Anti CSRF Token——验证来源
1. 在生成提交页面时，服务器生成一个 token 并保留，然后复制一份到前端页面，一般是放在表单隐藏域里。
2. 用户提交表单时，会一并提交这个 token，服务器验证该 token 是否一致。
3. 如果有人 CSRF，除非他看到了用户的前端代码，否则不会知道这个 token。
4. 如果直接把表单内嵌过来到第三方页面呢？内嵌过来因为是跨域，所以也读取不到表单数据。
5. 生成 token 的信息里可以加上时间戳，后续服务器可以验证是否过期。

### `SameSite` cookies——禁止或限制第三方请求携带身份信息
1. 为 `Set-Cookie` 响应头新增 `Samesite` 属性，可以用它来禁止从第三方页面发起请求时提交该 cookie。
2. 必须要是 HTTPS 请求。
3. [参考](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#SameSite_cookies)

### 验证码——发送请求前让用户知道
1. 图片验证码保证只有用户明确交互才会发送请求。
2. 短信验证码会在短信中说明用户正在进行的操作。


## 预防攻击的发生
1. 前面所说的，都是被攻击的网站如何做好防护。而非预防攻击的发生，CSRF 的攻击可以来自：
    * 攻击者自己的网站。
    * 有文件上传漏洞的网站。
    * 第三方论坛等用户内容。
    * 被攻击网站自己的评论功能等。
2. 对于来自黑客自己的网站，我们无法预防。但对其他情况，可以考虑从以下方面预防
    * 严格管理所有的上传接口，防止任何预期之外的上传内容（例如 HTML）。
    * 添加 Header `X-Content-Type-Options: nosniff` 防止黑客上传 HTML 内容的资源（例如图片）被解析为网页。
    * 对于用户上传的图片，进行转存或者校验。不要直接使用用户填写的图片链接。
    * 当前用户打开其他用户填写的链接时，需告知风险（这也是很多论坛不允许直接在内容中发布外域链接的原因之一，不仅仅是为了用户留存，也有安全考虑）。


## References
* [白帽子讲Web安全](https://book.douban.com/subject/10546925/)
* <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)">WASP</a>
* [What is CSRF?](https://www.educba.com/what-is-csrf/)
* [【基本功】 前端安全系列之二：如何防止CSRF攻击？](https://zhuanlan.zhihu.com/p/46592479)
* [Google’s Gmail security failure leaves my business sabotaged](https://www.davidairey.com/google-gmail-security-hijack/)
