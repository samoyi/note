# 停机问题


## 抽象本质
### 说谎者悖论？


## “停机” 的概念
1. 程序的运行会有两个结果：
    * 该程序会在有限时间内结束运行
    * 该程序永不结束运行
2. 所谓 “结束运行”，可以是正常的运行结束，也可以是因为程序保存然后结束。
3. 一个程序是否会停机，除了程序本身的设计外，还和输入的数据有关系。比如下面的代码中，如果输入的 `x` 是正数，那就不会停机
    ```
    while ( x > 0 ) {

    }
    ```
4. 所以，停机问题就是要判断 “某程序在给定数据下，是否会在有限时间内结束运行” 的问题。
5. 停机问题这里要做出的这个判断，并不是要具体对某一个程序进行判断，而是要实现一个判断规则。准确的说，就是要实现一个判断程序，用这个判断程序来判断其他程序是否会停机。


## 停机判断程序
1. 我们为这个判断程序取名为 `HaltChecker`，它接收两个参数：一个是被判断的程序 `p`，一个是要输入给 `p` 的数据 `d`。
2. 我们的期望是，对于任意的 `p` 和 `d`，`HaltChecker` 可以 **在有限的时间内** 正确的判断出程序 `p` 在接收数据 `d` 的情况下是否会停机。
3. 显然，`HaltChecker` 自己必须是一个永远会停机的程序，否则就没法判断其他程序了。


## `HaltChecker` 不能实现，停机问题不可解
1. 假设 `HaltChecker` 可以实现，那么我们用使用它编写一个函数作为程序
    ```
    SelfLoop ( p ) {
        halts = HaltChecker(p, p);
        if ( halts ) {
            while (1 > 0) {

            }
        }
    }
    ```
2. `SelfLoop` 接收一个程序 `p`，然后把 `p` 同时作为 `HaltChecker` 的两个参数传入，判断是否会停机。
3. 如果程序 `p` 接收自身作为输入会停机，则 `SelfLoop` 不会停机；如果程序 `p` 接收自身作为输入会不会停机，则 `SelfLoop` 会停机。
4. 也就是说，`SelfLoop(p)` 是否会停机的结果，永远会和 `p(p)` 相反。
5. 现在，如果程序 `p` 恰好就是 `SelfLoop`，就会得出：`SelfLoop(SelfLoop)` 是否会停机的结果，永远会和 `SelfLoop(SelfLoop)` 相反。
6. 所以 `HaltChecker` 可以实现的假设不成立。


## References
* [程序员的数学](https://book.douban.com/subject/19949020/)