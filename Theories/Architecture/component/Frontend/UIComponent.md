# UIComponent


## 文档
### UML类图


## 低耦合
1. 开始设计的时候就考虑复用性。
2. 考虑一下几方面的耦合
    * 父子组件的耦合：包括父子组件的通信和引用
    * 对 store 数据的耦合
    * 其他全局数据的耦合
    * UI 组件只负责展示，不应该请求数据和过度的处理数据

### 组件数据来源
1. 四种数据来源：
    * 组件内部的局部数据
    * 通过 prop 获得的父组件数据
    * 通过 mixin 和其他多个同辈组件（也可以包括父组件）共享的数据
    * 通过 store 全局共享的数据
2. 四种数据来源具有不同的耦合度：
    * 组件内部的局部数据是完全独立的，不依赖于外部。
    * 通过 prop 获得的父组件数据不依赖于特定的父组件，只需要确保获得类型正确的数据。
    * 通过 mixin 共享的数据被一组组件共享，耦合于当前组件所在的同辈和父级组件。如果将该组件放在其他组件目录下就会失效。
    * 通过 store 全局共享的数据不和其他组件耦合，但仍然耦合于当前项目全局环境，所以不能作为跨项目公用的基础组件。
3. 所以如果要封装跨项目的基础组件：
    * 不能依赖 store 中的数据，通过 prop 作为 API 接收外部数据。
    * 带封装的基础组件不能依赖外部的 mixin，但可以依赖内部的 mixin，也就是基础组件内部的子组件共享数据。
4. 如果只是封装为项目内部的公共组件    

#### 数据的存放位置
1. 数据只在组件里使用时，应该放在组件内部。
2. 数据是和父组件共享，可以通过 prop 和 emit 来使用。
3. 数据被父组件和多个同辈组件共享，虽然仍然可以通过 prop 和 emit 来使用，但这时已经比较麻烦了，因为需要在使用每个同辈组件时定义 prop 和 emit 监听。
4. 这种情况下可以通过 mixin 和 store 设置独立于父组件和多个同辈组件之外的数据源和修改方法：
    * 但是如果是跨项目的基础组件，则不能使用 store 里的数据；
    * 如果数据只是在父组件和同辈组件间共享，则可以使用 mixin。
5. 数据被父组件和多个子组件共享，但是这几个子组件中至少有一个都不会修改数据，则仍然可以通过 prop 来传递。但这时已经比较麻烦了，因为要一个一个的通过 prop 传递。


使用 mixin 和 store



### props 的扁平度权衡
1. 考虑 *Introduce Parameter Object* 和 *Split Parameter Object* 这两个相反的重构规则。
2. 如果组件接收的参数比较少时，直接接收对象属性而不是对象整体更方便。而且复用起来也会更方便，因为不耦合与对象的结构和属性名。如果传对象的话，就要保证任何使用该组件时，所传的对象都应该有同样的结构和属性名，才能正确的访问到需要的属性值。
3. 如果接受的参数比较多，但是这些参数在逻辑上也不属于一个整体，也不适合封装为一个对象来传递。以为内 “对象” 这种东西应该是有语义的，而不仅仅是形式上的组合，它们应该有内在的联系。不过很多情况下如果传递了多个参数，一般至少其中一部分是有内在联系的，可以作为一个整体对象。
4. 如果只需要传递一个对象中的少量属性的话，也没必要传整个对象。如果属性比较深而要写比较长的属性查询链，应该使用计算属性来封装
    ```html
    <UserInfoCard
        :name="leaderName"
        :age="leaderAge"
    >
    ```
5. 但如果多个参数在逻辑上属于一个整体，那就可以作为一个对象整体来传递。
6. 如果要传递对象并且期望复用的话，这个对象结构就不能耦合于某一类对象，而应该是为该组件定制的一个对象结构，所有调用该组件的地方都要把传递的属性封装为该定制的对象结构。

### ref 和 parent
低耦合

### 对 store 数据的耦合

### 其他全局数据的耦合

### 纯 UI 组件
1. UI 组件应该只负责 UI 的工作，不应该处理数据，包括请求数据和格式化数据。
2. 如果一个组件（可能包含子组件）只是在一个项目里复用，那它可以自己请求数据。请求应该在父组件发起，对返回的数据进行格式化也应该在父组件进行，父组件处理好数据后，分配给纯展示的子组件使用。父组件统一的处理好数据，其他子组件只作为纯 UI 组件。
3. 但如果是复用在多个项目，那就必须封装为纯 UI 组件，完全由组件使用者传递最终的数据。


## state 正确的反映数据结构
1. 考虑 *Introduce Parameter Object* 和 *Split Parameter Object* 这两个相反的重构规则。
2. 如果 state 越不扁平，使用起来肯定会麻烦一些在读取、设置和监听时，需要一层一层的取属性。例如
    ```js
    data () {
        return {
            group: {
                leader: {
                    info: {
                        name: "33",
                        age: 22
                    }
                },
                members: [...]
            }
        }
    }
    ```
    想要读取和设置 `name` 属性时就要写长长的查询链 `this.group.leader.info.name`，不仅麻烦而且容易出错。
3. 但是，**state 作为一个组件的数据源，它应该如实反映组件数据的结构**。所以，不应该为了扁平而破坏数据的逻辑结构。
4. 而且，还有类似于 Vue 中计算属性这样的功能，对于比较深的属性，应该使用计算属性来封装读取。设置也应该通过方法来封装
    ```js
    {
        computed: {
            leaderName () {
                return this.group.leader.info.name;
            },
        },
        methods: {
            setLeaderName (val) {
                this.group.leader.info.name = val;
            },
        }
    }
    ```




## State change purity
TODO，[这篇文章](https://engineering.carsguide.com.au/front-end-component-design-principles-55c5963998c9) 的这个主题没看明白。





## References
* [《重构（第2版）》](https://book.douban.com/subject/33400354/)
* [Front end component design principles](https://engineering.carsguide.com.au/front-end-component-design-principles-55c5963998c9)
