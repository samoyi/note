# 通用的图片浏览组件封装


<!-- TOC -->

- [通用的图片浏览组件封装](#通用的图片浏览组件封装)
    - [思想](#思想)
        - [细粒度抽离组件](#细粒度抽离组件)
    - [术语定义](#术语定义)
    - [支持的功能](#支持的功能)
    - [现状](#现状)
        - [模块结构](#模块结构)
        - [模块高度耦合](#模块高度耦合)
        - [很多大的方法](#很多大的方法)
        - [耦合列表](#耦合列表)
    - [顺序](#顺序)
        - [第一步，基本看懂现有的逻辑](#第一步基本看懂现有的逻辑)
        - [第二步，拆分](#第二步拆分)
    - [便于拆分的情况](#便于拆分的情况)
    - [UML](#uml)
    - [拆分组件要点](#拆分组件要点)
        - [粒度、复用性和依赖](#粒度复用性和依赖)
        - [组件 API](#组件-api)
            - [API 规范](#api-规范)
            - [API 说明](#api-说明)
        - [基础组件](#基础组件)
        - [拆分步骤](#拆分步骤)
    - [mixin](#mixin)
        - [具有内聚性的一组公共操作作为 mixin](#具有内聚性的一组公共操作作为-mixin)
        - [适用范围比较广的属性作为 mixin 或放在 store 里](#适用范围比较广的属性作为-mixin-或放在-store-里)
        - [将计算属性和方法搬移到子组件和 mixin](#将计算属性和方法搬移到子组件和-mixin)
        - [拆分长函数](#拆分长函数)
            - [设置参数逻辑](#设置参数逻辑)
        - [模板字符串拆分为独立的方法或计算属性](#模板字符串拆分为独立的方法或计算属性)
    - [涉及的重构原则](#涉及的重构原则)
        - [小步修改](#小步修改)
        - [意图和实现分离](#意图和实现分离)
    - [语义化](#语义化)
    - [涉及的重构方法](#涉及的重构方法)
        - [Encapsulate Variable](#encapsulate-variable)
        - [Split Parameter Object](#split-parameter-object)
        - [封装条件表达式](#封装条件表达式)
    - [涉及的设计模式](#涉及的设计模式)
        - [中介者模式/享元模式](#中介者模式享元模式)
    - [性能优化](#性能优化)
        - [图片预加载](#图片预加载)
        - [渲染](#渲染)
    - [API 文档](#api-文档)
    - [References](#references)

<!-- /TOC -->


## 思想
### 细粒度抽离组件
* 降低解耦难度
* 降低测试定位难度


## 术语定义
* 组件：对应 `.vue` 文件
* 模块：实现一个独立功能的部分。一个组件会包含一个或多个模块。


## 支持的功能
* 图片拍摄信息展示
* 图片人脸识别
* 可拖动的图片列表缩略图列表
* 图片大图展示
* 图片操作：点赞、收藏、下载、转发


## 现状
* 当前的组件耦合于图片列表页

### 模块结构
* 完整组件
    * 结构头部
        * 显示的头部
            * 图片名称
            * 拍摄信息控件
            * 关闭按钮
        * 显示在主体部分的人脸识别结果（分类有问题，不属于结构头部）
    * 结构主体  
        * 显示的主体，即图片展示区域 
    * 结构底部     
        * 显示在主体部分的未分类部分（分类有问题，不属于结构底部）
            * 图片描述
            * 点赞控件（分类有问题，应该属于结构底部）
            * 下载提示
            * 浏览进度
        * 显示在主体部分的缩略图（分类有问题，不属于结构底部）
        * 显示的底部
            * 查看原图控件
            * 图片操作控件
                * 收藏控件
                * 下载控件
                * 转发控件
                * 管理控件

### 模块高度耦合
1. 组件本身的部分只有一个 `.vue` 文件，长达 2400 行，没有一行注释和文档。
2. 组件内的各个模块相互依赖，各模块的数据和方法在组件内全局可见，互相引用。导致在拆分的时候牵一发而动全身。

### 很多大的方法


### 耦合列表

## 顺序
### 第一步，基本看懂现有的逻辑
1. 整理代码格式，写注释，写文档，构建模块结构图。
2. 本来一上来就准备先把大文件拆小，但由于不知道各模块之间的耦合关系，所以拆分的时候很容易出错。
* 

### 第二步，拆分
* 前期细粒度拆分，*小步修改* 重构原则。
* 从耦合度比较低的模块开始进行拆分，逐步梳理。（*小步修改* 重构原则）
* 本来在同一个组件里的 state 属性，因为现在要拆分组件并且在若干个组件里共享，所以需要进行封装。放在 store，通过 getter 访问，通过 mutation 修改。
* 开始时各模块耦合度很高，拆分难度比较大。这样试图拆分出去的模块越大，就要处理越多的解耦和。因此可以先进行细粒度的拆分，拆分出很多小的组件，每次拆分只需要处理少量的解耦和。等到解耦完成后，再把可以合并的小组件实现高内聚的合并。而且，细粒度的解耦就可以进行细粒度的测试，可以很快的定位拆分导致的错误。（*小步修改* 重构原则）


## 便于拆分的情况
* scss 都是按照嵌套结构的，这样提取出一个模块后，可以快速找到这个模块的所有 scss
* 纯函数。如果方法不直接引用当前组件的属性，那个拆分后就可以补改变方法的内部逻辑，只需要改变参数。


## UML



## 拆分组件要点
### 粒度、复用性和依赖
1. 根据复用需求和复用成本来决定粒度：如果可以在其他地方复用，并且复用时不会明显导致内部逻辑复杂，不会明显增大维护成本，那就可以实现为独立组件。
2. 根据可复用的范围来决定依赖的内容
    * 如果组件将来可被其他项目复用，那只能依赖 prop 和插槽。
    * 如果组件只会被当前项目全局复用，那还可以依赖 store。
    * 如果组件只用在图片浏览功能，那就还可以依赖 mixin。

### 组件 API
#### API 规范
* 主要通过 prop、自定义事件和插槽来使用组件。
* prop 的 `type` 属性提供类型约束，`validator` 方法提供值约束。

#### API 说明
1. 一般情况下直接在组件中进行注释说明。主要包括以下三方面
    * prop
    * 自定义事件
    * 插槽
2. 因为 prop 都是统一放在 `props` 属性里，所以直接在相应的代码中加入注释；自定义事件和插槽并没有统一的位置，所以需要在组件头部统一进行说明。
3. 自定义事件的说明包括：事件名、触发条件和参数说明；插槽的说明包括插槽名、插槽内容、默认内容和作用域插槽的插槽 prop。
4. 示例
    ```html
    <!------------------------------------------------------------------------------------------------->
    <!--  # 查看大图按钮组件                                                                          -->
    <!--                                                                                             -->
    <!--  ## 自定义事件                                                                               -->
    <!--  ### `clickBtn`                                                                             -->
    <!--  * 点击时触发                                                                                -->
    <!--  * 包含一个参数为事件对象                                                                     -->
    <!--                                                                                             -->
    <!--  ## 插槽                                                                                    -->
    <!--  ### 默认插槽                                                                                -->
    <!--  * 插槽内容为按钮文字，默认值为 `查看大图`                                                     -->
    <!--                                                                                             -->
    <!--  ## 组件方法                                                                                 -->
    <!--  ### `$refs.click`                                                                          -->
    <!--  * 模拟按钮点击事件                                                                          -->
    <!------------------------------------------------------------------------------------------------->
    ```

### 基础组件
1. 由于公司没有公共组件库，而且当前项目的组件库也不完善，所以图片浏览部分的一些基础组件都是直接实现的。
2. 涉及的基础组件分为两类：当前项目可以公用的、其他 Vue 项目也可以公用的。
3. 现在对这些基础组件进行封装，以后如果构建公共组件库可以更方便的加入。
4. 当前项目可以公用的    
    * 查看大图按钮
    * 拍摄信息
        * 摄影师名称
        * 数码师名称
        * 拍摄时间
        * 拍摄地点
        * 照片名称 
    * 设备信息
        * 相机品牌
        * 相机型号
        * 镜头
        * 焦距
        * 光圈
        * 快门
        * ISO
        * 曝光
5. 其他 Vue 项目也可以公用的
    * 圆形头像
    * 关闭按钮
    * 信息按钮
    * 点赞按钮
    * 收藏按钮
    * 下载按钮
    * 分享按钮
6. 其中用到的图标为 iconfont 字体图标，其他项目要使用时需要先引入在线字体。

### 拆分步骤
1. 看懂该模块的逻辑，整理修改其中不合理的代码。
2. 罗列出拆分后需要的 prop、emit 和 ref 清单。
3. 分析哪些属性和事件要子组件自己维护，哪些要放在父组件或 mixin，哪些应该放在 store 里。
4. 拆分出去后，根据上面的清单一项项的修改：
    * ref 引用的大部分其实可以转成 prop 加 emit。如果一定要直接操作 DOM，也可以父级通过 prop 传递状态进去，然后子组件内部自己操作 DOM。


## mixin
### 具有内聚性的一组公共操作作为 mixin
例如好几个模块的按钮需要强制授权或手机号登录，那么把强制授权或手机号登录相关的属性和方法提取为独立的 mixin

### 适用范围比较广的属性作为 mixin 或放在 store 里
1. 好几个子组件都会用到的属性，就不用分别作为 prop 传入了然后 emit 修改了，应该放在公共的 mixin 里面或者 store 里
2. store 里面的数据如果好几个子组件都会用到，那么可以放在 mixin 里面，这样各个组件就不用直接从 store 里面去，而是更方便的作为组件属性来获取。而且如果要对 store 里面的数据再包装的话，也方便统一包装。

### 将计算属性和方法搬移到子组件和 mixin
1. 拆分出的子组件中用到的计算属性和方法都是定义在父组件上的，从父组件搬运过来的话，就是隔离在不同的组件作用域里面了。
2. 如果属性和方法适合放到 mixin 里面那就比较方便。否则的话，原来的计算属性和方法中引用的 `data` 上的属性和计算属性，现在方法搬移到子组件之后，`this` 是指向子组件，会发生引用错误。
3. 如果在拆分的过程中就处理好所有的引用关系，那么本项重构的周期会比较长，需要处理好所有的计算属性和方法之后这个子组件才能使用，不符合小步修改的重构原则。
4. 可以直接让子组件直接引用父组件的计算属性和方法。办法是在子组件里定义同名的计算属性和方法，然后在内部引用父组件的计算属性和方法。例如
    ```js
    foo() {
        this.$parent.foo();
    }
    ```
5. 这样就可以快速的拆分出来一个可用的子组件，然后在此基础上逐个修改方法。
6. 这种思路的一个常见问题是，父组件中如果使用了 `$refs.someNode`，现在因为模板的搬移就访问不到了。
7. 我开始想到的解决方法是，在子组件调用父组件时绑定 `this`
    ```js
    foo() {
        this.$parent.foo.call(this);
    }
    ```
8. 但并没有用，发现 Vue 会使用 `bind` 方法把组件的方法绑定到当前组件实例上（源码中的 `initMethods` 方法）。而且居然即使我也使用 `bind` 绑定也不行
    ```js
    foo() {
        this.$parent.foo.bind(this)();
    }
    ```
9. 目前的解决方法只能改动父类中的方法，在其中通过 `$refs` 先引用到子组件再引用到对应的节点
    ```js
    this.$refs.child.$refs.someNode
    ```





### 拆分长函数
包括长计算属性和长方法

#### 设置参数逻辑
1. 例如有一个 64 行的函数，用来初始化一个 Swiper 实例，其中 35 行都是在计算和组装参数对象，显然这部分应该提取出来。
2. 而且 35 行中还有 15 行在拼装模板字符串，模板字符串的格式和规则都根普通 JS 代码不同，看起来比较费劲，所以这部分也应该提取为独立的方法。

### 模板字符串拆分为独立的方法或计算属性
模板字符串的格式和规则都根普通 JS 代码不同，看起来比较费劲，所以这部分也应该提取为独立的方法。


## 涉及的重构原则
### 小步修改
* 先拆分小的、容易理解的、耦合度低的组件
* 拆分出的组件先直接通过 `$parent` 直接引用父级方法和属性，保证组件可用后再处理作用域的问题

### 意图和实现分离
* HTML 模板里面不要放计算逻辑，放进计算属性和方法里

## 语义化
* 区分 `v-if` 和 `v-show` 的计算属性名：前者用 `isRender`，后者用 `isShow`


## 涉及的重构方法

### Encapsulate Variable
拆分组件时公共数据放进 store，通过 getter 访问，通过 mutation 修改。

### Split Parameter Object
给子组件传 prop 时如果子组件只需要对象中的少部分属性，就不要传整个对象。

### 封装条件表达式
HTML 模板中不要写条件表达式，改为计算属性。


## 涉及的设计模式
### 中介者模式/享元模式
原来都在同一个组件里，现在拆分之后需要共享的数据和方法放进 mixin。


## 性能优化
### 图片预加载

### 渲染
该用 `v-show` 的地方不要用 `v-if`。很多时候想用方便的 `v-else`，但如果只是显示隐藏而不是重渲染，那还是应该用 `v-show`


## API 文档
1. 模板中 `.yml` 文件配置图片浏览组件。
2. 需要进行浏览时先设置浏览的图片列表
    ```js
    this.$store.commit("photolist/setPicViewList", photosList);
    ```
3. 传入图片列表中的某个序号，开始图片浏览
    ```js
    // 例如这里从图片列表的第一张开始浏览
    this.$store.commit("photolist/openPicView", 0);
    ```


## References
* [揭秘 Vue.js 九个性能优化技巧](https://juejin.cn/post/6922641008106668045)
