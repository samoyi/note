# 通用的图片浏览组件封装


<!-- TOC -->

- [通用的图片浏览组件封装](#通用的图片浏览组件封装)
    - [思想](#思想)
        - [细粒度抽离组件](#细粒度抽离组件)
    - [术语定义](#术语定义)
    - [支持的功能](#支持的功能)
    - [现状](#现状)
        - [模块结构](#模块结构)
        - [模块高度耦合](#模块高度耦合)
        - [很多大的方法](#很多大的方法)
        - [耦合列表](#耦合列表)
    - [顺序](#顺序)
        - [第一步，基本看懂现有的逻辑](#第一步基本看懂现有的逻辑)
        - [第二步，拆分](#第二步拆分)
    - [便于拆分的情况](#便于拆分的情况)
    - [UML](#uml)
    - [拆分组件要点](#拆分组件要点)
        - [具有内聚性的一组公共操作作为 mixin](#具有内聚性的一组公共操作作为-mixin)
        - [适用范围比较广的属性作为 mixin 或放在 store 里](#适用范围比较广的属性作为-mixin-或放在-store-里)
        - [拆分步骤](#拆分步骤)
    - [涉及的重构方法](#涉及的重构方法)
        - [Encapsulate Variable](#encapsulate-variable)
        - [Split Parameter Object](#split-parameter-object)
    - [涉及的设计模式](#涉及的设计模式)
    - [性能优化](#性能优化)
        - [图片预加载](#图片预加载)
        - [渲染](#渲染)
    - [API 文档](#api-文档)
    - [References](#references)

<!-- /TOC -->


## 思想
### 细粒度抽离组件
* 降低解耦难度
* 降低测试定位难度


## 术语定义
* 组件：对应 `.vue` 文件
* 模块：实现一个独立功能的部分。一个组件会包含一个或多个模块。



## 支持的功能
* 图片拍摄信息展示
* 图片人脸识别
* 可拖动的图片列表缩略图列表
* 图片大图展示
* 图片操作：点赞、收藏、下载、转发


## 现状
* 当前的组件耦合于图片列表页

### 模块结构
* 完整组件
    * 结构头部
        * 显示的头部
            * 图片名称
            * 拍摄信息控件
            * 关闭按钮
        * 显示在主体部分的人脸识别结果（分类有问题，不属于结构头部）
    * 结构主体  
        * 显示的主体，即图片展示区域 
    * 结构底部     
        * 显示在主体部分的未分类部分（分类有问题，不属于结构底部）
            * 图片描述
            * 点赞控件（分类有问题，应该属于结构底部）
            * 下载提示
            * 浏览进度
        * 显示在主体部分的缩略图（分类有问题，不属于结构底部）
        * 显示的底部
            * 查看原图控件
            * 图片操作控件
                * 收藏控件
                * 下载控件
                * 转发控件
                * 管理控件

### 模块高度耦合
1. 组件本身的部分只有一个 `.vue` 文件，长达 2400 行，没有一行注释和文档。
2. 组件内的各个模块相互依赖，各模块的数据和方法在组件内全局可见，互相引用。导致在拆分的时候牵一发而动全身。
3. 缺少测试

### 很多大的方法


### 耦合列表

## 顺序
### 第一步，基本看懂现有的逻辑
1. 整理代码格式，写注释，写文档，构建模块结构图。
2. 本来一上来就准备先把大文件拆小，但由于不知道各模块之间的耦合关系，所以拆分的时候很容易出错。
* 

### 第二步，拆分
* 从耦合度比较低的模块开始进行拆分，逐步梳理。
* 本来在同一个组件里的 state 属性，因为现在要拆分组件并且在若干个组件里共享，所以需要进行封装。放在 store，通过 getter 访问，通过 mutation 修改。
* 开始时各模块耦合度很高，拆分难度比较大。这样试图拆分出去的模块越大，就要处理越多的解耦和。因此可以先进行细粒度的拆分，拆分出很多小的组件，每次拆分只需要处理少量的解耦和。等到解耦完成后，再把可以合并的小组件实现高内聚的合并。而且，细粒度的解耦就可以进行细粒度的测试，可以很快的定位拆分导致的错误。


## 便于拆分的情况
* css 都是按照嵌套结构的，这样提取出一个模块后，可以快速找到这个模块的所有 css


## UML



## 拆分组件要点
### 具有内聚性的一组公共操作作为 mixin
例如好几个模块的按钮需要强制授权或手机号登录，那么把强制授权或手机号登录相关的属性和方法提取为独立的 mixin

### 适用范围比较广的属性作为 mixin 或放在 store 里
1. 好几个子组件都会用到的属性，就不用分别作为 prop 传入了然后 emit 修改了，应该放在公共的 mixin 里面或者 store 里
2. store 里面的数据如果好几个子组件都会用到，那么可以放在 mixin 里面，这样各个组件就不用直接从 store 里面去，而是更方便的作为组件属性来获取。而且如果要对 store 里面的数据再包装的话，也方便统一包装。

### 拆分步骤
1. 看懂该模块的逻辑，整理修改其中不合理的代码。
2. 罗列出拆分后需要的 prop、emit 和 ref 清单。
3. 分析哪些属性和事件要子组件自己维护，哪些要父组件维护
    * 如果是只和该模块相关的，那就放在子组件里，否则放在外面通过 prop 和 emit 来操作
4. 拆分出去后，根据上面的清单一项项的修改。
    * ref 引用的大部分其实可以转成 prop 加 emit。如果一定要直接操作 DOM，也可以父级通过 prop 传递状态进去，然后子组件内部自己操作 DOM。


## 涉及的重构方法
### Encapsulate Variable
拆分组件时公共数据放进 store，通过 getter 访问，通过 mutation 修改。

### Split Parameter Object
给子组件传 prop 时如果子组件只需要对象中的少部分属性，就不要传整个对象。


## 涉及的设计模式


## 性能优化
### 图片预加载

### 渲染
该用 `v-show` 的地方不要用 `v-if`。很多时候想用方便的 `v-else`，但如果只是显示隐藏而不是重渲染，那还是应该用 `v-show`


## API 文档


## References
* [揭秘 Vue.js 九个性能优化技巧](https://juejin.cn/post/6922641008106668045)
