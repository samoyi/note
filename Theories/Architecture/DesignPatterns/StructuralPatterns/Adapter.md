# Adapter

适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。


<!-- TOC -->

- [Adapter](#adapter)
    - [设计思想](#设计思想)
        - [SRP](#srp)
        - [对用户透明](#对用户透明)
    - [抽象本质](#抽象本质)
    - [实现原理](#实现原理)
    - [适用场景](#适用场景)
    - [缺点](#缺点)
    - [例子](#例子)
    - [和其他模式的关系](#和其他模式的关系)
    - [References](#references)

<!-- /TOC -->


## 设计思想
### SRP
原来的对象不需要为了新的需求做兼容，可以继续保持单一的功能。

### 对用户透明
1. 被适配的对象不需要做出任何修改，甚至不会知道自己被适配了。
2. 因为适配器实现了和被适配对象相同的接口，所以使用原对象的对象也是无感知的。


## 抽象本质
打补丁式的兼容


## 实现原理
1. 确保至少有两个类的接口不兼容：
    * 一个无法修改（通常是第三方、遗留系统或者存在众多已有依赖的类）的功能性服务类。
    * 一个或多个将受益于使用服务类的客户端类。
2. 声明客户端接口，描述客户端如何与服务交互。
3. 创建遵循客户端接口的适配器类。所有方法暂时都为空。
4. 在适配器类中添加一个成员变量用于保存对于服务对象的引用。通常情况下会通过构造函数对该成员变量进行初始化，但有时在调用其方法时将该变量传递给适配器会更方便。
5. 依次实现适配器类客户端接口的所有方法。适配器会将实际工作委派给服务对象，自身只负责接口或数据格式的转换。
6. 客户端必须通过客户端接口使用适配器。这样一来，你就可以在不影响客户端代码的情况下修改或扩展适配器。


## 适用场景
1. 适配对象接口不兼容的情况。
2. 有时想使用一个对象，其实这个对象的功能是可以满足并且是符合语义的，但只是接口的实现不兼容，这时就可以使用适配器转换一下接口。


## 缺点
1. 打补丁式的兼容会让过时或不良的设计苟延残喘。
2. 因为属于非正常的逻辑，因此会使程序的变得难以理解。
3. 有时需要的其实并不是对旧的设计打补丁兼容，而是应该直接重构。


## 例子
1. 假设我们正在编写一个渲染广东省地图的页面。目前从第三方资源里获得了广东省的所有城市以及它们所对应的 ID，并且成功地渲染到页面中：
    ```js
    const GuangdongCities = [
        {
            name: 'city1',
            id: 11,
        },
        {
            name: 'city2',
            id: 12,
        },
    ];

    function render(cities){
        document.write(JSON.stringify(cities));
    }

    render(GuangdongCities);
    ```
2. 但后来因为某些原因，渲染出的结构必须变动，变成如下的结构：
    ```js
    {
        city1: 11,
        city1: 22,
    };
    ```
3. 除了大动干戈地改写渲染页面的前端代码之外，另外一种更轻便的解决方式就是新增一个数据格式转换的适配器：
    ```js
    const GuangdongCities = [
        {
            name: 'city1',
            id: 11,
        },
        {
            name: 'city2',
            id: 12,
        },
    ];

    function render(cities){
        document.write(JSON.stringify(cities));
    }

    function citiesAdapter( oldCityList ){
        let cities = {};
        oldCityList.forEach((city)=>{
            cities[city.name] = city.id;
        })
        return cities;
    }

    render(citiesAdapter(GuangdongCities));
    ```


## 和其他模式的关系
1. 有一些模式跟适配器模式的结构非常相似，比如装饰者模式、代理模式和外观模式。这几种模式都属于 “包装模式”，都是由一个对象来包装另一个对象。
2. 适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。
3. 适配器模式是改变接口但不改变功能，而装饰器模式和代理模式都是修改功能但不改变接口。
4. 装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次；代理模式是为了控制对对象的访问，通常也只包装一次。
5. 外观模式的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。


## References
* [《JavaScript设计模式与开发实践》](https://book.douban.com/subject/26382780/)
* [Refactoring.Guru](https://refactoring.guru/design-patterns/adapter)
* [《设计模式》](https://book.douban.com/subject/1052241/)