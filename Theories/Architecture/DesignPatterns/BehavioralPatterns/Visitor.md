# Visitor


<!-- TOC -->

- [Iterator](#iterator)
    - [思想](#思想)
    - [内部迭代器和外部迭代器](#内部迭代器和外部迭代器)
        - [内部迭代器](#内部迭代器)
        - [外部迭代器](#外部迭代器)
    - [References](#references)

<!-- /TOC -->


## 思想
1. 我们要对一组不完全相同的对象执行一个类似的操作，这个操作会根据每个对象的不同之处而略有不同。
2. 我们当然可以给每个对象内部都定义各自的这个方法，但有时并不能这么做。比如：
    * 比如有 100 个对象但其实只是分为 3 类，那操作也就 3 种，但你还是要把操作代码写 100 份才行。
    * 比如从语义上来说，对象内部不应该包含这个操作代码。例如对象是一组不同语言的说明书，而你的操作是翻译这些说明书。翻译这个行为从语义上就不属于说明书本身该有的功能，而是外部的功能。
3. 所以我们可以把这些不同的操作定义到外部一个模块，这个模块接收对象，根据对象类型执行不同的操作。
4. 其实这里已经把问题解决了，但访问者模式还要处理的一个问题是，这个操作模块无法通过 O(1) 操作确定对象的方法，只能线性的确定当前对象的类型然后进行操作，比如只能这样
    ```js
    if (obj.type == 1) {
        doFor1(obj);
    }
    else if (obj.type == 2) {
        doFor2(obj);
    }
    else if (obj.type == 3) {
        doFor3(obj);
    }
    // ...
    ```
5. 所以访问者模式还是要修改那些对象，它让那些对象可以接受这个操作模块，这个操作模块就被称为访问者。然后每个具体的对象从这个操作模块调用自己对应的方法
    ```js
    class Obj1 {
        constructor (visitor) {
            visitor.doFor1();
        }
    }
    class Obj2 {
        constructor (visitor) {
            visitor.doFor2();
        }
    }
    ```
6. 怎么感觉还是直接让操作模块完全处理更好啊，设计成范访问者并没有少写代码，也没有降低耦合，反而是破坏了对象的语义。


## References
* [Refactoring.Guru](https://refactoring.guru/design-patterns/visitor)