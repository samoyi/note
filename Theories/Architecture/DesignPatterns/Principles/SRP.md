# Single responsibility principle


<!-- TOC -->

- [Single responsibility principle](#single-responsibility-principle)
    - [设计思想](#设计思想)
    - [设计模式中的 SRP 原则](#设计模式中的-srp-原则)
    - [SRP 原则的优缺点](#srp-原则的优缺点)
    - [何时应该分离职责](#何时应该分离职责)
    - [面向用户时，在灵活和方便之间权衡](#面向用户时在灵活和方便之间权衡)
    - [References](#references)

<!-- /TOC -->


## 设计思想
1. 单一职责原则（SRP）的职责被定义为 “引起变化的原因”。如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。
2. 此时，这个方法通常是一个不稳定的方法，修改代码总是一件危险的事情，特别是当两个职责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意想不到的破坏，这种耦合性得到的是低内聚和脆弱的设计。
3. 因此，SRP 原则体现为：一个对象（方法）只做一件事情。


## 设计模式中的 SRP 原则
* 代理模式：原功能要添加功能时，不再原功能上添加，而是添加一个代理对象
* 迭代器模式：迭代数据的功能和对数据条目实际操作的功能相互独立
* 单例模式：实际功能对象和创建对象单例的功能相互独立
* 装饰者模式：装饰功能和基本功能相互独立


## SRP 原则的优缺点
1. SRP 原则的优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。
2. 但 SRP 原则也有一些缺点，最明显的是会增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。


## 何时应该分离职责
1. 在一个实体里实现了两个（或者更多）的功能。
2. 即使这两个功能总是一起使用，也不应该把它们放在同一个实体里。因为后期维护的时候，如果只修改其中一个功能，就很有可能影响到在同一个实体里的另一个功能。


## 面向用户时，在灵活和方便之间权衡
1. 对于开发功能的人来说，在实现逻辑时应该做到尽量的 SRP，但是在面对用户时，常常需要权衡利弊。
2. 比如相比于整机，组装机显然要更加 SRP，可以灵活的独立升级独立维修。但对于大部分用户来说，还是会选择整机，因为更方便。
3. 当然，在整机的内部实现中，仍然需要做到尽可能的 SRP。
4. 同样，当我们的代码时提供接口给其他人使用的，那接口的设计也要考虑到这个权衡。一个接口继承三个功能对用户更方便，还是独立三个接口对用户更方便。


## References
* [《JavaScript设计模式与开发实践》](https://book.douban.com/subject/26382780/)
