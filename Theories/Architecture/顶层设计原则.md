# 顶层设计原则


## ETR 和 ETU 和 $ETC_h$ 和 $ETC_o$
1. Easier To Read 和 Easier To Use 和 Easier To Change 和 Easier To Control。
2. ETR 包含两层意思：
    * 子程序的实现应该对于其他合作编程者（以及一段时间后的自己）易读；
    * 子程序应该对于它的调用者易读（例如 API 设计合理）；
3. ETU 也包含两层意思：
    * 子程序对于它的调用者易用。（易用和易读不一样，比如一个函数从名字就知道是要干什么，这是易读；但如果它要传好几个参数，而且返回的结果还要再加工，这就不易用了）
    * 整个程序应该对于用户易用。
3. $ETC_o$ 是控制对数据或对象进行读取和设置的控制，例如把属性的读取和设置都封装为方法。
4. 一种设计方法经常是两中或三中原则的结合。例如封装对象的设计方法，通过把一组数据和行为封装为对象：
    * 把复杂的逻辑封装起来并提供明确的 API，所以是 ETR 的；
    * 意图与实现分离，所以是 $ETC_h$ 的；
    * 实现为黑箱，阻止用户直接接触内部数据，所以是 $ETC_o$ 的。
5. 重构和设计模式的大多数方法其实都是为了实现这三点。


## ETU
1. 这一原则的目的并不是为了减少使用者的理解难度或者减少使用者的出错概率，而是减少使用者的工作量。
2. 因为你实现了一个功能往往是供好几个甚至很多使用者反复使用的，所以如果你实现时给自己增加一点难度而为每次使用降低一点难度，那对于之后很多次的使用来说就是总体降低了很多使用成本。






## $ETC_h$
### 技术选型的可逆性
1. 程序本来要使用一种第三方软件，但后期可能改为另一种第三方软件。在理想的情况下，应该可以很快的切换到另一种软件。
2. 但实际情况并没有这么理想，毕竟兼容的成本也并不小。
3. 那么在设计选型阶段，就要评估哪些选择是相对来更更稳定，哪些后期可能会变化。
4. 对于那些更有可能的变化，就要做好迎接变化的准备，让程序内部的接口可以更好的适应变化。


## $ETC_o$
1. 变化是危险的。

### 解决思路
#### 定义为常量
如果一个数据本身不需要变化，那就定义为常量。

#### 创建副本
1. 如果一个数据不是只被使用一次，那如果要修改格式之类的话，就考虑使用副本。
2. 之后每次使用这个数据都是取原始的副本。

### 缩减可见范围
在小范围内可变就相对好控制一些

### 收紧修改权限
只允许通过特定的方法修改


## References
* [The Pragmatic Programmer: From Journeyman to Master 第2版](https://book.douban.com/subject/35006892/)