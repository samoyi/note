# Speculative Generality

<!-- TOC -->

- [Speculative Generality](#speculative-generality)
    - [思想](#思想)
        - [权衡](#权衡)
        - [参数的语义](#参数的语义)
    - [解决思路](#解决思路)
        - [抵御增加 flag 来兼容新功能的冲动](#抵御增加-flag-来兼容新功能的冲动)
    - [重构方法参考](#重构方法参考)
    - [References](#references)

<!-- /TOC -->


## 思想
### 权衡
任何一个建议甚至原则，都值得权衡。

### 参数的语义
1. 参数是用来设定行为的属性的，而不应该用来改变切换不同的行为
2. 比如说 “踢球” 这个行为，参数可以是 “力度”，“力度” 是行为的属性。
3. 但不应该设定一个参数 `type`，取值 “用脚踢” 后者 “用头顶”，然后把 `type` 参数传给 “踢球”，这是直接改变 “踢球” 这个行为了。
4. 为了使用 “头球” 的行为，你应该重新第一一个名为 “头球” 的行为。


## 解决思路
1. 为了复用做很多钩子和判断真的是很难看而且难以理解和难以修改，还不如写两个单独的部分。
2. 在计算和传输速度够快、存储和流量消耗不大的情况下，复用带来的一点点性能提升，远远比不上复杂的逻辑所带来的理解成本。
不要为了通用性而明显增加一个实体的复杂度、可理解性、易修改性。

### 抵御增加 flag 来兼容新功能的冲动
1. 其实这个和 Remove Flag Argument 这条重构一个原理。
2. 比如开始一个方法用来设置列表
    ```js
    setList (list) {
        this.list = list;
    }
    ```
3. 后来这个列表变成了分页请求，那么就出现了另一种列表处理方法，就是把请求到的列表 append 现有列表里，而不是直接覆盖。
4. 以为我很懒，所以这时就会有一种强烈的复用冲动
    ```js
    setList (list, isAppend) {
        if (isAppend) {
            this.list = [...this.list, ...list];
        }
        else {
            this.list = list;
        }
    }
    ```
5. 这样是挺好的兼容了两个情况，好像也没什么问题。而且这个参数的命名也挺有语义的。
6. 但是，随着这个方法逻辑的演化，它会越来越复杂，内部可能也要做不止一次的兼容，那样看起来就费劲了。
7. 而且，一个函数应该只做一种行为，参数只是用来修饰修为的，而不是改变行为的。
8. “替换列表” 和 “追加列表” 其实应该算是两种行为，那就应该定义为两个函数。
9. 除了语义化更明确以外，更重要的是，当你查看调用栈的时候，不管是替换列表还是追加列表，你看到的都是同一个函数，你看不到函数的参数。你想 debugger 的时候不仅要确定 `setList` 被调用了，还要再看看第二个参数是什么。 
10. 而如果你定义为两个函数 `resetList` 和 `appendList`，查看调用栈就是一目了然了。


## 重构方法参考
* Remove Flag Argument
* Split Loop
* Split Variable
* Separate Query from Modifier
* Push Down Method
* Push Down Field
* Collapse Hierarchy


## References
* [《重构（第2版）》](https://book.douban.com/subject/33400354/)
