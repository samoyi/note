# 重构目录

## Single responsibility principle
### 检查原则
* 一个 widget 只是一个模块
* 一个对象只做一件事情
* 一个方法只做一件事情

### 设计模式实现
* 代理模式：原功能要添加功能时，不再原功能上添加，而是添加一个代理对象
* 迭代器模式：迭代数据的功能和对数据条目实际操作的功能相互独立
* 单例模式：实际功能对象和创建对象单例的功能相互独立
* 装饰者模式：装饰功能和基本功能相互独立


## Open–closed principle
### 检查原则
* 抽离业务逻辑
* 避免过多的条件分支

### 抽离业务逻辑
1. 即使是一个 widget、一个对象甚至一个方法，都有核心逻辑和业务逻辑的区别，如果业务逻辑可能频繁更改或扩展，就可以考虑分离。
2. 比如在一个相册列表组件里，获取相册数据、选择渲染哪种样式的列表就属于核心逻辑，而具体每种样式的相册列表则属于业务逻辑，应该放到外面。

### 避免过多的条件分支
1. 不一定是`if...else`或`switch`这样明确的条件分支，只要是内部有兼容不同情况的逻辑，都可以考虑只保留核心逻辑，而将具体的实现拆分出去。
2. widget 可以接受不同的组件，对象有多态性，函数可以接收不同的参数。如果有不同的多种逻辑要兼容，那就索性把逻辑写在单独的组件、单独的对象或者单独的函数里，根据不同的条件引入不同的逻辑，而不要都挤在一起之后才进行逻辑判断。
3. 为 widget、对象或方法实现不同的功能应该通过传参，而非在其内部做复杂的兼容。
4. 如果 widget、对象或方法内部有复杂的条件判断，那每次对象要修改或拓展方法，都要进到对象内部进行修改。
5. 每一个 widget、对象和方法内部，都要尽可能的逃避责任，尽可能让自己清净。你们不要进到我里面才石头剪刀布来决定执行谁，你们在外面就决定好，谁赢了谁再进来。

#### 相册列表 widget 拆分
1. 相册列表 widget 中，原来是把大图列表和小图列表的代码都直接写在里面，根据后端参数判断渲染哪一部分代码。
2. 这样不仅看起来很费劲，而且如果要修改某种样式的列表，都要进到相册列表总的 widget 里修改。
3. 后来把大图列表和小图列表都作为单独的组件，大图列表组件、小图列表组件和相册列表总的 widget 实现了解耦。不管是修改还是扩展都更方便，大小图列表也可以复用到其他地方，不再绑定到相册列表总的 widget 里。


### 设计模式实现
* 模板方法模式

## 例子
1. 三目运算符代码量会少一点点，而且可能也有一点点的性能优势。但如果像下面这样用，维护的成本就大于性能的收益了
    ```js
    if ( !aup || !bup ) {
        return a === doc ? -1 :
            b === doc ? 1 :
            aup ? -1 :
            bup ? 1 :
            sortInput ?
            ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
            0;
    }
    ```
    这是什么丑逼！！


## References
* [《JavaScript设计模式与开发实践》](https://book.douban.com/subject/26382780/)
