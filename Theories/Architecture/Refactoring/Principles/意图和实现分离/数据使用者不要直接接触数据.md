# 对使用者透明


<!-- TOC -->

- [对使用者透明](#对使用者透明)
    - [思想](#思想)
        - [对使用者透明](#对使用者透明-1)
        - [封装变量——不要直接使用变量保存的基本类型值](#封装变量不要直接使用变量保存的基本类型值)
            - [防止设置误操作](#防止设置误操作)
            - [防止读取误操作](#防止读取误操作)
    - [实现逻辑](#实现逻辑)
        - [想要读取数据时，提供读取方法](#想要读取数据时提供读取方法)
        - [想要改变数据时，提供设置方法](#想要改变数据时提供设置方法)
        - [想要根据数据做判断时，直接提供判断方法](#想要根据数据做判断时直接提供判断方法)
    - [涉及的 bad code](#涉及的-bad-code)
    - [涉及的重构方法](#涉及的重构方法)
    - [References](#references)

<!-- /TOC -->


## 思想
包括修改和读取

### 对使用者透明
1. 比如最初是通过有没有手机号判断是否登陆，后来改成了有没有名字判断登陆。
2. 那各个组件里不要自己去做判断，否则就是开始要读取手机号之后又改成读取名字。
3. 而是在数据层封装一个比如说 `isLogin` 方法，这个方法对各个组件透明，不管底层判断逻辑怎么变。

###　封装变量——不要直接使用变量保存的基本类型值
除了 Encapsulate Variable 这条重构规则中说到的，封装变量也可以防止使用者的误操作。

#### 防止设置误操作
1. 如果某个数据只有几种类型值，写操作如果直接传值，使用者有可能传不正确的值。
2. 比如一个变量 `postion` 的值只能是 `left`、`middle` 和 `right`，那如果让使用者直接改变这个变量的值，他可能会不知道只有这三个，而设置了 `top`，或者比如笔误写成了 `rigth`。而这个错误的设置，是不会报错的。又因为设了一个错误的值，所以之后所有基于这个变量的判断就会是 `false`。
3. 所以最好是封装三个方法：`setLeftPosition`
    ```js
    setLeftPosition() {
        position = 'left';
    },
    setMiddlePosition() {
        position = 'middle';
    },
    setRightPosition() {
        position = 'right';
    },
    ```

#### 防止读取误操作
1. 读取也是一样，只不过这种时候是出现在做判断的时候。
2. 比如使用者想判断当前是不是 `right`，他笔误写成了 `if (postion === 'rigth')`。那么这个判断肯定是 `false`，他会以为当前的值不是 `right`。
3. 同样也应该封装为三个方法
    ```js
    isLeftPosition() {
        position === 'left';
    },
    isMiddlePosition() {
        position === 'middle';
    },
    isRightPosition() {
        position === 'right';
    },
    ```


## 实现逻辑
### 想要读取数据时，提供读取方法

### 想要改变数据时，提供设置方法
* 设值方法接收值参数。
* 或者要约束在几个合理值时，像上面说的那样给每个值设置一个设值函数。

### 想要根据数据做判断时，直接提供判断方法
像上面说到的。


## 涉及的 bad code
* Data Class
* MutableData
* Message Chains
* Insider Trading
* Global Data


## 涉及的重构方法
* Encapsulate Variable
* Hide Delegate
* 用函数替代判断表达式
* Encapsulate Collection
* Encapsulate Record


## References
* [*Refactoring: Improving the Design of Existing Code,Second Edition*](https://book.douban.com/subject/30332135/)
