# 消除非必要的可变性

<!-- TOC -->

- [消除非必要的可变性](#消除非必要的可变性)
    - [思想](#思想)
    - [评估耦合程度的几个维度](#评估耦合程度的几个维度)
        - [连接点数量](#连接点数量)
        - [连接点数据影响范围](#连接点数据影响范围)
        - [连接点数据类型](#连接点数据类型)
    - [耦合的类型](#耦合的类型)
        - [语义耦合](#语义耦合)
    - [通用性与效率的权衡](#通用性与效率的权衡)
    - [涉及的 bad codes](#涉及的-bad-codes)
    - [涉及的重构](#涉及的重构)
    - [References](#references)

<!-- /TOC -->


## 思想
1. 顶层设计原则：ETU 和 $ETC_h$。
2. ETU 是调用环境不需要为了调用而改变太多；$ETC_h$ 是方便扩展。


## 评估耦合程度的几个维度
1. 想象两个机构要打交道，要交流和合作，那怎样才算低耦合呢？
2. 首先，最好两个机构分别成立一个小部门专门进行对接，而不是两个机构的多个部门各自为政的进行对接。
3. 其次，一个结构的对接部门最好只是和另一个结构的对接部门对接，而不是深入到对方机构内部和其他部门对接。
4. 还有，对接的部门的对接规则、对接技术等最好都是大家普遍通用的，不要为了对接还要建立不熟悉的规则、引入另外的技术。
5. 这三方面的例子，分别对应下面的三种耦合度评估维度。

### 连接点数量
1. 两个实体之间最松散的耦合当然是完全没有连接，当然这种情况下也就不能交流了。
2. 在能交流的前提下，最理想的耦合度就是两个实体只有一个连接点，两个实体只需要为对方处理好一个连接点的对接工作就可以交流。
3. 而如果连接点数量很多，两个实体为了实现交流就要做出更多的改变来对接对方，也就是越来越适应对方。越来越适应对方，也就越来越不适应其他的第三方。
4. 例如一个子程序的参数就是和调用方的连接点（返回值也算是一个连接点，不过这里先不考虑）。如果子程序只有一个参数，那么子程序与调用它的调用者之间的连接点的数量就只有一个，调用者只需要处理这一个参数即可。而如果子程序有六个参数，也就是与调用方有六个连接点，那调用方就要为该子程序做更多事情，让自己更多的去适应这个子程序，也就产生了更多的耦合。
5. 不只是子程序，然后实体对外的接口越多则耦合度就越高。

### 连接点数据影响范围
1. 《代码大全2》中的这一条小标题是 “可见性”（Visibility），是说在使用一个模块时如果是明确的传递参数那就是好的，但如果要修改一个全局数据以供模块使用就是不好的。
2. 两个实体交流的数据当然最好是显式传递，而不是隐式的修改一个值，一个偷偷摸摸的行为会被人忽略掉，进而会产生一些问题。但书中的说明并没有明确的体现出这样会增加耦合度。
3. 在大多数情况下，要调用另一个实体时，调用的参数是会特别准备的，大多数情况下参数都是按值传递的。也就是说，传参的方式会尽可能的不影响调用方环境对该参数数据的使用。
4. 而如果是修改全局数据，或者是一个作用域很大的数据，则很有可能该数据也有其他的使用者。那么你这样的修改肯定也会影响到其他地方对该数据的使用，也就是说其他地方也要为这个调用做出调整，也就是增加了耦合度。

### 连接点数据类型
1. 连接点的数据类型越通用则耦合度越低，不过可能会降低一些效率。
2. 例如一个子程序 `LookupVacationBenefit()`，它根据一个员工的雇佣时间和职位级别来计算该员工的假期数量。
3. 它可以设计成接收 `employee` 对象作为参数，然后内部读取该对象的雇佣时间和职位级别数据进行计算。也可以设计成接收两个更基础的参数，也就是直接的雇佣时间和职位级别，可能这两个参数都是基础的整数值。
4. 如果这个子程序被两个调用方调用，而这两个调用方本身都有 `employee` 对象，那显然第一种设计方法更好，以为可以降低调用方的使用难度，而且也只有一个连接点，耦合度更低。
5. 但是如果两个调用方中有一个并没有 `employee` 对象，该调用方就要仅仅为了使用这个子程序而创建该对象。这种麻烦的原因就是因为 `LookupVacationBenefit()` 的设计耦合了本身有 `employee` 对象的那个调用方。
6. 可以看到，一种设计方法既可能是降低了耦合度，也可能是增加了耦合度，完全要根据实际的使用情况而定。


## 耦合的类型
### 语义耦合
1. 一个实体不仅使用了另一个实体的语法元素（syntactic element），而且还使用了有关那个实体内部工作细节的语义知识（semantic knowledge）。
2. 《代码大全2》中的例子（5.3）没太看明白，但感觉意思就是：两个实体不仅仅有明确的接口上的耦合，还有隐式的需要知道对方的内部逻辑。
3. 也就是说，当你使用一个实体时，你只看它的接口是不够的，你还需要知道一些它的内部逻辑。
4. 这就要求调用方和被调用方需要一些代码之外的约定，而且除了要求对方接口不要更改以外，还希望对方一直遵守这些私下的约定。


## 通用性与效率的权衡
1. 从上面评估耦合度的分析可以看到，一个实体如果越需要通用，就越好做到低耦合性。
2. 一个实体只有越不和某些个别环境耦合，才能复用到不同的环境里。也就是说，这个实体不能是为给别环境定制的。
3. 而定制的优点则是更高的效率。就像上面的  `LookupVacationBenefit()`，如果是为有 `employee` 对象的环境定制的话，该环境使用起来效率就会更高。
4. 所以，对于耦合度来说，通用性和效率有时是矛盾的。如果确定实体不需要通用，那就可以好现有环境更多的耦合以追求效率；如果要通用或可能要通用，则还是低耦合会更安全。


## 涉及的 bad codes


## 涉及的重构
* Replace Query with Parameter


## References
* [*Refactoring: Improving the Design of Existing Code,Second Edition*](https://book.douban.com/subject/30332135/)
