# 循环中提前函数返回以减少条件判断


<!-- TOC -->

- [循环中提前函数返回以减少条件判断](#循环中提前函数返回以减少条件判断)
    - [思想](#思想)
        - [复杂的大逻辑步骤拆分为简单的小逻辑步骤](#复杂的大逻辑步骤拆分为简单的小逻辑步骤)
    - [Motivation](#motivation)
        - [区分函数返回的条件和循环退出的条件](#区分函数返回的条件和循环退出的条件)
    - [References](#references)

<!-- /TOC -->


## 思想
### 复杂的大逻辑步骤拆分为简单的小逻辑步骤
1. 若干个逻辑综合到一起，可能看起来更方便，或者至少省点代码，但其实理解起来会更麻烦，得不偿失。
2. 拆分后，步骤上可能稍微多了一些，但整体逻辑上就清晰了。


## Motivation
### 区分函数返回的条件和循环退出的条件
1. 有些循环的退出条件，实际上也是整个函数的返回条件。这时如果把这退出循环但函数不返回的条件和函数返回的条件都放在循环条件的判断里，就会让判断变得很复杂，各种或且非混杂在一起。
2. 而且如果都放在循环条件的判断里，在循环结束后还要再判断是哪一种导致的循环终止。
3. 例如一个哈希表的开放寻址法的查找方法，会不断散列查找槽位，直到满足以下三个条件之一：
    * 散列到一个从没有插入节点的槽位，说明没找到；
    * 散列完所有的槽位；
    * 找到查找的节点。
4. 上面三个条件都会导致再散列的循环结束，但其实，前两个情况应该直接导致函数返回空值表示没有节点被删除，而最后一种情况只是导致循环结束，后序还要进行例如内存释放、计数变化的操作后才会函数返回。
5. 如果把这三个条件都写到循环条件里，不仅麻烦而且理解起来更困难
    ```cpp
    void hash_delete (int key) {
        index = 0;
        
        int pos = hash_fn(key);

        while ( !isVirginalSlot(pos) // 不是从没有插入节点的槽位
                && index < SIZE // 还没散列完所有的槽位
                && (isDeleted(pos) || table[pos].node->key != key) // 不是要找的节点 
        ) {
            pos = hash_fn(key);
        }
        // 在这里不确定为什么跳出的循环，所以还要再判断一下
        if ( hasNode(pos) ) { // 如果是找到了节点而跳出的
            // 删除操作
        }
    }
    ```
6. 但如果把直接导致函数返回的判断提取出来
    ```cpp
    void hash_delete (int key) {
        index = 0;
        
        int pos = hash_fn(key);
        if ( isVirginalSlot(pos) || index == SIZE ) {
            return;
        }

        // 三种混杂在一起的条件判断独立开了，更容易理解
        while ( isDeleted(pos) || table[pos].node->key != key ) {
            pos = hash_fn(key);
            if ( isVirginalSlot(pos) || index == SIZE ) {
                return;
            }
        }

        // 而且能走到这里一定是因为找到了节点，所以可以直接删除
        // 删除操作
    }
    ```


## References
* [《JavaScript设计模式与开发实践》](https://book.douban.com/subject/26382780/)
