# Encapsulate Record


<!-- TOC -->

- [Encapsulate Record](#encapsulate-record)
    - [原则](#原则)
    - [场景](#场景)
        - [getter 和 setter](#getter-和-setter)
        - [Vue 计算属性对数据读取的封装](#vue-计算属性对数据读取的封装)
        - [Vue 组件中不应该直接修改 `data` 数据](#vue-组件中不应该直接修改-data-数据)
    - [过度优化](#过度优化)
    - [References](#references)

<!-- /TOC -->


## 原则
* **意图与实现分离**：提供明确的 API 供使用者方便的使用，但不需要他们知道功能的实现。
* **黑箱封装**：禁止使用者随意修改内部数据，并且黑箱内部可以对公开的功能做一些黑箱操作。
* **访问监听**：通过读写方法可以监听和控制用户的访问。
* **对使用者透明**：可以在对外的表现不变化的前提下，在里面根据需求修改逻辑，使用者都是无感的。


## 场景
### getter 和 setter

### Vue 计算属性对数据读取的封装
1. 某个数据可能获取起来比较复杂，使用计算属性就可以掩盖掉获取的实现。
2. 可以在计算属性中根据情况对数据进行加工和修改。
3. 直接读取组件 `data` 数据或者 store `state` 数据是无法监听的，但是计算属性就可以。

### Vue 组件中不应该直接修改 `data` 数据
1. 如果组件多个方法都会修改 `data` 中的同一个数据 `foo`，那么当这个 `foo` 发生变化时，就无法知道是哪里修改的，只能在所有的修改该数据方法里 debugger。
2. 但是如果有一个统一的修改方法 `setFoo`，所有修改 `foo` 的方法都调用 `setFoo`，这样在 `setFoo` 里就可以通过调用栈看到是哪里调用的。
3. Vuex 的 mutation 就是这个设计思想。


## 过度优化


## References
* [《重构（第2版）》](https://book.douban.com/subject/33400354/)

