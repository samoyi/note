# Feature Envy


## 原则
1. 一个实体在提供一项服务时，应该在自己内部处理组织服务的逻辑并给出最终结果，而不应该让请求者频繁请求来组织服务结果。
2. 一个实体内的请求者如果为了一个服务频繁请求另一个实体，那就应该考虑是不是应该把这个请求者的逻辑移入那个实体。


## 场景
### 频繁请求 store 的逻辑也许可以移入 store 作为一个 action
1. 比如一个应用需要检查用户登录状态，为此在刚进入项目的时候需要读取一些 token 之类的值，而且根据登录还会发送不同的请求。
2. 因为是在刚进入应用时的逻辑，所以刚开始时这段逻辑放在入口文件中。其中会查询好几个 store 中的 getter，然后根据登录状态，分别 dispatch store 中不同的 action。
3. 这里，store 外面为了实现一个功能，频繁的使用了 store 的功能，那这个功能的逻辑还是由 store 来处理比较好。
4. 重构之后，store 只需要暴露出一到两个 action，入口文件也不用复杂的逻辑，直接调用这一两个 action 就行了。


## 过度优化
### 如果依赖不明显，就不要破坏语义化
1. 之前在一个微信配置和授权相关的 store 模块里，定义了一个 `reloadAlbum` 方法，内部会调用该模块一个微信授权的方法，跳转微信授权，以此来重新进入相册。
2. 也正是因为内部会调用当前微信模块里的授权方法，所以当初才会被定义到微信的模块里。从这个角度来看，似乎是符合这里的 Feature Envy 的重构逻辑的——因为会调用微信模块的方法，所以就放到微信模块里吧。
3. 但其实从名字也可以看出来，“重载相册” 这种行为，无法算作一个微信配置或者授权的操作，只是用到了授权方法而已。虽然内部调用了微信模块的授权方法，但从它的语义上来看，“重载相册” 这种行为都是一个项目的基础行为。
4. 所以，应该把它移动的基础的 store 模块里，然后在内部跨模块调用微信模块里的方法。
5. 虽然这样跨模块了，好像是有一点点 Feature Envy。但是因为只是进行了一次跨模块调用，而且语义页更加明确，所以还是更好一些的。



