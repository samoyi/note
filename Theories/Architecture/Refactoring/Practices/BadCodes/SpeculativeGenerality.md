# Speculative Generality


## 原则
如果为了复用，一个实体内部的逻辑变得很复杂，那就别复用


## 场景
### 接口设计的起负作用的兼容
1. 一个后端接口，同时兼容了点赞和收藏的功能，需要传一个数字 flag，0 或者 1
2. 首先，这种强行兼容就很麻烦了。因为点赞和收藏完全是两个功能，而不是一个功能的两个方面；
3. 其次，这个 flag 也不明不白，所以你使用的时候肯定要加上注释；
4. 更丧心病狂的是，这个接口的 URL 最终段居然是 `collect` ！
5. 然而前端在使用的时候，依然沿用了这个逻辑：请求函数加了这个奇怪的参数，函数体里面也做了好几次判断，最终成了一个又复杂又长的函数。
6. 重构的方法当然应该是后端修改接口，但后端暂时没改的情况下，前端可以对接口请求再封装一层，然后把之前统一调 `collect` 的地方修改为调各自的方法
    ```js
    async likePic () {
      await collect(0);
    },
    async collectPic () {
      await collect(1);
    },
    ```
7. 即使后端接口暂时无法修改，也要在实际调用接口的地方拆分再封装。不要让接口的实际使用者去做判断。



## 过度优化
### 两个模块完全独立，本来有能共用的部分也没有共用
1. 开始想在一个模块上做兼容，后来发现还是还是独立比较好，结果就完全拷贝了一份。
2. 其实两者可能还是有一部分可以共用的，结果拷贝后就懒得抽出公共部分了。
3. 比如直接复制出了一个 vue 组件，两个功能不一样，但样式还是一样的。那就应该抽出共用的样式文件。


## References
* [《重构（第2版）》](https://book.douban.com/subject/33400354/)
