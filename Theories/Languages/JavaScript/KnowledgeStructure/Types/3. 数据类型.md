
* String, Numbers, booleans, null, and undefined are immutable


typeofæ“ä½œç¬¦â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
* Technically, functions are considered objects in ECMAScript and donâ€™t represent another data type. However, they do have some special properties, which necessitates differentiating between functions and other objects via the typeof operator.
* ç”¨typeofæµ‹è¯•æœªå£°æ˜Žçš„å˜é‡ä¹Ÿä¸ä¼šæŠ¥é”™ï¼Œä½†å¦‚æžœæ£€æµ‹ä¹‹åŽæ‰ç”¨letå£°æ˜Žçš„å˜é‡åˆ™ä¼šå‡ºé”™
        console.log(typeof value);     // ReferenceError!
        var value = "blue";
http://es-discourse.com/t/why-typeof-is-no-longer-safe/15

## Undefined Type
1. The undefined value represents a deeper kind of absence. 
2. A variable containing the value of undefined is different from a variable that hasnâ€™t been
defined at all.ï¼š
```
var message;
alert(message);    //"undefined"
alert(age);        //äº§ç”Ÿé”™è¯¯
```
3. The typeof operator returns â€œundefinedâ€ when called on an uninitialized variable, but it also
returns â€œundefinedâ€ when called on an undeclared variable.
```
var message;
alert(typeof message);     //"undefined"
alert(typeof age);         //"undefined"     
```
Even though uninitialized variables are automatically assigned a value of undefined, it is advisable to always initialize variables. That way, when typeof returns "undefined", youâ€™ll know that itâ€™s because a given variable hasnâ€™t been declared rather than was simply not initialized.




## Null Type
1. The Null type is the second data type that has only one value: the special value null. Logically, a null value is an empty object pointer, which is why typeof returns â€œobjectâ€ when itâ€™s passed a null value
2. The value undefined is a derivative of null, so ECMA-262 defines them to be superficially equal 
```alert(null == undefined); //true```
3. You might consider undefined to represent a system-level, unexpected, or error-like absence of value and null to represent program-level, normal, or expected absence of value. If you need to assign one of these values to a variable or property or pass one of these values to a function, null is almost always the right choice.This helps to keep the paradigm of null as an empty object pointer and further differentiates it from undefined.


## Booleanç±»åž‹
1. è¯¥ç±»åž‹åªæœ‰ä¸¤ä¸ªå­—é¢å€¼ï¼štrueå’Œfalseã€‚Booleanç±»åž‹çš„å­—é¢å€¼æ˜¯åŒºåˆ†å¤§å°å†™çš„ã€‚
2. è™½ç„¶Booleanç±»åž‹çš„å­—é¢å€¼åªæœ‰ä¸¤ä¸ªï¼Œä½†ECMAscriptä¸­æ‰€æœ‰ç±»åž‹çš„å€¼éƒ½æœ‰ä¸Žè¿™ä¸¤ä¸ªBooleanå€¼ç­‰ä»·çš„å€¼ã€‚è¦å°†ä¸€ä¸ªå€¼è½¬æ¢ä¸ºå…¶å¯¹åº”çš„Booleanå€¼ï¼Œå¯ä»¥è°ƒç”¨è½¬åž‹å‡½æ•°Boolean(): 
3. å¯ä»¥å¯¹ä»»ä½•æ•°æ®ç±»åž‹çš„å€¼è°ƒç”¨Boolean()å‡½æ•°ï¼Œè€Œä¸”æ€»ä¼šè¿”å›žä¸€ä¸ªBooleanå€¼ã€‚è‡³äºŽè¿”å›žçš„è¿™ä¸ªå€¼æ˜¯trueè¿˜æ˜¯falseï¼Œå–å†³äºŽè¦è½¬æ¢å€¼çš„æ•°æ®ç±»åž‹åŠå…¶å®žé™…å€¼ã€‚

æ•°æ®ç±»åž‹ | è½¬æ¢ä¸ºtrueçš„å€¼ | è½¬æ¢ä¸ºfalseçš„å€¼
---|---|---
Boolean | true | false
String | ä»»ä½•éžç©ºå­—ç¬¦ä¸² | 	""
Number | ä»»ä½•éžé›¶æ•°å­—å€¼ï¼ˆåŒ…æ‹¬æ— ç©·å¤§ï¼‰ | 0å’ŒNaN
Object | ä»»ä½•å¯¹è±¡ | null
Undefined | n/aï¼ˆæˆ–N/Aï¼Œnot applicableçš„ç¼©å†™ï¼Œæ„ä¸ºâ€ä¸é€‚ç”¨â€œï¼‰ | undefined




## Numberç±»åž‹
#### ä¸€. è¿™ç§ç±»åž‹ä½¿ç”¨IEEE754æ ¼å¼æ¥è¡¨ç¤ºæ•´æ•°å’Œæµ®ç‚¹æ•°ã€‚
1. Unlike many languages, JavaScript does not make a distinction between integer values and floating-point values. All numbers in JavaScript are represented as floating-point values. 
2. JavaScript represents numbers using the 64-bit floating-point format defined by the IEEE 754 standard,1 which means it can represent numbers as large as Â±1.7976931348623157 Ã— 10^308 and as small as Â±5 Ã— 10^âˆ’324.
3. The JavaScript number format allows you to exactly represent all integers between âˆ’9007199254740992 (âˆ’2^53) and 9007199254740992 (2^53), inclusive. However, certain operations in JavaScript (such as array indexing and the bitwise operators) are performed with 32-bit integers.
4. ES6ä¸­ Number.isInteger() åˆ¤æ–­ä¸€ä¸ªå€¼æ˜¯å¦ä¸ºæ•´æ•°
ï¼ˆ1ï¼‰éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨JavaScriptå†…éƒ¨ï¼Œæ•´æ•°å’Œæµ®ç‚¹æ•°æ˜¯åŒæ ·çš„å‚¨å­˜æ–¹æ³•ï¼Œæ‰€ä»¥3å’Œ3.0è¢«è§†ä¸ºåŒä¸€ä¸ªå€¼ï¼Œéƒ½ä¼šè¿”å›žtrue


#### äºŒ. è¿›åˆ¶
1. ES6æä¾›äº†äºŒè¿›åˆ¶æ•°å­—çš„å†™æ³•ï¼Œä½¿ç”¨å‰ç¼€0bæˆ–0B
2. ES6ä¹‹å‰ï¼Œå…«è¿›åˆ¶å­—é¢å€¼çš„ç¬¬ä¸€ä½å¿…é¡»æ˜¯0.å¦‚æžœå­—é¢å€¼ä¸­çš„æ•°å€¼è¶…å‡ºäº†èŒƒå›´ï¼Œé‚£ä¹ˆå‰å¯¼0å°†è¢«å¿½ç•¥ï¼ŒåŽé¢çš„æ•°å€¼å°†å½“åšåè¿›åˆ¶æ•°å€¼è§£æžã€‚
     var octalNum=08   //æ— æ•ˆçš„å…«è¿›åˆ¶æ•°å€¼â€”â€”è§£æžä¸º8
3. ES6ä¹‹å‰ï¼Œå…«è¿›åˆ¶å­—é¢é‡åœ¨ä¸¥æ ¼æ¨¡å¼ä¸‹æ˜¯æ— æ•ˆçš„ï¼Œä¼šå¯¼è‡´æ”¯æŒçš„JavaScriptå¼•æ“ŽæŠ›å‡ºé”™è¯¯ã€‚ä½†ES6æä¾›äº†å…«è¿›åˆ¶çš„æ–°å‰ç¼€ï¼š0oæˆ–0O
4. åå…­è¿›åˆ¶å­—é¢å€¼çš„å‰ä¸¤ä½å¿…é¡»æ˜¯0xæˆ–0Xï¼Œå­—æ¯A~Få¯ä»¥å¤§å†™ä¹Ÿå¯ä»¥å°å†™ã€‚
5. åœ¨è¿›è¡Œç®—æœ¯è®¡ç®—æ—¶ï¼Œæ‰€æœ‰ä»¥å…«è¿›åˆ¶å’Œåå…­è¿›åˆ¶è¡¨ç¤ºçš„æ•°å€¼æœ€ç»ˆéƒ½å°†è¢«è½¬æ¢ä¸ºåè¿›åˆ¶æ•°å€¼ã€‚

#### ä¸‰. Binary Floating-Point and Rounding Errors
* There are infinitely many real numbers, but only a finite number of them (18437736874454810627, to be exact) can be represented exactly by the JavaScript floating-point format. This means that when youâ€™re working with real numbers in JavaScript, the representation of the number will often be an approximation of the actual number.
* The IEEE-754 floating-point representation used by JavaScript is a binary representation, which can exactly represent fractions like 1/2, 1/8, and 1/1024. Unfortunately, the fractions we use most commonly are decimal fractions 1/10, 1/100, and so on. Binary floating-point representations cannot exactly represent numbers as simple as 0.1.
```
var x = .3 - .2; // thirty cents minus 20 cents
var y = .2 - .1; // twenty cents minus 10 cents
x == y // => false: the two values are not the same!
x == .1 // => false: .3-.2 is not equal to .1
y == .1 // => true: .2-.1 is equal to .1
```
* Because of rounding error, the difference between the approximations of .3 and .2 is not exactly the same as the difference between the approximations of .2 and .1. 
* The computed values are adequate for almost any purpose: the problem arises when we attempt to compare values for equality
* A future version of JavaScript may support a decimal numeric type that avoids these rounding issues. Until then you might want to perform critical financial calculations using scaled integers. For example, you might manipulate monetary values as integer cents rather than fractional dollars.

#### å››. æµ®ç‚¹æ•°
1. æµ®ç‚¹æ•°å¿…é¡»åŒ…å«ä¸€ä¸ªå°æ•°ç‚¹ï¼Œå¹¶ä¸”å°æ•°ç‚¹åŽé¢å¿…é¡»è‡³å°‘æœ‰ä¸€ä½æ•°å­—ã€‚è™½ç„¶å°æ•°ç‚¹å‰é¢å¯ä»¥æ²¡æœ‰æ•´æ•°ï¼Œä½†å¹¶ä¸æŽ¨èã€‚  
```var  floatNum=.1     //æœ‰æ•ˆï¼Œä½†ä¸æŽ¨è ```
2. ç”±äºŽä¿å­˜æµ®ç‚¹æ•°å€¼éœ€è¦çš„å†…å­˜ç©ºé—´æ˜¯ä¿å­˜æ•´æ•°å€¼çš„ä¸¤å€ï¼Œå› æ­¤ECMAScriptä¼šä¸å¤±æ—¶æœºçš„å°†æµ®ç‚¹æ•°å€¼è½¬æ¢ä¸ºæ•´æ•°å€¼ï¼š
```
var floatNum1=1.;   //å°æ•°ç‚¹åŽæ²¡æœ‰æ•°å­—â€”â€”è§£æžä¸º1
var floatNum2=10.0   //æ•´æ•°â€”â€”è§£æžä¸º10
```
3. å¯¹äºŽæžå¤§æˆ–æžå°çš„æ•°å€¼ï¼Œå¯ä»¥ç”¨e/EæŒ‡æ•°è¡¨ç¤ºæ³•è¡¨ç¤ºçš„æµ®ç‚¹æ•°å€¼è¡¨ç¤ºã€‚
    é»˜è®¤æƒ…å†µä¸‹ï¼ŒECMAScriptä¼šå°†é‚£äº›å°æ•°ç‚¹åŽå¸¦æœ‰6ä¸ªé›¶ä»¥ä¸Šçš„æµ®ç‚¹æ•°è½¬æ¢ä¸ºä»¥eè¡¨ç¤ºæ³•è¡¨ç¤ºçš„æ•°å€¼ã€‚ä¾‹å¦‚ï¼Œ 0.0000003ä¼šè¢«è½¬æ¢æˆ3e-7ã€‚å®žæµ‹å¦‚æžœæ•´æ•°éƒ¨åˆ†ä¸æ˜¯0çš„è¯ï¼Œå¹¶ä¸ä¼šå˜æˆç§‘å­¦è®¡æ•°æ³•
4. åŸºäºŽIEEE754çš„æµ®ç‚¹æ•°å€¼çš„æœ€é«˜ç²¾åº¦æ˜¯17ä½å°æ•°ï¼Œä½†åœ¨è¿›è¡Œç®—æœ¯è®¡ç®—æ—¶å…¶ç²¾åº¦è¿œè¿œä¸å¦‚æ•´æ•°ã€‚ä¾‹å¦‚
```
var floatNum1=0.1;
var floatNum2=0.2;
var floatNum3=0.3;
document.write(floatNum1+floatNum2);    //è¿”å›žçš„æ˜¯0.30000000000000004
document.write(floatNum1+floatNum3);    //è¿”å›žçš„æ˜¯0.4
```
5. æ°¸è¿œä¸è¦æµ‹è¯•æŸä¸ªç‰¹å®šçš„æµ®ç‚¹æ•°å€¼ã€‚è¿™æ˜¯ä½¿ç”¨åŸºäºŽIEEE754æ•°å€¼çš„æµ®ç‚¹è®¡ç®—çš„é€šç—…ã€‚
6. ES6åœ¨Numberå¯¹è±¡ä¸Šé¢ï¼Œæ–°å¢žä¸€ä¸ªæžå°çš„å¸¸é‡Number.EPSILONç”¨æ¥å¤„ç†æµ®ç‚¹æ•°è¯¯å·®æ‰€å¸¦æ¥çš„é—®é¢˜ï¼Œå³
    å¦‚æžœè®¡ç®—ç»“æžœçš„è¯¯å·®å°äºŽNumber.EPSILONï¼Œæˆ‘ä»¬å°±å¯ä»¥è®¤ä¸ºå¾—åˆ°äº†æ­£ç¡®ç»“æžœã€‚

#### äº”. æ•°å€¼èŒƒå›´
1. ç”±äºŽå†…å­˜çš„é™åˆ¶ECMAScriptå¹¶ä¸èƒ½ä¿å­˜ä¸–ç•Œä¸Šæ‰€æœ‰çš„æ•°å€¼ã€‚ECMAScriptèƒ½å¤Ÿè¡¨ç¤ºçš„æœ€å°æ•°å€¼ä¿å­˜åœ¨Number.MIN_VALUEä¸­ï¼Œèƒ½å¤Ÿè¡¨ç¤ºçš„æœ€å¤§æ•°å€¼ä¿å­˜åœ¨Number.MAX_VALUEä¸­ã€‚
2. Arithmetic in JavaScript does not raise errors in cases of overflow, underflow, or division by zero. å¦‚æžœæŸæ¬¡è®¡ç®—çš„ç»“æžœè¶…å‡ºäº†èŒƒå›´ï¼Œåˆ™ä¼šè¢«è½¬æ¢ä¸ºç›¸åº”çš„-Infinityæˆ–Infinityã€‚è¯¥æ•°å€¼å°†æ— æ³•å‚ä¸Žä¸‹ä¸€æ¬¡çš„è®¡ç®—ã€‚  
3. æƒ³è¦ç¡®å®šä¸€ä¸ªæ•°å€¼æ˜¯ä¸æ˜¯æœ‰ç©·çš„ï¼Œå¯ä»¥ä½¿ç”¨Number.isFinite()ã€‚æ­£è´Ÿæ— ç©·ä»¥åŠNaNéƒ½ä¼šè¿”å›žfalseã€‚
4. åœ¨ES6ä¹‹å‰ï¼ŒisFiniteæ˜¯å…¨å±€å¯¹è±¡çš„æ–¹æ³•ï¼Œä¸”å¦‚æžœå‚æ•°ä¸æ˜¯æ•°å­—ï¼Œä¼šå…ˆè°ƒç”¨Number()å‡½æ•°è½¬æ¢ä¸ºæ•°å­—å†åˆ¤æ–­ï¼›ES6å°†å…¶å®šä¹‰åœ¨Numberä¸Šï¼Œä¸”ä¸å†è½¬åž‹ã€‚
5. ä½†æ˜¯ï¼Œå³ä½¿æ˜¯åœ¨Number.MIN_VALUEå’ŒNumber.MAX_VALUEä¹‹é—´çš„æ•°ï¼Œä¹Ÿä¸èƒ½ä¿è¯éƒ½èƒ½ç²¾ç¡®è®¡ç®—ã€‚JavaScriptèƒ½å¤Ÿå‡†ç¡®è¡¨ç¤ºçš„æ•´æ•°èŒƒå›´åœ¨-2^53åˆ°2^53ä¹‹é—´ï¼ˆä¸å«ä¸¤ä¸ªç«¯ç‚¹ï¼‰ï¼Œè¶…è¿‡è¿™ä¸ªèŒƒå›´ï¼Œæ— æ³•ç²¾ç¡®è¡¨ç¤ºè¿™ä¸ªå€¼ã€‚ES6å¼•å…¥äº†Number.MAX_SAFE_INTEGERå’ŒNumber.MIN_SAFE_INTEGERè¿™ä¸¤ä¸ªå¸¸é‡ï¼Œç”¨æ¥è¡¨ç¤ºè¿™ä¸ªèŒƒå›´çš„ä¸Šä¸‹é™ã€‚åŒæ—¶ï¼ŒES6çš„ Number.isSafeInteger()åˆ™æ˜¯ç”¨æ¥åˆ¤æ–­ä¸€ä¸ªæ•´æ•°æ˜¯å¦è½åœ¨è¿™ä¸ªèŒƒå›´ä¹‹å†…ã€‚
ä¸€ä¸ªæ³¨æ„ç‚¹æ˜¯ï¼Œä½ ä¸åº”å½“åªæ£€éªŒè¿ç®—ç»“æžœæ˜¯å¦åœ¨è¿™ä¸ªèŒƒå›´å†…ï¼Œè€Œåº”å½“æ£€éªŒå‚ä¸Žè¿ç®—çš„æ¯ä¸€ä¸ªæ•°ã€‚
6. è®¿é—®Number.NEGATIVE_INFINITYå’ŒNumber.POSITIVE_INFINITYå¯ä»¥å¾—åˆ°è´Ÿå’Œæ­£Infinityçš„å€¼ã€‚
7. Underflow occurs when the result of a numeric operation is closer to zero than the smallest representable number. In this case, JavaScript returns 0. If underflow occurs from a negative number, JavaScript returns a special value known as â€œnegative zero.â€ This value is almost completely indistinguishable from regular zero and JavaScript programmers rarely need to detect it.
8. Division by zero is not an error in JavaScript: it simply returns infinity or negative infinity. There is one exception, however: zero divided by zero does not have a welldefined value, and the result of this operation is the special not-a-number value, printed as NaN.

#### å…­. NaN
1.NaNï¼Œå³éžæ•°å€¼ï¼ˆNot a Numberï¼‰æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æ•°å€¼ï¼Œè¿™ä¸ªæ•°å€¼ç”¨äºŽè¡¨ç¤ºä¸€ä¸ªæœ¬æ¥è¦è¿”å›žæ•°å€¼çš„æ“ä½œæ•°æœªè¿”å›žæ•°å€¼çš„æƒ…å†µï¼ˆè¿™æ ·å°±ä¸ä¼šæŠ›å‡ºé”™è¯¯äº†ï¼‰ã€‚
2. ä»»ä½•æ¶‰åŠNaNçš„æ“ä½œéƒ½ä¼šè¿”å›žNaNã€‚
3. NaN does not compare equal to any other value, including itself. ä½†é€šè¿‡ES6çš„ Object.is()æ–¹æ³•æ˜¯ï¼Œå®ƒå’Œå®ƒæœ¬èº«ç›¸ç­‰ã€‚
4. isNaN()
ï¼ˆ1ï¼‰ES6ä¹‹å‰è¿™æ˜¯å…¨å±€æ–¹æ³•ï¼Œä¸”å¦‚æžœå‚æ•°ä¸æ˜¯æ•°å­—ï¼Œä¼šå…ˆè°ƒç”¨Number()å‡½æ•°è½¬æ¢ä¸ºæ•°å­—å†åˆ¤æ–­ï¼›ES6å°†å…¶ä½œä¸ºNumberçš„æ–¹æ³•ï¼Œä¸”ä¸å†è½¬åž‹ã€‚
ï¼ˆ2ï¼‰åœ¨æŽ¥æ”¶åˆ°ä¸€ä¸ªå€¼åŽï¼Œä¼šå°è¯•è½¬æ¢ä¸ºæ•°å€¼(ES6ä¹‹å‰)ï¼Œä»»ä½•ä¸èƒ½è¢«è½¬æ¢ä¸ºæ•°å€¼çš„å€¼éƒ½ä¼šå¯¼è‡´è¿™ä¸ªå‡½æ•°è¿”å›žtrueï¼š
```
alert(isNaN(NaN));      //true
alert(Number.isNaN(10));       //false
alert(isNaN("10"));     //false (å¯ä»¥è¢«è½¬æ¢ä¸ºæ•°å€¼10)
alert( isNaN(undefined) ); // true Number(undefined) è¿”å›žNaN
alert( Number.isNaN(undefined) ); // false ä¸è°ƒç”¨Number()è½¬åž‹
alert(isNaN("blue"));   //true  (Number("blue") return NaN)
alert(Number.isNaN("blue"));   //false  (ä¸å‘ç”Ÿè½¬åž‹,"blue"æ˜¾ç„¶ä¸æ˜¯NaN)
alert(isNaN(true));     //false (å¯ä»¥è¢«è½¬æ¢ä¸ºæ•°å€¼1ï¼‰
```
å¯ä»¥çœ‹å‡ºæ¥ï¼Œå› ä¸ºES6ä¹‹å‰isNaNä¼šè½¬åž‹ï¼Œæ‰€ä»¥ä¸èƒ½ç›´æŽ¥ç”¨å®ƒåˆ¤æ–­ä¸€ä¸ªå€¼æœ¬èº«æ˜¯ä¸æ˜¯NaNï¼Œå¿…é¡»å†åŒæ—¶ç¡®å®šè¯¥å€¼ typeof ä¸º numberæ‰è¡Œ



#### ä¸ƒ. æ•°å€¼è½¬æ¢
1.æœ‰ä¸‰ä¸ªå‡½æ•°å¯ä»¥æŠŠéžæ•°å€¼è½¬æ¢ä¸ºæ•°å€¼ï¼šNumber()ã€Number.parseInt()å’ŒNumber.parseFloat()ã€‚
2.ç¬¬ä¸€ä¸ªå‡½æ•°ï¼Œå³è½¬åž‹å‡½æ•°å¯ä»¥ç”¨äºŽä»»ä½•æ•°æ®ç±»åž‹ã€‚å¦å¤–ä¸¤ä¸ªå‡½æ•°åˆ™ä¸“é—¨ç”¨äºŽæŠŠå­—ç¬¦ä¸²è½¬æ¢æˆæ•°å€¼ã€‚å®žæµ‹åŽä¸¤ä¸ªä¹Ÿå¯ä»¥è½¬æ¢é¦–é¡¹æ˜¯æ•°å­—æˆ–æ•°å­—å­—ç¬¦ä¸²çš„æ•°ç»„ï¼Œä½†ä¸èƒ½è½¬æ¢å¸ƒå°”å€¼ã€‚
3.è¿™ä¸‰ä¸ªå‡½æ•°å¯¹äºŽåŒæ ·çš„è¾“å…¥ä¼šæœ‰è¿”å›žä¸åŒçš„ç»“æžœã€‚
4.è½¬æ¢æžå¤§æˆ–æžå°çš„æ•´æ•°æ—¶ä¼šè¿”å›žä¸ªä½æ•°ï¼Œå› ä¸ºä½¿ç”¨äº†eåº•æ•°çš„è®¡æ•°æ³•ã€‚
5.ä¸€å…ƒåŠ æ“ä½œç¬¦çš„æ“ä½œä¸ŽNumber()å‡½æ•°ç›¸åŒ

6.Number()å‡½æ•°çš„è½¬æ¢è§„åˆ™å¦‚ä¸‹ï¼š
     ï¼ˆ1ï¼‰å¦‚æžœæ˜¯Booleanå€¼ï¼Œtrueå’Œfalseå°†åˆ†åˆ«è¢«è½¬æ¢ä¸º1å’Œ0.
     ï¼ˆ2ï¼‰å¦‚æžœæ˜¯æ•°å­—å€¼ï¼Œåªæ˜¯ç®€å•çš„ä¼ å…¥å’Œè¿”å›žã€‚ï¼ˆå…¶ä»–è¿›åˆ¶ä¼šè½¬æ¢åˆ°10è¿›åˆ¶ï¼‰
     ï¼ˆ3ï¼‰å¦‚æžœæ˜¯nullå€¼ï¼Œè¿”å›ž0ã€‚
     ï¼ˆ4ï¼‰å¦‚æžœæ˜¯undefinedï¼Œè¿”å›žNaNã€‚
     ï¼ˆ5ï¼‰å¦‚æžœæ˜¯å­—ç¬¦ä¸²ï¼Œéµå¾ªä¸‹åˆ—è§„åˆ™ï¼š
          â‘ å¦‚æžœå­—ç¬¦ä¸²åªåŒ…å«æ•°å­—ï¼ˆåŒ…æ‹¬å‰é¢å¸¦æ­£è´Ÿå·çš„æƒ…å†µï¼‰ï¼Œåˆ™å°†å…¶è½¬æ¢ä¸ºåè¿›åˆ¶æ•°å€¼ã€‚ï¼ˆâ€011â€œä¼šè¢«è½¬æ¢ä¸º11ï¼‰
          â‘¡å¦‚æžœå­—ç¬¦ä¸²ä¸­åŒ…å«æœ‰æ•ˆçš„æµ®ç‚¹æ ¼å¼ï¼Œåˆ™å°†å…¶è½¬æ¢ä¸ºå¯¹åº”çš„æµ®ç‚¹æ•°å€¼ã€‚ï¼ˆåŒæ ·å¿½ç•¥å‰å¯¼é›¶ï¼‰
          â‘¢å¦‚æžœå­—ç¬¦ä¸²åŒ…å«æœ‰æ•ˆçš„åå…­è¿›åˆ¶æ ¼å¼ï¼Œåˆ™å°†å…¶è½¬æ¢ä¸ºç›¸åŒå¤§å°çš„åè¿›åˆ¶æ•´æ•°å€¼ã€‚
          â‘£å¦‚æžœå­—ç¬¦ä¸²æ˜¯ç©ºçš„ï¼Œåˆ™å°†å…¶è½¬æ¢ä¸º0ã€‚parseIntå’ŒparseFloatåœ¨è¿™ç§æƒ…å†µä¸‹è¿”å›žNaN
          â‘¤å¦‚æžœå­—ç¬¦ä¸²åŒ…å«é™¤ä¸Šè¿°æ ¼å¼ä»¥å¤–çš„å­—ç¬¦ï¼Œåˆ™å°†å…¶è½¬æ¢ä¸ºNaNã€‚
    ï¼ˆ6ï¼‰å¦‚æžœæ˜¯å¯¹è±¡ï¼Œåˆ™è°ƒç”¨å¯¹è±¡çš„valueOf()æ–¹æ³•ï¼Œç„¶åŽä¾ç…§å‰é¢çš„è§„åˆ™è½¬æ¢è¿”å›žçš„å€¼ã€‚å¦‚æžœè½¬æ¢çš„ç»“æžœæ˜¯NaNï¼Œåˆ™è°ƒç”¨å¯¹è±¡çš„toString()æ–¹æ³•ï¼Œç„¶åŽå†æ¬¡ä¾ç…§å‰é¢çš„è§„åˆ™è½¬æ¢è¿”å›žçš„å­—ç¬¦ ä¸²å€¼ã€‚ä¸æ‡‚
7.Number.parseInt()ã€‚
ï¼ˆ1ï¼‰ES6ä¹‹å‰è¿™æ˜¯å…¨å±€æ–¹æ³•ï¼ŒES6å°†å…¶ä½œä¸ºNumberçš„æ–¹æ³•
     ï¼ˆ2ï¼‰parseInt()ä¼šå¿½ç•¥å­—ç¬¦ä¸²å‰é¢çš„ç©ºæ ¼ï¼Œç›´åˆ°æ‰¾åˆ°ç¬¬ä¸€ä¸ªéžç©ºæ ¼å­—ç¬¦
     ï¼ˆ3ï¼‰å¦‚æžœç¬¬ä¸€ä¸ªéžç©ºæ ¼å­—ç¬¦ä¸æ˜¯æ•°å­—å­—ç¬¦æˆ–è€…æ­£è´Ÿå·ï¼Œä¼šè¿”å›žNaN
     ï¼ˆ4ï¼‰å¦‚æžœç¬¬ä¸€ä¸ªå­—ç¬¦æ˜¯æ•°å­—å­—ç¬¦æˆ–è€…æ­£è´Ÿå·ï¼Œä¼šç»§ç»­è§£æžä¸‹ä¸€ä¸ªï¼Œç›´åˆ°è§£æžå®ŒåŽç»­çš„æ‰€æœ‰æ•°å­—å­—ç¬¦æˆ–è€…æ˜¯é‡åˆ°ä¸€ä¸ªéžæ•°å­—å­—ç¬¦ã€‚
     ï¼ˆ5ï¼‰parseInt()å¯ä»¥é»˜è®¤å¯ä»¥è¯†åˆ«å…«è¿›åˆ¶å’Œåå…­è¿›åˆ¶ï¼Œå¹¶è§£æžè¿”å›žä¸ºåè¿›åˆ¶ã€‚ECMAScript 5å·²ç»ä¸èƒ½è¯†åˆ«å…«è¿›åˆ¶ã€‚ä½†é€šè¿‡ä¼ å‚å¯ä»¥
            è¯†åˆ«ä»»ä½•è¿›åˆ¶ï¼Œè€Œä¸”ä¸ç”¨å†™æˆå…«è¿›åˆ¶æˆ–åå…­è¿›åˆ¶æ ¼å¼ã€‚å’ŒtoString()æ•ˆæžœç›¸å
     ï¼ˆ6ï¼‰å»ºè®®æ— è®ºåœ¨ä»€ä¹ˆæƒ…å†µä¸‹éƒ½æ˜Žç¡®æŒ‡å®šåŸºæ•°ã€‚
8. Number.parseFloat()
ï¼ˆ1ï¼‰ES6ä¹‹å‰è¿™æ˜¯å…¨å±€æ–¹æ³•ï¼ŒES6å°†å…¶ä½œä¸ºNumberçš„æ–¹æ³•
ï¼ˆ2ï¼‰å¦‚æžœå­—ç¬¦ä¸²åŒ…å«çš„æ˜¯ä¸€ä¸ªå¯è§£æžä¸ºæ•´æ•°çš„æ•°ï¼ˆæ²¡æœ‰å°æ•°ç‚¹æˆ–è€…å°æ•°ç‚¹åŽå…¨æ˜¯0ï¼‰ï¼Œå°†ä¼šè¿”å›žæ•´æ•°ã€‚
ï¼ˆ3ï¼‰çœ‹èµ·æ¥ï¼Œä¸ç®¡æ˜¯ES6çš„è¿˜æ˜¯ä¹‹å‰çš„è¯¥æ–¹æ³•ï¼Œè§£æžç²¾åº¦éƒ½æ¯”è¾ƒæœ‰é™
var parsedFloat1 = parseFloat( '1.337000012397766117451156851189711');
console.log( parsedFloat1 );// 1.3370000123977661
var parsedFloat2 = Number.parseFloat( '1.337000012397766117451156851189711');
console.log( parsedFloat2 );// 1.337000012397761



## Stringç±»åž‹
#### ä¸€.æ¦‚è¿°
1. JavaScript uses the UTF-16 encoding of the Unicode character set, and JavaScript strings are sequences of unsigned 16-bit values. 
2. The most commonly used Unicode characters (those from the â€œbasic multilingual planeâ€) have codepoints that fit in 16 bits and can be represented by a single element of a string. Unicode characters whose
codepoints do not fit in 16 bits are encoded following the rules of UTF-16 as a sequence (known as a â€œsurrogate pairâ€) of two 16-bit values. This means that a JavaScript string of length 2 (two 16-bit values) might represent only a single Unicode character
```
let p = "Ï€"; // Ï€ is 1 character with 16-bit codepoint 0x03c0
let e = "ð‘’"; // ð‘’ is 1 character with 17-bit codepoint 0x1d452
p.length // => 1: p consists of 1 16-bit element
e.length // => 2: UTF-16 encoding of ð‘’ is 2 16-bit values: "\ud835\udc52"
```
3. The length of a string is the number of 16-bit values it contains, not the number of characters.
4. The various string-manipulation methods defined by JavaScript operate on 16-bit values, not on characters. They do not treat surrogate pairs specially, perform no normalization of the string, and do not even ensure that a string is well-formed UTF-16.
5. ECMAScript strings are immutable. 
    * You can access the text at any index of a string, but JavaScript provides no way to alter the text of an existing string. 
    ```
    let str = 'abc';
    console.log( str[1] ); // 'b'
    str[1] = 'd'; // TypeError: Cannot assign to read only property '1' of string 'abc'
    ```
    * è¦æ”¹å˜æŸä¸ªå˜é‡ä¿å­˜çš„å­—ç¬¦ä¸²ï¼Œé¦–å…ˆè¦é”€æ¯åŽŸæ¥çš„å­—ç¬¦ä¸²ï¼Œç„¶åŽå†ç”¨å¦ä¸€ä¸ªåŒ…å«æ–°å€¼çš„å­—ç¬¦ä¸²å……å¡«è¯¥å˜é‡ã€‚
    ```
    let lang = "Java";
    lang = lang + "Script";
    ```
    å®žçŽ°è¿™ä¸ªæ“ä½œçš„è¿‡ç¨‹å¦‚ä¸‹ï¼šé¦–å…ˆåˆ›å»ºä¸€ä¸ªèƒ½å®¹çº³10ä¸ªå­—ç¬¦çš„æ–°å­—ç¬¦ä¸²ï¼Œç„¶åŽåœ¨è¿™ä¸ªå­—ç¬¦ä¸²ä¸­å¡«å……"Java"å’Œ"Script"ï¼Œæœ€åŽä¸€æ­¥æ˜¯é”€æ¯åŽŸæ¥çš„å­—ç¬¦ä¸²"Java"å’Œå­—ç¬¦ä¸²"Script"ã€‚   

    * All string methods that appear to return a modified string are, in fact, returning a new string value. 

6. In ECMAScript 5, you can break a string literal across multiple lines by ending each line but the last with a backslash (\\).
```
let str = "hello \
world \
!";
console.log( str ); // hello world !
```
7. ==ä¸æ‡‚ES6å¯¹å­—ç¬¦unicodeè¡¨ç¤ºæ³•çš„æ‰©å±•== http://es6.ruanyifeng.com/#docs/string


#### äºŒ. Escape Sequences in String Literals
Stringæ•°æ®ç±»åž‹åŒ…å«ä¸€äº›ç‰¹æ®Šçš„å­—ç¬¦å­—é¢é‡ï¼Œä¹Ÿå«è½¬ä¹‰åºåˆ—ï¼Œç”¨äºŽè¡¨ç¤ºéžæ‰“å°å­—ç¬¦ï¼Œæˆ–è€…å…·æœ‰å…¶ä»–ç”¨é€”çš„å­—ç¬¦ã€‚è¿™äº›å­—ç¬¦å­—é¢é‡å¦‚ä¸‹è¡¨æ‰€ç¤ºï¼š

å­—é¢é‡ | å«ä¹‰
---|---
\n | æ¢è¡Œ
\t | åˆ¶è¡¨
\b | é€€æ ¼
\r | å›žè½¦
\f | è¿›çº¸
\\\ | æ–œæ 
\\' | å•å¼•å·ï¼ˆ'ï¼‰ï¼Œåœ¨ç”¨å•å¼•å·è¡¨ç¤ºçš„å­—ç¬¦ä¸²ä¸­ä½¿ç”¨ã€‚ä¾‹å¦‚ï¼š'He said, \'hey.\''
\\" | åŒå¼•å·ï¼ˆ"ï¼‰ï¼Œåœ¨ç”¨åŒå¼•å·è¡¨ç¤ºçš„å­—ç¬¦ä¸²ä¸­ä½¿ç”¨ã€‚ä¾‹å¦‚ï¼š"He said, \"hey.\""
\xnn | ä»¥åå…­è¿›åˆ¶ä»£ç nnè¡¨ç¤ºçš„ä¸€ä¸ªå­—ç¬¦ï¼ˆå…¶ä¸­nä¸º0ï½žFï¼‰ã€‚ä¾‹å¦‚ï¼Œ\x41è¡¨ç¤º"A"
\unnnn | ä»¥åå…­è¿›åˆ¶ä»£ç nnnnè¡¨ç¤ºçš„ä¸€ä¸ªUnicodeå­—ç¬¦ï¼ˆå…¶ä¸­nä¸º0ï½žFï¼‰ã€‚ä¾‹å¦‚ï¼Œ\u03a3è¡¨ç¤ºå¸Œè…Šå­—ç¬¦Î£


è¿™äº›å­—ç¬¦å­—é¢é‡å¯ä»¥å‡ºçŽ°åœ¨å­—ç¬¦ä¸²ä¸­çš„ä»»æ„ä½ç½®ï¼Œè€Œä¸”ä¹Ÿå°†è¢«ä½œä¸ºä¸€ä¸ªå­—ç¬¦æ¥è§£æžï¼Œå¦‚ä¸‹é¢çš„ä¾‹å­æ‰€ç¤ºï¼š
var text = "This is the letter sigma: \u03a3.";
å› ä¸ºä¼šè¢«ä½œä¸ºä¸€ä¸ªå­—ç¬¦è§£æžï¼Œæ‰€ä»¥å…¶lengthå€¼ä¹Ÿæ˜¯1


#### ä¸‰. ES6 æ¨¡æ¿å­—ç¬¦ä¸²ï¼šç›´æŽ¥åœ¨å­—ç¬¦ä¸²é‡Œä½¿ç”¨å˜é‡æˆ–è€…å‡½æ•°
ä½¿ç”¨åå¼•å·ï¼ˆæ³¢æµªé”®ï¼‰çš„å­—ç¬¦ä¸²ï¼Œå†…éƒ¨å¯ç›´æŽ¥ä½¿ç”¨å˜é‡åŠå…¶ä»–ä»£ç ï¼Œè¯­æ³•ç±»ä¼¼å¦‚ä¸‹ä¸¤ä¸ª
```
console.log( `hello world` );             // hello world

let name = 22;
console.log( `Hello ${name}` );           // hello 22

let yourName = ()=>11+22;
console.log( `ä½ å¥½ï¼Œ${ yourName()}` );    // ä½ å¥½ï¼Œ33
```
1. å¦‚æžœåœ¨æ¨¡æ¿å­—ç¬¦ä¸²ä¸­éœ€è¦ä½¿ç”¨åå¼•å·ï¼Œåˆ™è¦è½¬ä¹‰
2. å¦‚æžœä½¿ç”¨æ¨¡æ¿å­—ç¬¦ä¸²è¡¨ç¤ºå¤šè¡Œå­—ç¬¦ä¸²ï¼Œæ‰€æœ‰çš„ç©ºæ ¼å’Œç¼©è¿›éƒ½ä¼šè¢«ä¿ç•™åœ¨è¾“å‡ºä¹‹ä¸­ã€‚
3. å¦‚æžœå¤§æ‹¬å·ä¸­çš„å€¼ä¸æ˜¯å­—ç¬¦ä¸²ï¼Œå°†æŒ‰ç…§ä¸€èˆ¬çš„è§„åˆ™è½¬ä¸ºå­—ç¬¦ä¸²ã€‚
4. æ¨¡æ¿å­—ç¬¦ä¸²å¯ä»¥åµŒå¥—

==æ¨¡æ¿ç¼–è¯‘ ä¸æ‡‚  
æ ‡ç­¾æ¨¡æ¿ ä¸æ‡‚  
http://es6.ruanyifeng.com/#docs/string==



#### 




## Objectç±»åž‹
#### ä¸€.æ¦‚è¿°
1. åœ¨ECMAScriptä¸­ï¼Œå¦‚æžœä¸ç»™æž„é€ å‡½æ•°ä¼ é€’å‚æ•°ï¼Œåˆ™å¯ä»¥çœç•¥åŽé¢çš„æ‹¬å·ï¼Œä½†å¹¶ä¸æŽ¨èã€‚
2. åœ¨ECMAScriptä¸­ï¼ŒObjectç±»åž‹æ˜¯æ‰€æœ‰å®ƒçš„å®žä¾‹çš„åŸºç¡€ã€‚æ¢å¥è¯è¯´ï¼ŒObjectç±»åž‹æ‰€å…·æœ‰çš„ä»»ä½•å±žæ€§åŒæ ·å­˜åœ¨ä¸Žæ›´å…·ä½“çš„å¯¹è±¡ä¸­ã€‚

#### äºŒ. references
* object values are references, and we say that objects are compared by reference: two object values are the same if and only if they refer to the same underlying object.
```
var a = []; // The variable a refers to an empty array.
var b = a; // Now b refers to the same array.
b[0] = 1; // Mutate the array referred to by variable b.
a[0] // => 1: the change is also visible through variable a.
a === b // => true: a and b refer to the same object, so they are equal.
```
Assigning an object (or array) to a variable simply assigns the reference: it does not create a new copy of the object. 
* If you want to make a new copy of an object or array, you must explicitly copy the properties of the object or the elements of the array.
```
var a = ['a','b','c']; // An array we want to copy
var b = []; // A distinct array we'll copy into
for(var i = 0; i < a.length; i++) // For each index of a[]
{ 
    b[i] = a[i]; // Copy an element of a into b
}
```
* if we want to compare two distinct objects or arrays, we must compare their
properties or elements. 
```
function equalArrays(a,b) 
{
    if (a.length != b.length)
    {
        return false; // Different-size arrays not equal
    }
    for(var i = 0; i < a.length; i++) // Loop through all elements
    {
        if (a[i] !== b[i]) 
        {
            return false; // If any differ, arrays not equal
        }
    }
    return true; // Otherwise they are equal
}
```

#### ä¸‰. Objectçš„æ¯ä¸ªå®žä¾‹éƒ½å…·æœ‰ä¸‹åˆ—å±žæ€§å’Œæ–¹æ³•ï¼š
* constructorï¼šä¿å­˜ç€ç”¨äºŽåˆ›å»ºå½“å‰å¯¹è±¡çš„å‡½æ•°ã€‚
* hasOwnProperty(propertyName)ï¼šç”¨äºŽæ£€æŸ¥ç»™å®šçš„å±žæ€§åœ¨å½“å‰å¯¹è±¡å®žä¾‹ä¸­ï¼ˆè€Œä¸æ˜¯åœ¨å®žä¾‹çš„åŽŸåž‹ä¸­ï¼‰æ˜¯å¦å­˜åœ¨ã€‚å…¶ä¸­ï¼Œä½œä¸ºå‚æ•°çš„å±žæ€§åå¿…é¡»ä»¥å­—ç¬¦ä¸²å½¢å¼æŒ‡å®šã€‚
* isPrototypeOf(object)ï¼šç”¨äºŽæ£€æŸ¥ä¼ å…¥çš„å¯¹è±¡æ˜¯å¦æ˜¯å¦ä¸€ä¸ªå¯¹è±¡çš„åŽŸåž‹ã€‚
* ==propertyIsEnumerable(propertyName):ç”¨äºŽæ£€æŸ¥ç»™å®šçš„å±žæ€§æ˜¯å¦èƒ½å¤Ÿä½¿ç”¨for-inè¯­å¥æ¥æžšä¸¾ã€‚ä¸ŽhasOwnProperty()æ–¹æ³•ä¸€æ ·ï¼Œä½œä¸ºå‚æ•°çš„å±žæ€§åå¿…é¡»ä»¥å­—ç¬¦ä¸²çš„å½¢å¼æŒ‡å®šã€‚ä¸æ‡‚==
* toLocaleString()ï¼šè¿”å›žå¯¹è±¡çš„å­—ç¬¦ä¸²è¡¨ç¤ºï¼Œè¯¥å­—ç¬¦ä¸²ä¸Žæ‰§è¡ŒçŽ¯å¢ƒçš„åœ°åŒºå¯¹åº”ã€‚
    1. The default ```toLocaleString()``` method defined by Object doesnâ€™t do any localization itself: it simply calls ```toString()``` and returns that value.
    2. The Date and Number classes define customized versions of ```toLocaleString()``` that attempt to format numbers, dates, and times according to local conventions.
    3. Array defines a ```toLocaleString()``` method that works like ```toString()``` except that it formats array elements by calling their ```toLocaleString()``` methods instead of their ```toString()``` methods, and then it concatenates the resulting strings using a locale-specific (and implementation-defined) separator string
* toString():è¿”å›žå¯¹è±¡çš„å­—ç¬¦ä¸²è¡¨ç¤ºã€‚
    ```
    let obj = {x:3, y:5};
    console.log( obj.toString() ); // "[object Object]"
    
    let arr = [1, 2, 3];
    console.log( arr.toString() ); // "1,2,3"
    
    function fn(){return;}
    console.log( fn.toString() ); // "function fn(){return;}"
    
    let date = new Date();
    console.log( date.toString() ); // "Mon Sep 19 2016 13:02:58 GMT+0800 (China Standard Time)"
    
    let re = /\d+/g;
    console.log( re.toString() ); // "/\d+/g"
    ```
* valueOf()ï¼šè¿”å›žå¯¹è±¡çš„åŽŸå§‹å€¼
JavaScript calls this method automatically if an object is used in a context where a primitive value is required. 

å¯¹è±¡ç±»åž‹ | è¿”å›žå€¼
---|---
boolean | åŽŸå§‹å€¼
string | åŽŸå§‹å€¼
number	| åŽŸå§‹å€¼
object | è¯¥å¯¹è±¡åŽŸå§‹å€¼ï¼ˆæ¬²å°†objectå¯¹è±¡è½¬æ¢ä¸ºå¯è§çš„å­—ç¬¦ä¸²å½¢å¼ï¼Œéœ€è¦ç”¨JSON.stringify()æ–¹æ³•ï¼‰
function | åŽŸå§‹å€¼ã€‚è¿”å›žçš„ç±»åž‹è¿˜æ˜¯å‡½æ•°
array | åŽŸå§‹å€¼ã€‚è¿”å›žçš„ç±»åž‹è¿˜æ˜¯æ•°ç»„
date | è‡³ä»Šæ¯«ç§’æ•°çš„numberç±»åž‹
regexp | æœ¬èº«
undefined | æŠ¥é”™
null | æŠ¥é”™

#### å››. ECMA-262ä»¥å¤–çš„å¯¹è±¡
ä»ŽæŠ€æœ¯è§’åº¦è®²ï¼ŒECMA-262ä¸­å¯¹è±¡çš„è¡Œä¸ºä¸ä¸€å®šé€‚ç”¨äºŽJavaScriptä¸­çš„å…¶ä»–å¯¹è±¡ã€‚æµè§ˆå™¨çŽ¯å¢ƒä¸­çš„å¯¹è±¡ï¼Œæ¯”å¦‚BOMå’ŒDOMä¸­çš„å¯¹è±¡ï¼Œéƒ½å±žäºŽå®¿ä¸»å¯¹è±¡ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ç”±å®¿ä¸»å®žçŽ°æä¾›å’Œå®šä¹‰çš„ã€‚ECMA-262ä¸è´Ÿè´£å®šä¹‰å®¿ä¸»å¯¹è±¡ï¼Œå› æ­¤å®¿ä¸»å¯¹è±¡å¯èƒ½ä¼šä¹Ÿå¯èƒ½ä¸ä¼šç»§æ‰¿Objectã€‚


#### äº”. å±žæ€§å•ç‹¬ä½¿ç”¨çš„æ—¶å€™å¿…é¡»è¦åŠ å¼•å·
```
var obj = {
  a:1,
  b:2
};
delete obj.a;        //è¿™é‡Œä¸åŠ å¼•å·ä¸ä¼šæŠ¥é”™
alert("a" in obj);  //è¿™é‡Œä¸åŠ å¼•å·å°±ä¼šæŠ¥é”™
```

#### å…­.éåŽ†å¯¹è±¡çš„å±žæ€§å’Œå€¼
```
for(var i in obj)
{
    console.log(i +":"+ obj[i]);
}
```

## Global Object
* When the JavaScript interpreter starts (or whenever a web browser loads a new page), it creates a new global object and gives it an initial set of properties that define:
    * global properties like undefined, Infinity, and NaN
    * global functions like isNaN(), parseInt() , and eval().
    * constructor functions like Date(), RegExp(), String(), Object(), and Array()
    * global objects like Math and JSON
* The initial properties of the global object are not reserved words, but they deserve to be treated as if they are.
* In top-level code you can use the JavaScript keyword this to refer to the global object.In client-side JavaScript, the Window object serves as the global object for all JavaScript code contained in the browser window it represents. This global Window object has a self-referential window property that can be used instead of this to refer to the global object. 
```
console.log( window === this );  // true
console.log( this.window === this ); // true
```

## Wrapper Objects
* Three special reference types are designed to ease interaction with primitive values: the Boolean type, the Number type, and the String type. These types can act like the other reference types, but they also have a special behavior related to their primitive-type equivalents.  
 Every time a primitive value is read, an object of the corresponding primitive wrapper type is created behind the scenes, allowing access to any number of methods for manipulating the
data. 
    ```
    var s1 = "some text";
    var s2 = s1.substring(2);
    ```
    In this code, s1 is a variable containing a string, which is a primitive value. On the next line, the substring() method is called on s1 and stored in s2. Primitive values arenâ€™t objects, so logically they shouldnâ€™t have methods, though this still works as you would expect. In truth, there is a lot going on behind the scenes to allow this seamless operation. When s1 is accessed in the second line, it is being accessed in read mode, which is to say that its value is being read from memory. Any time a string value is accessed in read mode, the following three steps occur:
    1. Create an instance of the String type.
    2. Call the specified method on the instance.
    3. Destroy the instance.  
    
    You can think of these three steps as theyâ€™re used in the following three lines of ECMAScript code:
    ```
    var s1 = new String("some text");
    var s2 = s1.sunstring(2);
    s1 = null;
    ```
---
* The major difference between reference types and primitive wrapper types is the lifetime of the object. When you instantiate a reference type using the new operator, it stays in memory until it goes out of scope, whereas automatically created primitive wrapper objects exist for only one line of code before they are destroyed. This means that properties and methods cannot be added at runtime.
    ```
    var s1 = "some text";
    s1.color = "red";
    alert(s1.color);          //undefined
    ```
    The String object that was created in the second line is destroyed by the time the third line is executed. The third line creates its own String object, which doesnâ€™t have the color property.

---
* It is possible to create the primitive wrapper objects explicitly using the Boolean, Number, and String constructors. 
1. è¿™ç§æƒ…å†µä¸‹çš„åŸºæœ¬åŒ…è£…ç±»åž‹çš„ç”Ÿå­˜æœŸå’Œå¼•ç”¨ç±»åž‹ä¸€æ ·ã€‚
2. This should be done only when absolutely necessary, because it is often
confusing for developers as to whether they are dealing with a primitive or reference value.
3. Calling typeof on an instance of a primitive wrapper type returns â€œobjectâ€, and all primitive wrapper objects convert to the Boolean value true.ä¹Ÿå°±æ˜¯è¯´ç©ºå­—ç¬¦ä¸²ã€0ã€falseçš„åŸºæœ¬åŒ…è£…ç±»åž‹ä¹Ÿæ˜¯trueã€‚
5.The Object constructor also acts as a factory method and is capable of returning an instance of a primitive wrapper based on the type of value passed into the constructor. 
```
var obj = new Object("some text");
alert(obj instanceof String);     //true
```
5. The == equality operator treats a value and its wrapper object as equal, but you can distinguish them with the === strict equality operator.
```
let str = "hello",
    oStr = new String( "hello" );
console.log( str == oStr );  // true
console.log( str === oStr ); // true
```