
* String, Numbers, booleans, null, and undefined are immutable


typeof操作符————————————————————
* Technically, functions are considered objects in ECMAScript and don’t represent another data type. However, they do have some special properties, which necessitates differentiating between functions and other objects via the typeof operator.
* 用typeof测试未声明的变量也不会报错，但如果检测之后才用let声明的变量则会出错
        console.log(typeof value);     // ReferenceError!
        var value = "blue";
http://es-discourse.com/t/why-typeof-is-no-longer-safe/15

## Undefined Type
1. The undefined value represents a deeper kind of absence. 
2. A variable containing the value of undefined is different from a variable that hasn’t been
defined at all.：
```
var message;
alert(message);    //"undefined"
alert(age);        //产生错误
```
3. The typeof operator returns “undefined” when called on an uninitialized variable, but it also
returns “undefined” when called on an undeclared variable.
```
var message;
alert(typeof message);     //"undefined"
alert(typeof age);         //"undefined"     
```
Even though uninitialized variables are automatically assigned a value of undefined, it is advisable to always initialize variables. That way, when typeof returns "undefined", you’ll know that it’s because a given variable hasn’t been declared rather than was simply not initialized.




## Null Type
1. The Null type is the second data type that has only one value: the special value null. Logically, a null value is an empty object pointer, which is why typeof returns “object” when it’s passed a null value
2. The value undefined is a derivative of null, so ECMA-262 defines them to be superficially equal 
```alert(null == undefined); //true```
3. You might consider undefined to represent a system-level, unexpected, or error-like absence of value and null to represent program-level, normal, or expected absence of value. If you need to assign one of these values to a variable or property or pass one of these values to a function, null is almost always the right choice.This helps to keep the paradigm of null as an empty object pointer and further differentiates it from undefined.


## Boolean类型
1. 该类型只有两个字面值：true和false。Boolean类型的字面值是区分大小写的。
2. 虽然Boolean类型的字面值只有两个，但ECMAscript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean(): 
3. 可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值。至于返回的这个值是true还是false，取决于要转换值的数据类型及其实际值。

数据类型 | 转换为true的值 | 转换为false的值
---|---|---
Boolean | true | false
String | 任何非空字符串 | 	""
Number | 任何非零数字值（包括无穷大） | 0和NaN
Object | 任何对象 | null
Undefined | n/a（或N/A，not applicable的缩写，意为”不适用“） | undefined




## Number类型
#### 一. 这种类型使用IEEE754格式来表示整数和浮点数。
1. Unlike many languages, JavaScript does not make a distinction between integer values and floating-point values. All numbers in JavaScript are represented as floating-point values. 
2. JavaScript represents numbers using the 64-bit floating-point format defined by the IEEE 754 standard,1 which means it can represent numbers as large as ±1.7976931348623157 × 10^308 and as small as ±5 × 10^−324.
3. The JavaScript number format allows you to exactly represent all integers between −9007199254740992 (−2^53) and 9007199254740992 (2^53), inclusive. However, certain operations in JavaScript (such as array indexing and the bitwise operators) are performed with 32-bit integers.
4. ES6中 Number.isInteger() 判断一个值是否为整数
（1）需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值，都会返回true


#### 二. 进制
1. ES6提供了二进制数字的写法，使用前缀0b或0B
2. ES6之前，八进制字面值的第一位必须是0.如果字面值中的数值超出了范围，那么前导0将被忽略，后面的数值将当做十进制数值解析。
     var octalNum=08   //无效的八进制数值——解析为8
3. ES6之前，八进制字面量在严格模式下是无效的，会导致支持的JavaScript引擎抛出错误。但ES6提供了八进制的新前缀：0o或0O
4. 十六进制字面值的前两位必须是0x或0X，字母A~F可以大写也可以小写。
5. 在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换为十进制数值。

#### 三. Binary Floating-Point and Rounding Errors
* There are infinitely many real numbers, but only a finite number of them (18437736874454810627, to be exact) can be represented exactly by the JavaScript floating-point format. This means that when you’re working with real numbers in JavaScript, the representation of the number will often be an approximation of the actual number.
* The IEEE-754 floating-point representation used by JavaScript is a binary representation, which can exactly represent fractions like 1/2, 1/8, and 1/1024. Unfortunately, the fractions we use most commonly are decimal fractions 1/10, 1/100, and so on. Binary floating-point representations cannot exactly represent numbers as simple as 0.1.
```
var x = .3 - .2; // thirty cents minus 20 cents
var y = .2 - .1; // twenty cents minus 10 cents
x == y // => false: the two values are not the same!
x == .1 // => false: .3-.2 is not equal to .1
y == .1 // => true: .2-.1 is equal to .1
```
* Because of rounding error, the difference between the approximations of .3 and .2 is not exactly the same as the difference between the approximations of .2 and .1. 
* The computed values are adequate for almost any purpose: the problem arises when we attempt to compare values for equality
* A future version of JavaScript may support a decimal numeric type that avoids these rounding issues. Until then you might want to perform critical financial calculations using scaled integers. For example, you might manipulate monetary values as integer cents rather than fractional dollars.

#### 四. 浮点数
1. 浮点数必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但并不推荐。  
```var  floatNum=.1     //有效，但不推荐 ```
2. 由于保存浮点数值需要的内存空间是保存整数值的两倍，因此ECMAScript会不失时机的将浮点数值转换为整数值：
```
var floatNum1=1.;   //小数点后没有数字——解析为1
var floatNum2=10.0   //整数——解析为10
```
3. 对于极大或极小的数值，可以用e/E指数表示法表示的浮点数值表示。
    默认情况下，ECMAScript会将那些小数点后带有6个零以上的浮点数转换为以e表示法表示的数值。例如， 0.0000003会被转换成3e-7。实测如果整数部分不是0的话，并不会变成科学计数法
4. 基于IEEE754的浮点数值的最高精度是17位小数，但在进行算术计算时其精度远远不如整数。例如
```
var floatNum1=0.1;
var floatNum2=0.2;
var floatNum3=0.3;
document.write(floatNum1+floatNum2);    //返回的是0.30000000000000004
document.write(floatNum1+floatNum3);    //返回的是0.4
```
5. 永远不要测试某个特定的浮点数值。这是使用基于IEEE754数值的浮点计算的通病。
6. ES6在Number对象上面，新增一个极小的常量Number.EPSILON用来处理浮点数误差所带来的问题，即
    如果计算结果的误差小于Number.EPSILON，我们就可以认为得到了正确结果。

#### 五. 数值范围
1. 由于内存的限制ECMAScript并不能保存世界上所有的数值。ECMAScript能够表示的最小数值保存在Number.MIN_VALUE中，能够表示的最大数值保存在Number.MAX_VALUE中。
2. Arithmetic in JavaScript does not raise errors in cases of overflow, underflow, or division by zero. 如果某次计算的结果超出了范围，则会被转换为相应的-Infinity或Infinity。该数值将无法参与下一次的计算。  
3. 想要确定一个数值是不是有穷的，可以使用Number.isFinite()。正负无穷以及NaN都会返回false。
4. 在ES6之前，isFinite是全局对象的方法，且如果参数不是数字，会先调用Number()函数转换为数字再判断；ES6将其定义在Number上，且不再转型。
5. 但是，即使是在Number.MIN_VALUE和Number.MAX_VALUE之间的数，也不能保证都能精确计算。JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。同时，ES6的 Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。
一个注意点是，你不应当只检验运算结果是否在这个范围内，而应当检验参与运算的每一个数。
6. 访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY可以得到负和正Infinity的值。
7. Underflow occurs when the result of a numeric operation is closer to zero than the smallest representable number. In this case, JavaScript returns 0. If underflow occurs from a negative number, JavaScript returns a special value known as “negative zero.” This value is almost completely indistinguishable from regular zero and JavaScript programmers rarely need to detect it.
8. Division by zero is not an error in JavaScript: it simply returns infinity or negative infinity. There is one exception, however: zero divided by zero does not have a welldefined value, and the result of this operation is the special not-a-number value, printed as NaN.

#### 六. NaN
1.NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。
2. 任何涉及NaN的操作都会返回NaN。
3. NaN does not compare equal to any other value, including itself. 但通过ES6的 Object.is()方法是，它和它本身相等。
4. isNaN()
（1）ES6之前这是全局方法，且如果参数不是数字，会先调用Number()函数转换为数字再判断；ES6将其作为Number的方法，且不再转型。
（2）在接收到一个值后，会尝试转换为数值(ES6之前)，任何不能被转换为数值的值都会导致这个函数返回true：
```
alert(isNaN(NaN));      //true
alert(Number.isNaN(10));       //false
alert(isNaN("10"));     //false (可以被转换为数值10)
alert( isNaN(undefined) ); // true Number(undefined) 返回NaN
alert( Number.isNaN(undefined) ); // false 不调用Number()转型
alert(isNaN("blue"));   //true  (Number("blue") return NaN)
alert(Number.isNaN("blue"));   //false  (不发生转型,"blue"显然不是NaN)
alert(isNaN(true));     //false (可以被转换为数值1）
```
可以看出来，因为ES6之前isNaN会转型，所以不能直接用它判断一个值本身是不是NaN，必须再同时确定该值 typeof 为 number才行



#### 七. 数值转换
1.有三个函数可以把非数值转换为数值：Number()、Number.parseInt()和Number.parseFloat()。
2.第一个函数，即转型函数可以用于任何数据类型。另外两个函数则专门用于把字符串转换成数值。实测后两个也可以转换首项是数字或数字字符串的数组，但不能转换布尔值。
3.这三个函数对于同样的输入会有返回不同的结果。
4.转换极大或极小的整数时会返回个位数，因为使用了e底数的计数法。
5.一元加操作符的操作与Number()函数相同

6.Number()函数的转换规则如下：
     （1）如果是Boolean值，true和false将分别被转换为1和0.
     （2）如果是数字值，只是简单的传入和返回。（其他进制会转换到10进制）
     （3）如果是null值，返回0。
     （4）如果是undefined，返回NaN。
     （5）如果是字符串，遵循下列规则：
          ①如果字符串只包含数字（包括前面带正负号的情况），则将其转换为十进制数值。（”011“会被转换为11）
          ②如果字符串中包含有效的浮点格式，则将其转换为对应的浮点数值。（同样忽略前导零）
          ③如果字符串包含有效的十六进制格式，则将其转换为相同大小的十进制整数值。
          ④如果字符串是空的，则将其转换为0。parseInt和parseFloat在这种情况下返回NaN
          ⑤如果字符串包含除上述格式以外的字符，则将其转换为NaN。
    （6）如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符 串值。不懂
7.Number.parseInt()。
（1）ES6之前这是全局方法，ES6将其作为Number的方法
     （2）parseInt()会忽略字符串前面的空格，直到找到第一个非空格字符
     （3）如果第一个非空格字符不是数字字符或者正负号，会返回NaN
     （4）如果第一个字符是数字字符或者正负号，会继续解析下一个，直到解析完后续的所有数字字符或者是遇到一个非数字字符。
     （5）parseInt()可以默认可以识别八进制和十六进制，并解析返回为十进制。ECMAScript 5已经不能识别八进制。但通过传参可以
            识别任何进制，而且不用写成八进制或十六进制格式。和toString()效果相反
     （6）建议无论在什么情况下都明确指定基数。
8. Number.parseFloat()
（1）ES6之前这是全局方法，ES6将其作为Number的方法
（2）如果字符串包含的是一个可解析为整数的数（没有小数点或者小数点后全是0），将会返回整数。
（3）看起来，不管是ES6的还是之前的该方法，解析精度都比较有限
var parsedFloat1 = parseFloat( '1.337000012397766117451156851189711');
console.log( parsedFloat1 );// 1.3370000123977661
var parsedFloat2 = Number.parseFloat( '1.337000012397766117451156851189711');
console.log( parsedFloat2 );// 1.337000012397761



## String类型
#### 一.概述
1. JavaScript uses the UTF-16 encoding of the Unicode character set, and JavaScript strings are sequences of unsigned 16-bit values. 
2. The most commonly used Unicode characters (those from the “basic multilingual plane”) have codepoints that fit in 16 bits and can be represented by a single element of a string. Unicode characters whose
codepoints do not fit in 16 bits are encoded following the rules of UTF-16 as a sequence (known as a “surrogate pair”) of two 16-bit values. This means that a JavaScript string of length 2 (two 16-bit values) might represent only a single Unicode character
```
let p = "π"; // π is 1 character with 16-bit codepoint 0x03c0
let e = "𝑒"; // 𝑒 is 1 character with 17-bit codepoint 0x1d452
p.length // => 1: p consists of 1 16-bit element
e.length // => 2: UTF-16 encoding of 𝑒 is 2 16-bit values: "\ud835\udc52"
```
3. The length of a string is the number of 16-bit values it contains, not the number of characters.
4. The various string-manipulation methods defined by JavaScript operate on 16-bit values, not on characters. They do not treat surrogate pairs specially, perform no normalization of the string, and do not even ensure that a string is well-formed UTF-16.
5. ECMAScript strings are immutable. 
    * You can access the text at any index of a string, but JavaScript provides no way to alter the text of an existing string. 
    ```
    let str = 'abc';
    console.log( str[1] ); // 'b'
    str[1] = 'd'; // TypeError: Cannot assign to read only property '1' of string 'abc'
    ```
    * 要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串充填该变量。
    ```
    let lang = "Java";
    lang = lang + "Script";
    ```
    实现这个操作的过程如下：首先创建一个能容纳10个字符的新字符串，然后在这个字符串中填充"Java"和"Script"，最后一步是销毁原来的字符串"Java"和字符串"Script"。   

    * All string methods that appear to return a modified string are, in fact, returning a new string value. 

6. In ECMAScript 5, you can break a string literal across multiple lines by ending each line but the last with a backslash (\\).
```
let str = "hello \
world \
!";
console.log( str ); // hello world !
```
7. ==不懂ES6对字符unicode表示法的扩展== http://es6.ruanyifeng.com/#docs/string


#### 二. Escape Sequences in String Literals
String数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。这些字符字面量如下表所示：

字面量 | 含义
---|---
\n | 换行
\t | 制表
\b | 退格
\r | 回车
\f | 进纸
\\\ | 斜杠
\\' | 单引号（'），在用单引号表示的字符串中使用。例如：'He said, \'hey.\''
\\" | 双引号（"），在用双引号表示的字符串中使用。例如："He said, \"hey.\""
\xnn | 以十六进制代码nn表示的一个字符（其中n为0～F）。例如，\x41表示"A"
\unnnn | 以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\u03a3表示希腊字符Σ


这些字符字面量可以出现在字符串中的任意位置，而且也将被作为一个字符来解析，如下面的例子所示：
var text = "This is the letter sigma: \u03a3.";
因为会被作为一个字符解析，所以其length值也是1


#### 三. ES6 模板字符串：直接在字符串里使用变量或者函数
使用反引号（波浪键）的字符串，内部可直接使用变量及其他代码，语法类似如下两个
```
console.log( `hello world` );             // hello world

let name = 22;
console.log( `Hello ${name}` );           // hello 22

let yourName = ()=>11+22;
console.log( `你好，${ yourName()}` );    // 你好，33
```
1. 如果在模板字符串中需要使用反引号，则要转义
2. 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。
3. 如果大括号中的值不是字符串，将按照一般的规则转为字符串。
4. 模板字符串可以嵌套

==模板编译 不懂  
标签模板 不懂  
http://es6.ruanyifeng.com/#docs/string==



#### 




## Object类型
#### 一.概述
1. 在ECMAScript中，如果不给构造函数传递参数，则可以省略后面的括号，但并不推荐。
2. 在ECMAScript中，Object类型是所有它的实例的基础。换句话说，Object类型所具有的任何属性同样存在与更具体的对象中。

#### 二. references
* object values are references, and we say that objects are compared by reference: two object values are the same if and only if they refer to the same underlying object.
```
var a = []; // The variable a refers to an empty array.
var b = a; // Now b refers to the same array.
b[0] = 1; // Mutate the array referred to by variable b.
a[0] // => 1: the change is also visible through variable a.
a === b // => true: a and b refer to the same object, so they are equal.
```
Assigning an object (or array) to a variable simply assigns the reference: it does not create a new copy of the object. 
* If you want to make a new copy of an object or array, you must explicitly copy the properties of the object or the elements of the array.
```
var a = ['a','b','c']; // An array we want to copy
var b = []; // A distinct array we'll copy into
for(var i = 0; i < a.length; i++) // For each index of a[]
{ 
    b[i] = a[i]; // Copy an element of a into b
}
```
* if we want to compare two distinct objects or arrays, we must compare their
properties or elements. 
```
function equalArrays(a,b) 
{
    if (a.length != b.length)
    {
        return false; // Different-size arrays not equal
    }
    for(var i = 0; i < a.length; i++) // Loop through all elements
    {
        if (a[i] !== b[i]) 
        {
            return false; // If any differ, arrays not equal
        }
    }
    return true; // Otherwise they are equal
}
```

#### 三. Object的每个实例都具有下列属性和方法：
* constructor：保存着用于创建当前对象的函数。
* hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名必须以字符串形式指定。
* isPrototypeOf(object)：用于检查传入的对象是否是另一个对象的原型。
* ==propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用for-in语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串的形式指定。不懂==
* toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
    1. The default ```toLocaleString()``` method defined by Object doesn’t do any localization itself: it simply calls ```toString()``` and returns that value.
    2. The Date and Number classes define customized versions of ```toLocaleString()``` that attempt to format numbers, dates, and times according to local conventions.
    3. Array defines a ```toLocaleString()``` method that works like ```toString()``` except that it formats array elements by calling their ```toLocaleString()``` methods instead of their ```toString()``` methods, and then it concatenates the resulting strings using a locale-specific (and implementation-defined) separator string
* toString():返回对象的字符串表示。
    ```
    let obj = {x:3, y:5};
    console.log( obj.toString() ); // "[object Object]"
    
    let arr = [1, 2, 3];
    console.log( arr.toString() ); // "1,2,3"
    
    function fn(){return;}
    console.log( fn.toString() ); // "function fn(){return;}"
    
    let date = new Date();
    console.log( date.toString() ); // "Mon Sep 19 2016 13:02:58 GMT+0800 (China Standard Time)"
    
    let re = /\d+/g;
    console.log( re.toString() ); // "/\d+/g"
    ```
* valueOf()：返回对象的原始值
JavaScript calls this method automatically if an object is used in a context where a primitive value is required. 

对象类型 | 返回值
---|---
boolean | 原始值
string | 原始值
number	| 原始值
object | 该对象原始值（欲将object对象转换为可见的字符串形式，需要用JSON.stringify()方法）
function | 原始值。返回的类型还是函数
array | 原始值。返回的类型还是数组
date | 至今毫秒数的number类型
regexp | 本身
undefined | 报错
null | 报错

#### 四. ECMA-262以外的对象
从技术角度讲，ECMA-262中对象的行为不一定适用于JavaScript中的其他对象。浏览器环境中的对象，比如BOM和DOM中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。ECMA-262不负责定义宿主对象，因此宿主对象可能会也可能不会继承Object。


#### 五. 属性单独使用的时候必须要加引号
```
var obj = {
  a:1,
  b:2
};
delete obj.a;        //这里不加引号不会报错
alert("a" in obj);  //这里不加引号就会报错
```

#### 六.遍历对象的属性和值
```
for(var i in obj)
{
    console.log(i +":"+ obj[i]);
}
```

## Global Object
* When the JavaScript interpreter starts (or whenever a web browser loads a new page), it creates a new global object and gives it an initial set of properties that define:
    * global properties like undefined, Infinity, and NaN
    * global functions like isNaN(), parseInt() , and eval().
    * constructor functions like Date(), RegExp(), String(), Object(), and Array()
    * global objects like Math and JSON
* The initial properties of the global object are not reserved words, but they deserve to be treated as if they are.
* In top-level code you can use the JavaScript keyword this to refer to the global object.In client-side JavaScript, the Window object serves as the global object for all JavaScript code contained in the browser window it represents. This global Window object has a self-referential window property that can be used instead of this to refer to the global object. 
```
console.log( window === this );  // true
console.log( this.window === this ); // true
```

## Wrapper Objects
* Three special reference types are designed to ease interaction with primitive values: the Boolean type, the Number type, and the String type. These types can act like the other reference types, but they also have a special behavior related to their primitive-type equivalents.  
 Every time a primitive value is read, an object of the corresponding primitive wrapper type is created behind the scenes, allowing access to any number of methods for manipulating the
data. 
    ```
    var s1 = "some text";
    var s2 = s1.substring(2);
    ```
    In this code, s1 is a variable containing a string, which is a primitive value. On the next line, the substring() method is called on s1 and stored in s2. Primitive values aren’t objects, so logically they shouldn’t have methods, though this still works as you would expect. In truth, there is a lot going on behind the scenes to allow this seamless operation. When s1 is accessed in the second line, it is being accessed in read mode, which is to say that its value is being read from memory. Any time a string value is accessed in read mode, the following three steps occur:
    1. Create an instance of the String type.
    2. Call the specified method on the instance.
    3. Destroy the instance.  
    
    You can think of these three steps as they’re used in the following three lines of ECMAScript code:
    ```
    var s1 = new String("some text");
    var s2 = s1.sunstring(2);
    s1 = null;
    ```
---
* The major difference between reference types and primitive wrapper types is the lifetime of the object. When you instantiate a reference type using the new operator, it stays in memory until it goes out of scope, whereas automatically created primitive wrapper objects exist for only one line of code before they are destroyed. This means that properties and methods cannot be added at runtime.
    ```
    var s1 = "some text";
    s1.color = "red";
    alert(s1.color);          //undefined
    ```
    The String object that was created in the second line is destroyed by the time the third line is executed. The third line creates its own String object, which doesn’t have the color property.

---
* It is possible to create the primitive wrapper objects explicitly using the Boolean, Number, and String constructors. 
1. 这种情况下的基本包装类型的生存期和引用类型一样。
2. This should be done only when absolutely necessary, because it is often
confusing for developers as to whether they are dealing with a primitive or reference value.
3. Calling typeof on an instance of a primitive wrapper type returns “object”, and all primitive wrapper objects convert to the Boolean value true.也就是说空字符串、0、false的基本包装类型也是true。
5.The Object constructor also acts as a factory method and is capable of returning an instance of a primitive wrapper based on the type of value passed into the constructor. 
```
var obj = new Object("some text");
alert(obj instanceof String);     //true
```
5. The == equality operator treats a value and its wrapper object as equal, but you can distinguish them with the === strict equality operator.
```
let str = "hello",
    oStr = new String( "hello" );
console.log( str == oStr );  // true
console.log( str === oStr ); // true
```