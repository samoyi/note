# 数据上传

* 通过报头的`Transfer-Encoding`或`Content-Length`即可判断请求中是否带有内容
    ```js
    function hasBody(req) {
        return 'transfer-encoding' in req.headers || 'content-length' in req.headers;
    }
    ```
* 在 HTTP_Parser 解析报头结束后，报文内容部分会通过`data`事件触发，我们只需以流的方式
处理即可:
    ```js
    function (req, res) {
        if (hasBody(req)) {
            let buffers = [];
            req.on('data', (chunk)=>{
                buffers.push(chunk);
            });
            req.on('end', ()=>{
                // 将接收到的 Buffer 对象转换为字符串，挂置到 req 上
                req.rawBody = Buffer.concat(buffers).toString();
                handle(req, res);
            });
        }
        else {
            handle(req, res);
        }
    }
    ```


## 处理表单上传
```html
<form action="http://localhost:3000" method="POST">
    <input type="text" name="name" value="33" />
    <input type="text" name="age" value="22" />
    <input type="submit" />
</form>
```
```js
function handleFormUpload(req, res) {
    if (req.headers['content-type'] === 'application/x-www-form-urlencoded') {

        let queryData = '';

        req.on('data', (data)=>{
            queryData += data;

            if (queryData.length > 1e6) { // 1MB
                queryData = "";
                // Payload Too Large
                res.writeHead(413, {'Content-Type': 'text/plain'}).end();
                req.connection.destroy(); // 不懂细节
            }
        });

        req.on('end', ()=>{
            req.post = querystring.parse(queryData);
            res.end(`Name: ${req.post.name}, age: ${req.post.age}`);
        });
    }
}

const server = http.createServer(function(req, res){
    if (req.url !== '/favicon.ico'){
        res.setHeader('Content-Type', 'text/plain;charset=utf-8');

        handleFormUpload(req, res);
    }
});
server.listen(3000);
```


## 其他格式
### 判断数据类型
文件类型依据`Content-Type`中的值决定，但`Content-Type`可能还包含字符集信息，做判断时
要删除可能的字符集信息：
```js
function mime(req) {
    let str = req.headers['content-type'] || '';
    return str.split(';')[0];
}
```

### 处理 JSON 内容的提交
```js
function handleJSONUpload(req, res) {
    if (mime(req) === 'application/json') {
        try {
            req.body = JSON.parse(req.rawBody);
        }
        catch (e) {
            res.writeHead(400);
            res.end('Invalid JSON');
            return;
        }
    }
    todo(req, res);
}
```

### 处理 XML 内容的提交
社区有支持 XML 到 JSON 转换的库，如 `xml2js`


## 附件上传
1. 附件上传有两种形式：表单或 AJAX。通过 PHP 或 Node.js 的第三方模块可以方便的处理上传
的文件，但这里实现一下原生 Node.js 接受上传文件。
2. 通过表单上传文件时，接受到的文件 buffer 对象内部除了文件本身的数据，还会包括文件名、
MIME type 等信息，需要提取其中的文件本身数据（顺便也可以获取文件名）。
3. 而通过 AJAX 上传的文件，接受到的文件 buffer 对象只包含文件本身的数据，可以直接保存
为文件。虽然内部不包含文件类型信息，但可以通过内部的
[magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files)
判断文件类型，`file-type`模块就是根据这个原理实现的。但是好像没办法获取文件名，所以需要
生成临时文件名。
4. 因此，处理表单上传时，需要了解文件的二进制格式（应该是二进制格式吧），才能从中提取文
件名和文件数据。下面 JS 中注释的那一行，会显示出文件的二进制格式。可以看出来第二行包含了
文件名。例如一个 PNG 文件，前5行是这样的：
```
------WebKitFormBoundaryMuAMhOqT7J5l6fix
Content-Disposition: form-data; name="file"; filename="5df1;6r.png"
Content-Type: image/png

    PNG
```
而通过 AJAX 上传的，第一行就是：
```
	PNG
```

### 表单上传时的 HTML 代码
```html
<!-- 通过表单上传要在 form 里写明三个属性 -->
<form action="http://localhost:3000" method="POST" enctype="multipart/form-data">
    <input type="file" name="file" />
    <input type="submit" />
</form>
```

### AJAX 上传时的前端代码
通过 AJAX 上传的话其实只需要一个`input`就行了

```html
<input type="file" id="file" name="file" />
```
```js
document.querySelector('#file').addEventListener("change", function() {
    let file = this.files[0];
    let xhr = new XMLHttpRequest();
    xhr.open('POST', 'http://localhost:3000');
    xhr.setRequestHeader('Content-Type', 'multipart/form-data');
    xhr.send(file);
}, false);
```

### 统一的后端处理函数
```js
function mime(req) {
    let str = req.headers['content-type'] || '';
    return str.split(';')[0];
}

function handleFileUpload(req, res, byAJAX = false){
    if (mime(req) === 'multipart/form-data'){
        let chunks = [];
        let bufferConcat;
        let size = 0;

        req.on('data', (chunk)=>{
            chunks.push(chunk);
            size += chunk.length;
        });

        let newArray=[];
        req.on('end',function(){
            bufferConcat = Buffer.concat(chunks, size);

            if (!byAJAX){
                // 选出二进制格式里所有的行尾
                for (let a = 0; a < bufferConcat.length; a++){
                    if (bufferConcat[a].toString() === '13' && bufferConcat[a+1].toString() === '10'){
                        newArray.push(a);
                    }
                }

                // 用来匹配第二行的文件名
                const matchFileName = /; filename="([^"]+)"$/;

                // 第二行及文件名
                const sNameLine = bufferConcat.slice(newArray[0], newArray[1]).toString();
                const filename = sNameLine.match(matchFileName)[1];

                // 文件本身的数据。这个加 2 可能是从上一行的行末移动到这一行的行首
                const data = bufferConcat.slice(newArray[3] + 2, newArray[newArray.length - 2]);

                fs.writeFileSync('./' + filename , data);
            }
            else {
                let suffix = getType(); // 这是个虚拟的函数，会生成后缀名字符串
                let tempName = generateTempName(); // 也是个虚拟的函数，生成临时文件名

                fs.writeFileSync(`./${tempName}.${suffix}` , bufferConcat);
            }

            res.end();

            // 下面这个可以看出来二进制格式
            // fs.writeFileSync('imageInfo.md', bufferConcat.toString('ascii'));
        });
    }
}

const server = http.createServer(function(req, res){
    if (req.url !== '/favicon.ico'){
        res.setHeader('Content-Type', 'text/plain;charset=utf-8');

        handleFileUpload(req, res); // 通过表单上传
        // handleFileUpload(req, res, true); // 通过 AJAX 上传
    }
});
server.listen(3000);
```

* 不懂，怎么同时上传多个文件
* 不懂，为什么文件`input`必须要有`name`属性


## 数据上传与安全
### 内存限制
同时提交的数据量过大，会耗尽服务器内存。两种解决方案：
* 限制上传内容的大小，一旦超过限制，停止接收数据，并响应`413`状态码。
* 通过流式解析，将数据流导向到磁盘中，Node 只保留文件路径等小数据。

### 防御 CSRF
参考`Theories\Security\Web\Attacks\CSRF.md`



## References
* [《深入浅出Node.js》](https://book.douban.com/subject/25768396/)
