# 数据上传

* 通过报头的`Transfer-Encoding`或`Content-Length`即可判断请求中是否带有内容
    ```js
    function hasBody(req) {
        return 'transfer-encoding' in req.headers || 'content-length' in req.headers;
    }
    ```
* 在 HTTP_Parser 解析报头结束后，报文内容部分会通过`data`事件触发，我们只需以流的方式
处理即可:
    ```js
    function (req, res) {
        if (hasBody(req)) {
            let buffers = [];
            req.on('data', (chunk)=>{
                buffers.push(chunk);
            });
            req.on('end', ()=>{
                // 将接收到的 Buffer 对象转换为字符串，挂置到 req 上
                req.rawBody = Buffer.concat(buffers).toString();
                handle(req, res);
            });
        }
        else {
            handle(req, res);
        }
    }
    ```


## 处理表单上传
```html
<form action="http://localhost:3000" method="POST">
    <input type="text" name="name" value="33" />
    <input type="text" name="age" value="22" />
    <input type="submit" />
</form>
```
```js
function handleFormUpload(req, res) {
    if (req.headers['content-type'] === 'application/x-www-form-urlencoded') {

        let queryData = '';

        req.on('data', (data)=>{
            queryData += data;

            if (queryData.length > 1e6) { // 1MB
                queryData = "";
                // Payload Too Large
                res.writeHead(413, {'Content-Type': 'text/plain'}).end();
                req.connection.destroy(); // 不懂细节
            }
        });

        req.on('end', ()=>{
            req.post = querystring.parse(queryData);
            res.end(`Name: ${req.post.name}, age: ${req.post.age}`);
        });
    }
}

const server = http.createServer(function(req, res){
    if (req.url !== '/favicon.ico'){
        res.setHeader('Content-Type', 'text/plain;charset=utf-8');

        handleFormUpload(req, res);
    }
});
server.listen(3000);
```


## 其他格式
### 判断数据类型
文件类型依据`Content-Type`中的值决定，但`Content-Type`可能还包含字符集信息，做判断时
要删除可能的字符集信息：
```js
function mime(req) {
    let str = req.headers['content-type'] || '';
    return str.split(';')[0];
}
```

### 处理 JSON 内容的提交
```js
function handleJSONUpload(req, res) {
    if (mime(req) === 'application/json') {
        try {
            req.body = JSON.parse(req.rawBody);
        }
        catch (e) {
            res.writeHead(400);
            res.end('Invalid JSON');
            return;
        }
    }
    todo(req, res);
}
```

### 处理 XML 内容的提交
社区有支持 XML 到 JSON 转换的库，如 `xml2js`


## 附件上传
```html
<form action="http://localhost:3000" method="POST" enctype="multipart/form-data">
    <input type="file" name="file" />
    <input type="submit" />
</form>
```
```js
function mime(req) {
    let str = req.headers['content-type'] || '';
    return str.split(';')[0];
}

function handleFileUpload(req, res){
    if (mime(req) === 'multipart/form-data'){
        let chunks = [];
        let bufferConcat;
        let size = 0;

        req.on('data', (chunk)=>{
            chunks.push(chunk);
            size += chunk.length;
        });

        let newArray=[];
        req.on('end',function(){
            bufferConcat = Buffer.concat(chunks, size);

            // 下面会在文件的二进制格式（应该是二进制格式吧）中提取文件名和文件数据
            // 下面注释的那一行，会显示出文件的二进制格式。可以看出来第二行包含了文件名

            // 选出所有的行尾
            for (let a = 0; a < bufferConcat.length; a++){
                if (bufferConcat[a].toString() === '13'
                    && bufferConcat[a+1].toString() === '10'){
                    newArray.push(a);
                }
            }

            // 用来匹配第二行的文件名
            const matchFileName = /; filename="([^"]+)"$/;
            // 第二行及文件名
            const sNameLine = bufferConcat.slice(newArray[0], newArray[1]).toString();
            const filename = sNameLine.match(matchFileName)[1];

            // 不懂。数据为什么是从如下的位置截取
            const data = bufferConcat.slice(newArray[3] + 2, newArray[newArray.length - 2]);

            fs.writeFileSync('./'+filename , data);
            res.end();

            // fs.writeFileSync('imageInfo.md', bufferConcat.toString('ascii'));
        });
    }
}
```


## 数据上传与安全
### 内存限制
同时提交的数据量过大，会耗尽服务器内存。两种解决方案：
* 限制上传内容的大小，一旦超过限制，停止接收数据，并响应`413`状态码。
* 通过流式解析，将数据流导向到磁盘中，Node 只保留文件路径等小数据。

### 防御 CSRF
参考`Theories\Security\Web\Attacks\CSRF.md`



## References
* [《深入浅出Node.js》](https://book.douban.com/subject/25768396/)
