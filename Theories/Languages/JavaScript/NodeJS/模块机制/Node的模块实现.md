# Node的模块实现

Node 在实现中并非完全按照规范实现，而是对模块规范进行了一定的取舍，同时也增加了少许自身
需要的特性。


## Node 引用模块的基本步骤
1. 路径分析：根据`require()`的参数标识符来分析路径
2. 文件定位
3. 编译执行


## Node 模块类型
在Node中，模块分为两类：一类是 Node 提供的模块，称为核心模块；另一类是用户编写的模块，称
为文件模块。
* 核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进程启动时，
部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤
可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。
* 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模
块慢。


## 优先从缓存加载
1. 与前端浏览器会缓存静态脚本文件以提高性能一样，Node 对引入过的模块都会进行缓存，以减
少二次引入时的开销。
2. 不同的地方在于，浏览器仅仅缓存文件，而 Node 缓存的是编译和执行之后的对象。
3. 不论是核心模块还是文件模块，`require()`方法对相同模块的二次加载都一律采用缓存优先的
方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。


## 路径分析
### 标识符类型
因为标识符有几种形式，对于不同的标识符，模块的查找和定位有不同程度上的差异
* 核心模块标识符，如`http`、`fs`等
* 以`.`或`..`开头的文件模块相对路径标识符
* 以`/`开头的文件模块绝对路径标识符
* 非路径形式的文件模块，如自定义的`connect`模块，存放在`node_modules`目录下

#### 核心模块
* 核心模块的优先级仅次于缓存加载，它在 Node 的源代码编译过程中已经编译为二进制代码，其
加载过程最快。
* 如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个
`http`用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。

#### 路径形式的文件模块
* 相对路径或绝对路径会被转换为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓
存中，以使二次加载时更快。
* 这里说到的“真实路径”，可能是指比如 windows 系统中绝对路径`/a.js`会被转换为`D:\a.js`
* 由于文件模块给 Node 指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速
度慢于核心模块。

#### 自定义文件模块
* 存在于`node_modules`目录下的模块。
* 它是一种特殊的文件模块，可能是一个文件或者包的形式。
* 这类模块的查找是最费时的，也是所有方式中最慢的一种。

##### 模块路径
1. 模块路径是 Node 在定位自定义文件模块的具体文件时制定的查找策略，具体表现为一个路径组
成的数组。
2. 在任何路径下的一个模块中，查看`module.paths`，就可以看到该路径下查找模块时的模块路
径。例如：
    ```js
    // 当前文件路径为 D:\\WWW\\test\\test.js
    console.log(module.paths);
    // [
    //     'D:\\WWW\\test\\node_modules',
    //     'D:\\WWW\\node_modules',
    //     'D:\\node_modules'
    // ]
    ```
3. 在查找自定义模块时，例如`require('vue')`，就会按照当前目录的模块路径数组里的路径来
依次查找。


## 文件定位
### 文件扩展名分析
1. `require()`在分析标识符的过程中，会出现标识符既不是中不包含文件扩展名的情况。CommonJS 模
块规范也允许在标识符中不包含文件扩展名，这种情况下，Node 会按`.js`、`.json`、`.node`的
次序补足扩展名，依次尝试。
2. 这里说的依次尝试应该是先用`.js`后缀把所有可能的目录都查找完，如果没有再换`.json`后
缀；而不是在每个可能的目录都依次尝试这三个扩展名。否则下面也就不会说在加载`.json`和
`.node`文件时加上扩展名会速度更快了。
3. 在尝试的过程中，需要调用`fs`模块同步阻塞式地判断文件是否存在。因为 Node 是单线程的，
所以这里是一个会引起性能问题的地方。
4. 小诀窍是：如果是`.node`和`.json`文件，在传递给`require()`的标识符中带上扩展名，会
加快一点速度。另一个诀窍是：同步配合缓存，可以大幅度缓解 Node 单线程中阻塞式调用的缺陷。
不懂什么是同步配合缓存。

### 模块查找
当 Node 遇到`require(X)`时，按下面的顺序处理
#### 如果`X`核心模块：
直接返回该模块

#### 如果`X`是路径：
1. 解析真实地址
2. 首先认为它是文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行：
    ```
    X
    X.js
    X.json
    X.node
    ```
    注意这里先查找`X`再查找`X.js`，是因为 Node 无法判断`X`带不带扩展名。例如一个文件是
    `a.js.js`，在你`require('a.js')`时，Node 如果断定标识符是带扩展名的那显然就错了。
3. 如果第二步没有找到，则将`X`当成目录，查找`X/package.json`文件，解析`package.json`
文件并读取`main`字段，查找`main`字段指定的文件。
4. 如果`X/package.json`不存在或者其中`main`指定的文件不存在，则一次查找
    ```
    X/index.js
    X/index.json
    X/index.node
    ```


## References
* [《深入浅出Node.js》 2.2章节](https://book.douban.com/subject/25768396/)
