# ByteCode


<!-- TOC -->

- [ByteCode](#bytecode)
    - [设计目的](#设计目的)
        - [关键细节](#关键细节)
    - [实现原理](#实现原理)
    - [抽象本质](#抽象本质)
    - [设计思想](#设计思想)
    - [早期 V8 不使用字节码](#早期-v8-不使用字节码)
    - [机器代码缓存](#机器代码缓存)
    - [节码降低了内存占用](#节码降低了内存占用)
    - [字节码提升代码启动速度](#字节码提升代码启动速度)
    - [字节码降低代码的复杂度](#字节码降低代码的复杂度)
    - [References](#references)

<!-- /TOC -->


## 设计目的
1. 直接从 AST 编译为机器码的两个缺点：
    * 编译过程太慢，程序不能即使启动；
    * 机器码很大，缓存的话很占空间。
2. 加入字节码解决上面两个缺点：
    * 字节码可以快速生成，然后快速的解释执行；
    * 字节码相比机器码小得多，缓存占用空间少。

### 关键细节


## 实现原理


## 抽象本质


## 设计思想


## 早期 V8 不使用字节码
1. 我们知道 V8 在执行一段 JavaScript 代码之前，需要将其编译为字节码，然后再解释执行字节码或者将字节码编译为二进制代码然后再执行。
2. 所谓字节码，是指编译过程中的中间代码，你可以把字节码看成是机器代码的抽象。在 V8 中，字节码有两个作用：
    * 第一个是解释器可以直接解释执行字节码；
    * 第二个是优化编译器可以将字节码编译为二进制代码，然后再执行二进制机器代码。
3. 虽然目前的架构使用了字节码，不过早期的 V8 并不是这样设计的。那时候 V8 团队认为这种 “先生成字节码再执行字节码” 的方式，多了个中间环节，多出来的中间环节会牺牲代码的执行速度。于是在早期，V8 团队采取了非常激进的策略，直接将 JavaScript 代码编译成机器代码。其执行流程如下图所示
    <img src="./images/03.jpg" width="600" style="display: block; margin: 5px 0 10px;" />
4. 观察上面的执行流程图，我们可以发现，早期的 V8 也使用了两个编译器：
    * 第一个是 **基线编译器**，它负责将 JavaScript 代码编译为 **没有优化过** 的机器代码。
    * 第二个是 **优化编译器**，它负责将一些热点代码（执行频繁的代码）**优化** 为执行效率更高的机器代码。
5. 了解这两个编译器之后，接下来我们再来看看早期的 V8 是怎么执行一段 JavaScript 代码的：
    1. 首先，V8 会将一段 JavaScript 代码转换为抽象语法树 (AST)。
    2. 接下来基线编译器会将抽象语法树编译为未优化过的机器代码，然后 V8 直接执行这些未优化过的机器代码。
    3. 在执行未优化的二进制代码过程中，如果 V8 检测到某段代码重复执行的概率过高，那么 V8 会将该段代码标记为 HOT，标记为 HOT 的代码会被优化编译器优化成执行效率高的二进制代码，然后就执行该段优化过的二进制代码。
    4. 不过如果优化过的二进制代码并不能满足当前代码的执行，这也就意味着优化失败，V8 则会执行反优化操作。
6. 以上就是早期的 V8 执行一段 JavaScript 代码的流程，不过最近发布的 V8 已经抛弃了直接将 JavaScript 代码编译为二进制代码的方式，也抛弃了这两个编译器，进而使用了 “字节码 + 解释器 + 编译器” 的方式。
7. 早期的 V8 之所以抛弃中间形式的代码，直接将 JavaScript 代码编译成机器代码，是因为机器代码的执行性能非常高效。但是最新版本却朝着执行性能相反的方向进化，那么这是出于什么原因呢？


## 机器代码缓存
1. 要回答上面的问题，先要了解 V8 对二进制机器代码的缓存机制。
2. JavaScript 代码在浏览器中被执行的时候，需要先被 V8 编译，早期的 V8 会将 JavaScript 编译成未经优化的二进制机器代码，然后再执行这些未优化的二进制代码。通常情况下，编译占用了很大一部分时间，几乎和执行所消耗的时间一样。
3. 如果在浏览器中再次打开相同的页面，当页面中的 JavaScript 文件没有被修改，那么再次编译之后的二进制代码也会保持不变， 这意味着编译这一步白白浪费了 CPU 资源，因为之前已经编译过一次了。
4. 这就是 Chrome 浏览器引入二进制代码缓存的原因，通过把二进制代码保存在内存中来消除冗余的编译，重用它们完成后续的调用，这样就省去了再次编译的时间。
5. V8 使用两种代码缓存策略来缓存生成的代码：
    * V8 第一次执行一段代码时，会编译源 JavaScript 代码，并将编译后的二进制代码缓存在内存中，我们把这种方式称为 **内存缓存**（in-memory cache)。这样当再次执行到这段代码时，V8 就可以通过 JavaScript 源文件的字符串在内存中查找对应的编译后的二进制代码。如果内存缓存中存在这段代码所对应的二进制代码，那么就直接执行编译好的二进制代码。
    * V8 除了采用将代码缓存在内存中策略之外，还会将代码缓存到硬盘上，这样即便关闭了浏览器，下次重新打开浏览器再次执行相同代码时，也可以直接重复使用编译好的二进制代码。
6. 实践表明，在浏览器中采用了二进制代码缓存的方式，初始加载时分析和编译的时间缩短了 20%～40%。


## 节码降低了内存占用
1. 采用缓存是一种以空间换时间的策略。我们知道 Chrome 的多进程架构已经非常吃内存了，而 Chrome 中每个页面进程都运行了一份 V8 实例，V8 在执行 JavaScript 代码的过程中，会将 JavaScript 代码转换为未经优化的二进制代码。而二进制代码所占的空间要比源代码大得多，所以这种机制会占用很多内存。
2. 不过还好，因为 V8 使用惰性编译，不会编译函数内部的代码，所以也只会缓存顶层代码的二进制代码。这样缓存的二进制代码就不会占用很多内存了。
3. 但问题是，因为 JavaScript 之前没有块级作用域，所以典型的模块实现都是通过 IIFE。这就导致了大量的模块都不会被提前编译和缓存，而在一个大型工程中，这种模块是大量存在的。
4. 通过引入字节码，可以平衡这个矛盾，在不占用很多内存的情况下提供更多的缓存。
5. 这是因为，虽然字节码占用的空间要比源代码多，但是相比于机器码还是少得多。所以，我们如果采用缓存字节码的策略，就能用更少的内存缓存更多的内容，就能缓存所有代码的字节码，而不是仅仅缓存顶层代码的字节码。
6. 当然，因为字节码的执行速度要比机器码慢一些，所以会牺牲一些执行效率。不过使用字节码还可以提升启动速度，并且降低代码复杂度，所以整体来说要优于没有字节码的方案。


## 字节码提升代码启动速度
1. 生成机器代码比生成字节码需要花费更久的时间，但是直接执行机器代码却比解释执行字节码要更高效，所以在快速启动 JavaScript 代码与花费更多时间获得最优运行性能的代码之间，我们需要找到一个平衡点。
2. 字节码的生成速度要更快，但是解释器执行字节码的速度要比直接执行机器码慢。不过编译器可以基于字节码进行优化，对其中的热代码生成高效的机器码。
3. V8 的解释器 Ignition（就原始字节码执行速度而言）是所有引擎中最快的解释器。V8 的优化编译器名为 TurboFan，最终由它生成高度优化的机器码。


## 字节码降低代码的复杂度
1. 早期的 V8 代码，无论是基线编译器还是优化编译器，它们都是基于 AST 抽象语法树来将代码转换为机器码的。
2. 我们知道，不同架构的机器码是不一样的，而市面上存在不同架构的处理器又是非常之多，这意味着基线编译器和优化编译器要针对不同的体系的 CPU 编写不同的代码，这会大大增加代码量。
3. 引入了字节码后，因为字节码的执行过程和 CPU 执行二进制代码的过程类似，将字节码转换为不同架构的二进制代码的工作量也会大大降低，这就降低了转换底层代码的工作量。


## References
* [图解 Google V8](https://time.geekbang.org/column/intro/296)
