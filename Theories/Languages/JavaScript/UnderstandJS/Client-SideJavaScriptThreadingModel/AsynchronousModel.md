# Asynchronous Model

<!-- TOC -->

- [Asynchronous Model](#asynchronous-model)
    - [从 ES6 开始](#从-es6-开始)
    - [并行线程（Parallel Threading）](#并行线程parallel-threading)
        - [完整运行（Run-to-Completion）下的不确定性](#完整运行run-to-completion下的不确定性)
    - [References](#references)

<!-- /TOC -->


## 从 ES6 开始
1. 尽管你显然能够编写异步 JavaScript 代码，但直到最近 ES6，JavaScript 才真正内建有直接的异步概念。
2. ES6 从本质上改变了在哪里管理事件循环，精确指定了事件循环的工作细节，这意味着在技术上将其纳入了 JavaScript 引擎的势力范围，而不是只由宿主环境来管理。
3. 这个改变的一个主要原因是 ES6 中 Promise 的引入，因为这项技术要求对事件循环队列的调度运行能够直接进行精细控制，而不再是 `setTimeout` 那样不确定的异步控制。


## 并行线程（Parallel Threading）
1. 术语 **异步**（async）和 **并行**（parallel）常常被混为一谈，但实际上它们的意义完全不同：异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情。
2. 并行计算最常见的工具就是 **进程**（process）和 **线程**（thread）。进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。
3. 与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。
4. 并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的。前者的粒度要小得多。例如下面代码
    ```js
    var a = 20;

    function foo() {
        a = a + 1;
    }

    function bar() {
        a = a * 2;
    }

    // ajax(..)是某个库中提供的某个Ajax函数
    ajax( "http://some.url.1", foo );
    ajax( "http://some.url.2", bar );
    ```
5. 在 JS，这样的代码逻辑，最终 `a` 的值只可能有两种结果：先执行 `foo` 的话结果是 42，先执行 `bar` 的话结果是 41。`foo` 和 `bar` 一定在在事件队列中按照两种顺序之一顺序执行，不可能同时执行。
6. 但是如果存在并行执行，结果就更加的不确定。考虑 `foo` 和 `bar` 中代码运行的线程分别执行的是以下两段伪代码任务：
    * 线程 1，执行 `foo()`（`X` 和 `Y` 是临时内存地址）：
        ```
        foo():
            a. 把 a 的值加载到 X
            b. 把 1 保存在 Y
            c. 执行 X 加 Y，结果保存在 X
            d. 把 X 的值保存在 a
        ```
    * 线程 2，执行 `bar()`（`X` 和 `Y` 是临时内存地址）：
        ```
        bar():
            a. 把 a 的值加载到 X
            b. 把 2 保存在 Y
            c. 执行 X 乘 Y，结果保存在 X
            d. 把 X 的值保存在 a
        ```            
7. 现在，假设两个线程并行执行，它们在临时步骤中使用了共享的内存地址 `X` 和 `Y`（TODO，为什么是共享的？为什么两个线程把 a 加载到同一个内存地址）。如果按照以下步骤执行
    ```
    1a  (把 a 的值加载到 X            ==> 20)
    2a  (把 a 的值加载到 X            ==> 20)
    1b  (把 1 保存在 Y                ==> 1)
    2b  (把 2 保存在 Y                ==> 2)
    1c  (执行 X 加 Y，结果保存在 X     ==> 22)
    1d  (把 X 的值保存在 a            ==> 22)
    2c  (执行 X 乘 Y，结果保存在 X     ==> 44)
    2d  (把 X 的值保存在 a            ==> 44)
    ```
8. 可以看到，因为并行的粒度要小得多，所以结果会有很多种组合，上面这只是两个线程并行的可能结果中的一种。如果不通过特殊的步骤来防止这种交错运行的话，结果相比于串行会很不确定。
9. JavaScript 从不跨线程共享数据，这意味着不需要考虑这一层次的不确定性。
    
### 完整运行（Run-to-Completion）下的不确定性
1. 由于 JavaScript 的单线程特性，上面的 `foo`（以及 `bar`）中的代码具有 **原子性**（atomic）。也就是说，一旦 `foo` 开始运行，它的所有代码都会在 `bar` 中的任意代码运行之前完成，或者相反。这称为 **完整运行** 特性。
2. 但正如上面看到的，即使 JS 具有完整运行特性，在异步的情况下，结果也会出现不确定性。但是，这种不确定性是在函数（事件）顺序级别上，而不是多线程情况下的语句顺序级别（或者说，表达式运算顺序级别）。换句话说，这一确定性要高于多线程情况。
3. 在 JavaScript 的特性中，这种函数顺序的不确定性就是通常所说的 **竞态条件**（race condition），`foo` 和 `bar` 相互竞争，看谁先运行。具体来说，因为无法可靠预测 `a` 和 `b` 的最终结果，所以才是竞态条件。
4. 不过，ES6 中引入的 generator 打破了 JavaScript 的完整运行特性。


## References
* [你不知道的JavaScript（中卷）](https://book.douban.com/subject/26854244/)
* [图解 Google V8](https://time.geekbang.org/column/intro/296)