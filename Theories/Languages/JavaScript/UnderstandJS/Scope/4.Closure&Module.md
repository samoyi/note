# Closure


<!-- TOC -->

- [Closure](#closure)
    - [闭包是作用域链和词法作用域共同的产物——词法作用域链的产物](#闭包是作用域链和词法作用域共同的产物词法作用域链的产物)
    - [闭包实现原理](#闭包实现原理)
    - [用途](#用途)
        - [因为闭包是词法作用域的产物，所以通过闭包可以从外部访问函数内部的局部变量，实现私有属性](#因为闭包是词法作用域的产物所以通过闭包可以从外部访问函数内部的局部变量实现私有属性)
        - [因为闭包是作用域链的产物，所以同一个外部函数生成的两个闭包，拥有独立的作用域链](#因为闭包是作用域链的产物所以同一个外部函数生成的两个闭包拥有独立的作用域链)
        - [add private propery to object](#add-private-propery-to-object)
    - [Modules](#modules)
        - [Basic Modules](#basic-modules)
        - [Modern Modules](#modern-modules)
            - [思路整理](#思路整理)
        - [Future Modules](#future-modules)
    - [Performance considerations](#performance-considerations)
    - [Reference](#reference)

<!-- /TOC -->


## 闭包是作用域链和词法作用域共同的产物——词法作用域链的产物
1. 严格来说，所有的函数都是闭包，因为它们都有一个词法作用域链。
2. 但是大多时候，函数调用时所处的作用域是和定义它的作用域（词法作用域）相同的，所以看不出有什么奇怪的。但如果调用时所处的作用域和定义时的不一样，那就可能引起误解。
3. 一个典型的例子就是一个函数返回了其内部定义的另一个函数
    ```js
    function outer(){
        let n = 22;
        function inner(){
            console.log( n );
        }
        return inner;
    }

    let inner = outer();

    let n = 33;
    inner(); // 22
    ```
4. 这里可能会误解为打印出的是 33。然而如果是 33 的话，那就不是词法作用域，而是动态作用域了。
5. 作用域链的机制保证了在 `outer` 函数执行完毕后，其内部的变量不会被回收，还能被保存在 `outer` 函数外部的 `inner` 函数调用到。
6. 而词法作用域的机制保证了保存在 `outer` 函数外部的 `inner` 函数在查找变量 `n` 时查找到的是定义时的函数外部而不是调用时的函数外部。


## 闭包实现原理
1. 如果你理解了词法作用域和作用域链，那就很容易理解闭包：函数执行时使用的作用域链并不是它调用位置的作用域链，而是定义时的作用域链，也就是词法作用域链。
2. 但是理解闭包实现细节的时候可能会产生困惑：外层函数返回之后，它里面的局部变量应该就不存在了，为什么被返回的内层函数为什么还能使用这些变量呢？
3. 确实，对于类似 C 语言这种更底层的编程语言，对于基于栈的 CPU 架构中，如果一个函数的局部变量定义在 CPU 的栈中，那么当函数返回时它们的确就不存在了。
4. 但是 JavaScript 的作用域链是对象列表，而不是绑定的栈。
5. 每次调用外层函数的时候，都会为之创建一个新的对象用来保存局部变量，把这个对象添加至作用域链中。当外层函数返回的时候，就从作用域链中将这个绑定变量的对象删除。
6. 这时，如果有内层函数，那内层函数也会引用外层函数的作用域链。但只要它不返回，那么在外层函数返回时，因为没人内层函数，也就没人引用外层函数的变量对象，所以它就会被当做垃圾回收掉。
7. 但如果内层函数被返回了，那外层函数调用后，如果作为返回值的内层函数被某个对象引用，那么整条作用域链就被保留下来了。


## 用途
### 因为闭包是词法作用域的产物，所以通过闭包可以从外部访问函数内部的局部变量，实现私有属性
1. 因为外层函数的变量只能通过内层函数访问，所以可以实现私有
    ```js
    function create_person(){
        let _age = 22; // 私有属性，只能通过 getAge 和 setAge 访问
        return {
            getAge: ()=>_age,
            setAge: (n)=>{
                _age = n;
            }
        };
    }

    let person1 = create_person();
    console.log( person1.getAge() ); // 22
    person1.setAge(33);
    console.log( person1.getAge() ); // 33
    console.log(person1._age); // undefined
    ```
2. 通过 getter 和 setter 函数，可以让形式变得更像是属性访问，而不需要方法调用。getter 和 setter 因为是函数，所以可以实现闭包
    ```js
    function counter(n) { // 参数是外层函数局部变量，所以只能通过 getter 或 setter 访问
        return {
            // Property getter method returns and increments private counter var.
            get count() { return n++; },
            // Property setter doesn't allow the value of n to decrease
            set count(m){
                if (m >= n){
                    n = m;
                }
                else{
                    throw Error("count can only be set to a larger value");
                }
            }
        };
    }

    var c = counter(1000);
    console.log( c.count ); // => 1000
    console.log( c.count ); // => 1001
    c.count = 2000;
    console.log( c.count ); // => 2000
    c.count = 1987; // => Error!
    ```

### 因为闭包是作用域链的产物，所以同一个外部函数生成的两个闭包，拥有独立的作用域链
1. 外部函数定义的时候有一个词法作用域链，之后外部函数每次调用，都会创建一个新的变量对象，拼接到之前的作用域链尾部，作为调用时查询变量用的作用域链
    ```js
    function create_person(){
        let _age = 22;
        return {
            getAge: ()=>_age,
            setAge: (n)=>{
                _age = n;
            }
        };
    }

    let person1 = create_person();
    let person2 = create_person();
    console.log( person1.getAge() ); // 22
    console.log( person2.getAge() ); // 22
    person1.setAge(33);
    console.log( person1.getAge() ); // 33
    console.log( person2.getAge() ); // 22
    ```
2. 两次调用 `create_person` 都分别独立的创建了各自的变量对象，所以里面的 `_age` 都是独立的。
3. 这实际上就是 JavaScript 的模块原理。


### add private propery to object
```js
function addPrivateProperty(o, name, predicate){
	var value; // This is the property value
	// The getter method simply returns the value.
	o["get" + name] = function (){
		return value;
	};
	// The setter method stores the value or throws an exception if
	// the predicate rejects the value.
	o["set" + name] = function (v){
		if( predicate && !predicate(v) ){
			throw Error("set" + name + ": invalid value " + v);
		}
		else{
			value = v;
		}
	};
}

// The following code demonstrates the addPrivateProperty() method.
var o = {}; // Here is an empty object
// Add property accessor methods getName and setName()
// Ensure that only string values are allowed
addPrivateProperty(o, "Name", function (x){
	return typeof x == "string";
});
o.setName("Frank"); // Set the property value
console.log( o.getName() ); // Get the property value
o.setName(0); // Try to set a value of the wrong type
```


## Modules
### Basic Modules
```js
function Person(init_age){
    let _age = init_age;
    return {
        getAge: ()=>_age,
        setAge: (n)=>{
            _age = n;
        }
    };
}

let person1 = Person(22);
let person2 = Person(22);
console.log( person1.getAge() ); // 22
console.log( person2.getAge() ); // 22
person1.setAge(33);
console.log( person1.getAge() ); // 33
console.log( person2.getAge() ); // 22
```

### Modern Modules
1. Create a Module Manager (like NPM)
```js
//  MM —— Module Manager
/*
 * MM manages all modules defined by MM.define()
 *
 * When define a module, it can inject other modules as dependencies, by accepts
 * an module names array as the second argument of MM.define()
 *
 * Use MM.require() gets the defined module by MM
 */
let MM = (function() {
    // 模块管理器的所有模块
    // 每个模块是一个带着依赖的对象
	let modules = {};

    // 定义一个模块
    // name 是模块名称字符串
    // deps 是依赖的模块的模块名字符串组成的数组，这些依赖将作为参数传入新模块的构造函
    //      数中
    // impl 是一个工厂函数，返回作为模块的对象
	function define(name, deps, impl) {
        // 根据依赖的模块的名称，找出对应的模块
		for (let i=0; i<deps.length; i++) {
			deps[i] = modules[deps[i]];
		}

        // 书上是直接调用工厂函数并传入依赖，但这样的问题是所有对该模块的引用都是同一个
        // 对象，同一个作用域，在模块被复用时，内部方法使用的是同样的变量
        // modules[name] = impl(...deps);
        // 按照这种写法会出现下面的情况
        // const foo1 = MM.require('foo');
        // const foo2 = MM.require('foo');
        // console.log(foo1.getAge()); // 22
        // console.log(foo2.getAge()); // 22
        // foo1.setAge(23);
        // console.log(foo1.getAge()); // 23
        // console.log(foo2.getAge()); // 23

        // 这里修改为先不着急调动工厂函数，在加载模块的时候再调用。
        // 所以要先把依赖作为工厂函数的属性保存起来，到时调用的时候作为依赖注入
        impl.deps = deps;
        modules[name] = impl;
	}

    // 加载一个模块
	function require(name) {
        // 按照书上的注册模块直接就调用工厂函数的写法，加载模块时直接返回模块对象就行了
        // return modules[name];

        // 加载模块时再调用工厂函数并注入依赖返回模块
        let module = modules[name];
		return module(...module.deps);
	}

	return {
		define,
		require,
	};
})();
```

2. Define some modules
```js
// define an adder module, contains an add method
// 没有依赖就传空数组
MM.define('adder', [], function(){
    return {
        add(m, n){
            return m + n;
        }
    };
});

// define a divider module, contains a divide method
MM.define('divider', [], function(){
    return {
        divide(m, n){
            return m / n;
        }
    };
});

// define a accumulator module, contains a accumulate method
// 该模块将依赖 adder 模块，所以通过第二个参数注入。同时工厂函数要有相应的参数来接受依赖
MM.define('accumulator', ['adder'], function(adder){
    return {
        accumulate(arr){
            return arr.reduce(function(prev, cur){
                return adder.add(prev, cur)
            });
        }
    }
});

// define a averager module, contains a mean method
MM.define('averager', ['accumulator', 'divider'], function(accumulator, divider){
    return {
        mean(arr){
            return divider.divide(accumulator.accumulate(arr), arr.length);
        }
    };
});
```

3. Use module without worrying dependencies
```js
// As every module has loaded dependent modules automatically, you need not load
//   dependencies yourself
let averager = MM.require('averager');
console.log( averager.mean([3, 6, 9]) ); // 6
```

#### 思路整理
1. 一个模块是一个对象。
2. 注册模块时提供一个工厂函数，及若干个依赖的模块。
3. 将该工厂函数及其依赖保存到模块仓库里。
4. 加载模块时，调用该模块的工厂函数，同时传参依赖。该工厂函数会返回该模块的实际对象。
5. 只有模块的实际对象会被返回，其他的变量都会作为私有属性。只会被模块对象的方法访问到。
6. 由于通过参数传入了依赖的模块，所以被加载模块中的方法可以访问依赖模块中的数据。
7. 如果模块被多次加载，因为每次都会重新调用工厂函数，所以多个模块实例不会冲突。

### Future Modules
1. Function-based modules aren't a statically recognized pattern (something the
compiler knows about), so their API semantics aren't considered until run-time.
That is, you can actually modify a module's API during the run-time.
2. By contrast, ES6 Module APIs are static (the APIs don't change at run-time).
Since the compiler knows that, it can check during compilation that a reference
to a member of an imported module's API actually exists. If the API reference
doesn't exist, the compiler throws an "early" error at compile-time, rather than
waiting for traditional dynamic run-time resolution.
3. ES6 modules do not have an "inline" format, they must be defined in separate
files. The engines have a default "module loader" which synchronously loads a
module file when it's imported.


## Performance considerations
It is unwise to unnecessarily create functions within other functions if
closures are not needed for a particular task, as it will negatively affect
script performance both in terms of processing speed and memory consumption.


## Reference
* [《JavaScript: The Definitive Guide, 6th Edition》 8.6](https://book.douban.com/subject/5303032/)
* [You Don't Know JS: Scope Closure](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch5.md)
