# What is Scope


## 引言
1. 向变量中储存值和访问变量值的能力让程序拥有了 **状态**。
2. 但当我们使用变量的时候，就要考虑两个重要的问题：
	* **变量存储在哪**
	* **怎么找到变量**
3. 因此需要一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。这套规则被称为 **作用域**。
4. 先看下这篇介绍编译流程的 `../Compiler_Theory/Basic_Compilation_Process.md`。


## 设计思想


## 角色
* **Engine**: 从头到尾负责整个 JavaScript 程序的编译及执行过程。
* **Compiler**: 负责语法分析及代码生成等脏活累活。
* **Scope**: 负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。


## 以代码 `var a = 2;` 为例讲解引擎编译代码时的作用域概念
1. 编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。
2. 可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：“为一个变量分配内存，将其命名为a，然后将值2保存进这个变量。”然而，这并不完全正确。
3. 事实上编译器会进行如下处理。
	* 1. 遇到 `var a`，编译器会询问作用域是否已经有一个该名称的变量存在于 **同一个作用域** 的集合中。如果是，编译器会忽略该声明，继续进行编译（`let` 声明的话应该是直接报错把）；否则它会要求作用域在 **当前作用域** 的集合中声明一个新的变量，并命名为 `a`。
	2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 `a = 2` 这个赋值操作。
    3. 引擎运行时会首先询问作用域，在 **当前的作用域** 集合中是否存在一个叫作 `a` 的变量。如果是，引擎就会使用这个变量；如果不是，引擎会继续查找该变量。
    4. 如果引擎最终找到了 `a` 变量，就会将 `2` 赋值给它。否则引擎就会抛出一个异常。
4. 总结一下，变量的赋值操作会执行两个动作：首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。


## LHS 和 RHS
1. 编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 `a` 来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。
2. 在我们的例子中，引擎会为变量 `a` 进行 **LHS** 查询。另外一个查找的类型叫作 **RHS**。“L” 和 “R” 分别代表左侧和右侧，赋值操作的左侧和右侧。换句话说，当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。
3. 讲得更准确一点，RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。
4. 从这个角度说，RHS 并不是真正意义上的 “赋值操作的右侧”，更准确地说是 “非左侧”。你可以将 RHS 理解成 retrieve his source value（取到它的源值），这意味着 “得到某某的值”。
5. 考虑以下代码：
	```js
	console.log( a );
	```
	其中对 `a` 的引用是一个 RHS 引用，因为这里 `a` 并没有赋予任何值。相应地，需要查找并取得 `a` 的值，这样才能将值传递给 `console.log(..)`。
6. 相反的，考虑下面的代码：
	```js
	a = 2;
	```
	这里对 `a` 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为 `= 2` 这个赋值操作找到一个目标。
7. LHS 和 RHS 的含义是 “赋值操作的左侧或右侧” 并不一定意味着就是 “`=` 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最好将其理解为 “赋值操作的目标是谁（LHS）” 以及 “谁是赋值操作的源头（RHS）”。

### 示例
1. 考虑下面的程序，其中既有 LHS 也有 RHS 引用：
	```js
	function foo(a)  {
		console.log( a ); // 2
	}

	foo( 2 );
	```
2. 最后一行 `foo(..)` 函数的调用需要对 `foo` 进行 RHS 引用，意味着 “去找到 `foo` 的值”。
3. 代码中隐式的 `a = 2` 操作可能很容易被你忽略掉。这个操作发生在 2 被当作参数传递给 `foo(..)` 函数时，2 会被分配给参数 `a`。为了给参数 `a`（隐式地）分配值，需要进行一次 `LHS` 查询。
4. 函数体内还有对 `a` 进行的 RHS 引用，并且将得到的值传给了 `console.log(..)`。
5. `console.log(..)` 本身也需要一个引用才能执行，因此会对 `console` 对象进行 RHS 查询，并且检查得到的值中是否有一个叫作 `log` 的方法。

### How engine looks up elements in scope
```js
function foo(a) {
    console.log(a); // 2
}
foo(2);
```
1. 引擎执行到 `foo(2)` 时， 需要对 `foo` 进行 RHS，因此查询作用域。
2. 因为之前编译器在正确的作用域里声明了该函数，因此引擎可以查询到该函数。
3. 引擎执行 `foo`。
4. 执行该函数时因为进行了 `2` 的传参，因此要对形参 `a` 进行 LHS。
5. 因为编译器在正确的作用域里创建了该形参，因此引擎得以找到该变量，成功传参。
6. 函数内部存在一个 `console` 引擎不知道是什么，需要到作用域中进行 RHS 查询。
7. 作用域中存在该内置对象，引擎找到该对象并从中找到了 `log()` 方法。
8. `log()` 有形参 `a`，调用 `log()` 是还要进行一次 RHS 查询 `a`，找到后对其赋值 `2`。

### 另一例
1. 考虑下面代码
    ```js
    function foo(a) {
        var b = a;
        return a + b;
    }

    var c = foo( 2 );
    ```
2. 一共有三次 LHS
    * 对形参 `a` 进行赋值
    * 对变量 `b` 进行赋值
    * 对变量 `c` 进行赋值
3. 一共有四次 RHS
    * 查询函数 `foo`
    * 函数内第一行查询 `a`
    * 函数内第二行查询 `a`
    * 函数内第二行查询 `b`

### 函数声明的情况
1.  你可能会倾向于将函数声明 `function foo(a) {...` 概念化为普通的变量声明和赋值，比如 `var foo`、`foo ＝ function(a) {...`。如果这样理解的话，这个函数声明将需要进行 LHS 查询。
2. 然而还有一个重要的细微差别，编译器可以在代码生成的同时处理声明和值的定义，所以在引擎执行代码时，并不会有线程专门用来将一个函数值“分配给” `foo`。因此，将函数声明理解成前面讨论的 LHS 查询和赋值的形式并不合适。


## Reference
* [You Don't Know JS: Scope & Closures](https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope%20%26%20closures/ch1.md)
* [《你不知道的JavaScript（上卷）》](https://book.douban.com/subject/26351021/)
