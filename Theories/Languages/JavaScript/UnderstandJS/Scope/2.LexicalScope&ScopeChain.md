# Lexical Scope

Lexical Scope is by far the most commonly used by the vast majority of programming languages.


## Lex-time
1. The first traditional phase of a standard language compiler is called lexing (aka, tokenizing).
2. The lexing process examines a string of source code characters and assigns semantic meaning to the tokens as a result of some stateful parsing.


## Lexical Scope
1. Lexical scope is scope that is defined at lexing time.
2. In other words, lexical scope is based on where variables and blocks of scope are authored, by you, at write time, and thus is (mostly) set in stone by the time the lexer processes your code.
3. Lexical scope is "write-time", whereas dynamic scope are runtime. Lexical scope cares where a function was declared, but dynamic scope cares where a function was called from.
4. No matter where a function is invoked from, or even how it is invoked, its lexical scope is only defined by where the function was declared.
    ```js
    let age = 22;

    // 词法阶段，foo 函数是处在全局作用域。全局作用域的 age 是 22
    function foo(){
        console.log(age);
    }

    function bar(){
        let age = 33;
        // 调用阶段，foo 函数处在 bar 作用域，bar 作用域的 age 是 33
        foo();
    }

    bar(); // 22
    ```
    相反的情况：
    ```js
    function foo(){
        console.log(age); // ReferenceError: age is not defined
        // foo 函数内部的作用域链是 foo——window
    }

    function bar(){
        let age = 22;
        foo();
        // 这里 foo 被调用时，作用域链仍然是 foo——window，而不是 foo——bar——window
    }

    bar();
    ```
5. 即使是作为其他对象的方法调用，也依然是使用词法作用域。方法调用只是影响`this`，不影响变量
    ```js
    let age = 22;

    function foo(){
        console.log(age);
    }

    let o = {
        age: 33,
        bar: foo
    };

    o.bar(); // 22
    ```


## Cheating Lexical
* It is considered best practice to treat lexical scope as, in fact, lexical-only, and thus entirely author-time in nature.
* Cheating lexical scope leads to poorer performance.
* use strict mode.

### Do not use these methods
* `eval()` without strict mode
* Use a string argument for `setTimeout()` and `setInterval()`
* Create function with `new Function()`
* `with()`

### Performance
1. JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。
2. 但如果引擎在代码中发现了`eval(..)`或`with`，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道`eval(..)`会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给`wit`h用来创建新词法作用域的对象的内容到底是什么。
3. 最悲观的情况是如果出现了`eval(..)`或`with`，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。如果代码中大量使用`eval(..)`或`with`，那么运行起来一定会变得非常慢。


## Scope Chain
1. If we think of local variables as properties of some kind of implementation-defined object, then there is another way to think about variable scope.
2. Every chunk of JavaScript code (global code or functions) has a scope chain associated with it. When a function is defined, it stores the scope chain then in effect.
3. This scope chain is a list or chain of objects that defines the variables that are “in scope” for that code.
4. When that function is invoked, it creates a new object to store its local variables, and adds that new object to the stored scope chain to create a new, longer, chain that represents the scope for that function invocation.
5. When JavaScript needs to look up the value of a variable `x` (a process called variable resolution), it starts by looking at the first object in the chain.
6. If that object has a property named `x` , the value of that property is used. If the first object does not have a property named `x` , JavaScript continues the search with the next object in the chain. If the second object does not have a property named `x`, the search moves on to the next object, and so on.
7.  If `x` is not a property of any of the objects in the scope chain, then `x` is not in scope for that code, and a `ReferenceError` occurs.
8. This becomes more interesting for nested functions because each time the outer function is called, the inner function is defined again.
9. Since the scope chain differs on each invocation of the outer function, the inner function will be subtly different each time it is defined—the code of the inner function will be identical on each invocation of the outer function, but the scope chain associated with that code will be different.
    ```js
    function foo(){
        let x = 22;

        function setX(newX){
            x = newX;
        }

        function getX(){
            return x;
        }

        return [setX, getX];
    }

    let [setX1, getX1] = foo();
    let [setX2, getX2] = foo();

    setX1(33);
    console.log(getX1()); // 33
    console.log(getX2()); // 22
    ```
10. `foo`被调用了两次，所以就创建了两个变量对象，并由此衍生出两条作用域链。第一个变量对象里面的三个变量和第二个变量对象里的三个变量是没有关系的。所以`setX1(33)`只是给第一个变量对象里的`x`重新赋值了`33`，并不会影响第二个变量对象里的`x`；而`getX2()`读取的也正是第二个变量对象里的`x`。


## Reference
* [《You-Dont-Know-JS》 Lexical Scope](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch2.md)
* [《JavaScript: The Definitive Guide, 6th Edition》  3.10.3](https://book.douban.com/subject/5303032/)
