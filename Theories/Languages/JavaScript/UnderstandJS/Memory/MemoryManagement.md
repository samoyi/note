# Memory Management


<!-- TOC -->

- [Memory Management](#memory-management)
    - [设计目的](#设计目的)
        - [关键细节](#关键细节)
    - [实现原理](#实现原理)
    - [抽象本质](#抽象本质)
    - [设计思想](#设计思想)
    - [JavaScript 内存使用概述](#javascript-内存使用概述)
        - [变量在内存中的存储位置](#变量在内存中的存储位置)
        - [Memory life cycle](#memory-life-cycle)
            - [In high-level languages](#in-high-level-languages)
        - [垃圾的产生](#垃圾的产生)
    - [Garbage collection](#garbage-collection)
        - [引用（References）的概念](#引用references的概念)
        - [引用计数（reference-counting）算法](#引用计数reference-counting算法)
            - [缺陷：循环引用](#缺陷循环引用)
        - [标记-清除（Mark-and-sweep）算法](#标记-清除mark-and-sweep算法)
            - [标记和清除](#标记和清除)
            - [缺陷](#缺陷)
    - [V8 的垃圾回收算法](#v8-的垃圾回收算法)
        - [大致流程](#大致流程)
            - [第一步，通过 GC Root 标记空间中活动对象和非活动对象。](#第一步通过-gc-root-标记空间中活动对象和非活动对象)
            - [第二步，回收非活动对象所占据的内存](#第二步回收非活动对象所占据的内存)
            - [第三步，内存整理](#第三步内存整理)
        - [两个垃圾回收器](#两个垃圾回收器)
        - [副垃圾回收器](#副垃圾回收器)
        - [主垃圾回收器](#主垃圾回收器)
    - [优化回收效率](#优化回收效率)
        - [并行（parallel）和并发 (concurrent)](#并行parallel和并发-concurrent)
        - [并行回收](#并行回收)
        - [增量回收](#增量回收)
            - [三色标记法](#三色标记法)
        - [并发回收](#并发回收)
    - [References](#references)

<!-- /TOC -->


## 设计目的
1. 堆内存的回收不是自动进行的，在 C 这样的低级语言中需要程序员手动进行。
2. 但是这种手动回收很麻烦而且容易漏掉，所以像 JavaScript 这类高级语言实现了内存回收机制来帮助程序员回收堆内存。


### 关键细节
* 怎么识别一段内存已经不需要了？
* 引用计数怎么计数？
* 标记清除怎么标记？
* 既然标记清除是清除不可访问的对象，那不可访问还怎么找到它并清除？
* 内存回收后的收尾工作？


## 实现原理


## 抽象本质


## 设计思想


## JavaScript 内存使用概述
### 变量在内存中的存储位置
* 基本类型的值存储在栈内存中。
* 引用类型的值存储在堆内存中，其在堆内存的中的地址（指针）存储在栈内存中，引用类型变量即为该地址。

### Memory life cycle
Regardless of the programming language, memory life cycle is pretty much always the same:
1. **Allocate memory** — memory is allocated by the operating system which allows your program to use it. In low-level languages (e.g. C) this is an explicit operation that you as a developer should handle. In high-level languages, however, this is taken care of for you.
2. **Use memory** — this is the time when your program actually makes use of the previously allocated memory. Read and write operations are taking place as you’re using the allocated variables in your code.
3. **Release memory** — now is the time to release the entire memory that you don’t need so that it can become free and available again. As with the allocate memory operation, this one is explicit in low-level languages.

#### In high-level languages
1. The second part is explicit in all languages. The first and last parts are explicit in low-level languages, but are mostly implicit in high-level languages like JavaScript.
2. This seemingly “automatical” nature of freeing up resources is a source of confusion and gives JavaScript (and other high-level-language) developers the false impression they can choose not to care about memory management. **This is a big mistake**.

### 垃圾的产生
1. 以下面的代码为例
    ```js
    window.test = new Object()
    window.test.a = new Uint16Array(100)
    ```
2. 当 JavaScript 执行这段代码的时候，会先为 `window` 对象添加一个 `test` 属性，并在堆中创建了一个空对象，`window.test` 属性指向该对象的地址；随后又创建一个大小为 100 的数组，`test.a` 属性指向数组的地址。此时的内存布局图如下所示
    <img src="./images/01.jpg" width="600" style="display: block; margin: 5px 0 10px 0;" />
3. 如果此时，我将另外一个对象赋给了 `a` 属性
    ```js
    window.test.a = new Object()
    ```
    那么此时的内存布局如下所示
    <img src="./images/02.jpg" width="600" style="display: block; margin: 5px 0 10px 0;" />
4. `a` 属性之前是指向堆中数组对象的，现在已经指向了另外一个空对象，那么此时堆中的数组对象就成为了垃圾数据，因为我们无法从一个根对象遍历到这个数组对象。
5. 不过，不用担心这个数组对象会一直占用内存空间，因为垃圾回收器会自动清理。


## Garbage collection
1. 主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。
2. 这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。
3. 因此垃圾回收器只能实现一个有缺陷的解决方案。下面介绍两种常见的的垃圾回收算法以及它们的缺陷。

### 引用（References）的概念
1. 垃圾回收算法主要依赖于 “引用” 的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。
2. 在这里，“对象” 的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。

### 引用计数（reference-counting）算法
1. 这是最初级的垃圾收集算法。此算法把 “对象是否不再需要” 简化定义为 “对象有没有其他对象引用到它”。
2. 每次新创建一个对象并在堆内存中为其分配内存时，会记录该段内存的引用数。之后增加或减少对其引用都会同步的变动记录引用数。
3. 如果发现一段内存的引用数变为零，那就说明没有引用指向该段内存，它将被垃圾回收机制回收
    ```js
    var x = {
        a: {
            b: 2
        }
    };
    // 现在两个对象，第一个对象被 x 引用，第二个对象被 x.a 引用。所以两个对象都不能被回收内存。
    // 为了方便理解，引用关系记为 [ [x], [x.a] ]

    var y = x; // [ [x, y], [x.a, y.a] ]
    // y 也引用了第一个对象，所以 y.a 也会引用第二个对象。
    
    x = 1; // [ [y], [y.a] ]  
    // x 不再引用第一个对象，只剩下 y 独自引用。
    
    var z = y.a; // [ [y], [y.a, z] ]    
    // z 也引用第二个对象。
    
    y = 'mozilla'; // [ [], [z] ] 
    // y 不再引用第一个对象，第一个对象失去所有引用，可以被回收内存。但第二个对象还被 z 引用。
    
    z = null; // [ [], [] ]
    // z 也不再引用第二个对象，第二个对象失去所有引用，可以被回收内存。
    ```

#### 缺陷：循环引用
即使两个对象都没用了，但如果它俩互相引用对方，那就永远不会被回收
```js
function f() {
  var x = {};
  var y = {};
  x.a = y;        // x references y
  y.a = x;        // y references x

  return 'azerty';
}

f(); // 调用结束后 x 和 y 引用的对象其实都没用了
```

### 标记-清除（Mark-and-sweep）算法
1. 该算法将内存视为一个有向 **可达图**（reachability graph），形式如下图所示
    <img src="./images/17.png" width="600" style="display: block; margin: 5px 0 10px 0;" />
2. 该图的节点被分为一组根节点和一组堆节点，每个堆界定对应于堆中的一个已分配块。有向边 $p->q$ 意味着块 $p$ 中的某个位置指向块 $q$ 中的某个位置。
3. 根节点不在堆中的位置，它们包含指向堆中的指针。根节点可以是寄存器、栈里的变量，或者是虚拟内存中读写数据区域内的全局变量。例如 JavaScript 的 `window` 对象就是这样的一个根节点，通过它可以找到在堆中分配的对象。
4. 当存在一条从任意根节点出发并达到 $p$ 的有向路径时，我们说 $p$ 是 **可达的**（reachable）。在任何时刻，不可达节点对应于垃圾，不能被应用再次使用。
5. 每一个堆节点都有一个标记位，标记它是否可达。
6. 垃圾收集器的角色是维护可达图的某种表示，并通过释放不可达节点且将它们返回给空闲链表，来定期的回收它们。

#### 标记和清除
1. 初始状态下，刚分配的堆节点标记位上没有标记。
2. 标记阶段会从所有的根节点开始遍历堆节点，遍历到的每个堆节点后都会在它的标记位上做标记，表示可达。
3. 那些不可达的堆节点则仍然是未标记状态，之后会被回收。
4. 然后进入清除阶段，清除阶段不是从根节点遍历，因为遍历不到。它是遍历整个堆内存，然后查看已分配的内存块：
    * 如果该内存块已被标记，就证明还有用。当然之后可能会没用，所以这里要清除标记，以便下一次再标记。
    * 如果该内存块没有被标记，那就可以对该段内存进行回收。
5. 可以看到，这种垃圾回收算法可以解决引用计数算法遇到的循环引用问题，上图有三个堆节点在循环引用，但它们都是无法到达的。
6. 从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。
7. 

#### 缺陷
1. 上述算法逻辑是最基本的标记-清除算法，有如下主要缺陷：
    * 算法运行时会暂停正常程序运行；
    * 需要扫描整个堆内存区域；
    * 经过多次回收后，堆内存会变得破碎不连续。
2. 在基础算法之上，有不同的优化改进，下面 V8 的实现就是标记-清除算法的改进。


## V8 的垃圾回收算法
### 大致流程
#### 第一步，通过 GC Root 标记空间中活动对象和非活动对象。
1. 目前 V8 采用的 **可访问性**（reachability）算法来判断堆中的对象是否是活动对象。
2. 具体地讲，这个算法是将一些 GC Root 作为初始存活的对象的集合，从 GC Roots 对象出发，遍历 GC Root 中的所有对象：通过 GC Root 遍历到的对象，我们就认为该对象是 **可访问的**（reachable），那么必须保证这些对象应该在内存中保留，我们也称可访问的对象为 **活动对象**；通过 GC Roots 没有遍历到的对象，则是 **不可访问的**（unreachable），那么这些不可访问的对象就可能被回收，我们称不可访问的对象为 **非活动对象**。
3. 在浏览器环境中，GC Root 有很多，通常包括但不限于以下几种：
    * 全局的 window 对象（位于每个 iframe 中）；
    * 文档 DOM 树，由可以通过遍历文档到达的所有原生 DOM 节点组成；
    * 存放栈上变量。

#### 第二步，回收非活动对象所占据的内存
在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。

#### 第三步，内存整理
1. 一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为 **内存碎片**。
2. 当内存中出现了大量的内存碎片之后，如果需要分配较大的连续内存时，就有可能出现内存不足的情况，所以最后一步需要整理这些内存碎片。
3. 但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。

### 两个垃圾回收器
1. 目前 V8 采用了两个垃圾回收器，**主垃圾回收器**（Major GC）和 **副垃圾回收器**（Minor GC (Scavenger)）。
2. V8 之所以使用了两个垃圾回收器，主要是受到了 **代际假设**（The Generational Hypothesis）的影响。代际假设是垃圾回收领域中一个重要的概念，它有以下两个假设：
    * **大部分对象都是 “朝生夕死” 的**。也就是说大部分对象在内存中存活的时间很短，比如函数内部声明的变量，或者块级作用域中的变量，当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问。
    * **不死的对象，会活得更久**。比如全局的 window、DOM、Web API 等对象。
3. 其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的编程语言，如 Java、Python 等。V8 的垃圾回收策略，就是建立在该假设的基础之上的。
4. 如果我们只使用一个垃圾回收器，在优化大多数新对象的同时，就很难优化到那些老对象，因此你需要权衡各种场景，根据对象生存周期的不同，而使用不同的算法，以便达到最好的效果。
5. 所以，在 V8 中，会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象。新生代通常只支持 1～8M 的容量，而老生代支持的容量就大很多了。
6. 对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。副垃圾回收器主要负责新生代的垃圾回收。主垃圾回收器主要负责老生代的垃圾回收。

### 副垃圾回收器
1. 副垃圾回收器主要负责新生代的垃圾回收。通常情况下，大多数小的对象都会被分配到新生代，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。
2. 新生代中的垃圾数据用 **Scavenge 算法** 来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是 **对象区域**（from-space），一半是 **空闲区域**（to-space），如下图所示
    <img src="./images/03.jpg" width="600" style="display: block; margin: 5px 0 10px 0;" />
3. 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段。
4. 副垃圾回收器会把这些存活的对象（非垃圾）复制到空闲区域中，同时它还会把这些对象有序地排列起来。所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了
    <img src="./images/04.jpg" width="600" style="display: block; margin: 5px 0 10px 0;" />
5. 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作。这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。    
    <img src="./images/05.jpg" width="600" style="display: block; margin: 5px 0 10px 0;" />
6. 不过，副垃圾回收器每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域，复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。
7. 同时，副垃圾回收器还会采用 **对象晋升策略**，也就是移动那些经过两次垃圾回收依然还存活的对象到老生代中。

### 主垃圾回收器
1. 主垃圾回收器主要负责老生代中的垃圾回收。除了新生代中晋升的对象，一些大的对象会直接被分配到老生代里。因此，老生代中的对象有两个特点：一个是对象占用空间大；另一个是对象存活时间长。
2. 由于老生代的对象比较大，若要在老生代中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。所以，主垃圾回收器是采用 **标记-清除**（Mark-Sweep）的算法进行垃圾回收的。
3. 首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。
4. 接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，主垃圾回收器会直接将标记为垃圾的数据清理掉
    <img src="./images/06.jpg" width="600" style="display: block; margin: 5px 0 10px 0;" />
5. 对垃圾数据进行标记，然后清除，这就是标记-清除算法。不过对一块内存多次执行标记-清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又引入了另外一种算法——**标记-整理**（Mark-Compact）。
6. 这个算法的标记过程仍然与标记-清除算法里的是一样的，先标记可回收对象，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉这一端之外的内存
    <img src="./images/07.jpg" width="600" style="display: block; margin: 5px 0 10px 0;" />
    

## 优化回收效率
1. 由于 JavaScript 是运行在主线程之上的，因此，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做 **全停顿**（Stop-The-World）。
2. 一次完整的垃圾回收分为标记和清理两个阶段，垃圾数据标记之后，V8 会继续执行清理和整理操作，虽然主垃圾回收器和副垃圾回收器的处理方式稍微有些不同，但它们都是主线程上执行的，执行垃圾回收过程中，会暂停主线程上的其他任务。
3. 为了解决全停顿而造成的用户体验的问题，V8 团队经过了很多年的努力，向现有的垃圾回收器添加并行、并发和增量等垃圾回收技术，并且也已经取得了一些成效。这些技术主要是从两方面来解决垃圾回收效率问题的：
    * 第一，将一个完整的垃圾回收的任务拆分成多个小的任务，这样就消灭了单个长的垃圾回收任务；
    * 第二，将标记对象、移动对象等任务转移到后台线程进行，这会大大减少主线程暂停的时间，改善页面卡顿的问题，让动画、滚动和用户交互更加流畅。
    
### 并行（parallel）和并发 (concurrent) 
1. 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。
2. 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。
3. 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。
4. 并发的关键是你有处理多个任务的能力，不一定要同时；并行的关键是你有同时处理多个任务的能力。
5. 如果某个系统支持两个或者多个动作 **同时存在**，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作 **同时执行**，那么这个系统就是一个并行系统。
6. 并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）cpu 执行，如果可以就说明是并行，而并发是多个线程被（一个）cpu 轮流切换着执行。
7. 怎么感觉下面的并行回收和并发回收和这里的概念不太一样。

### 并行回收
1. 既然执行一次完整的垃圾回收过程比较耗时，那么解决效率问题，第一个思路就是主线程在执行垃圾回收的任务时，引入多个辅助线程来并行处理，因此 V8 团队引入了并行回收机制。
2. 所谓并行回收，是指垃圾回收器在主线程上执行的过程中，还会开启多个协助线程，同时执行同样的回收工作，其工作模式如下图所示
    <img src="./images/08.jpg" width="600" style="display: block; margin: 5px 0 10px 0;" />
3. 采用并行回收时，垃圾回收所消耗的时间，等于总体辅助线程所消耗的时间（辅助线程数量乘以单个线程所消耗的时间，TODO，多个辅助线程不是并行的？），再加上一些同步开销的时间。
4. 这种方式比较简单，因为在执行垃圾标记的过程中，主线程并不会同时执行 JavaScript 代码，因此 JavaScript 代码也不会改变回收的过程。所以我们可以假定内存状态是静态的，因此只要确保同时只有一个协助线程在访问对象就好了。
5. V8 的副垃圾回收器所采用的就是并行策略，它在执行垃圾回收的过程中，启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域。
6. 由于数据的地址发生了改变，所以还需要同步更新引用这些对象的指针。

### 增量回收
1. 虽然并行策略能增加垃圾回收的效率，能够很好地优化副垃圾回收器，但是这仍然是一种全停顿的垃圾回收方式，辅助线程不能独立的进行垃圾回收。
2. 对于老生代存放的大的对象来说，完整执行垃圾回收时间依然会很久。所以在 2011 年，V8 从又引入了增量标记的方式，我们把这种垃圾回收的方式称为 **增量式垃圾回收**。
3. 所谓增量式垃圾回收，是指垃圾收集器将标记工作分解为更小的块，并且穿插在主线程不同的任务之间执行。采用增量垃圾回收时，垃圾回收器没有必要一次执行完整的垃圾回收过程，每次执行的只是整个垃圾回收过程中的一小部分工作，具体流程可以参看下图
    <img src="./images/09.jpg" width="600" style="display: block; margin: 5px 0 10px 0;" />
4. 增量标记的算法比全停顿的算法要稍微复杂，这主要是因为增量回收是 **并发的**（concurrent）。要实现增量执行，需要满足两点要求
    * 垃圾回收可以被随时暂停和重启，暂停时需要保存当时的扫描结果，等下一波垃圾回收来了之后，才能继续启动。
    * 在暂停期间，被标记好的垃圾数据如果被 JavaScript 代码修改了，那么垃圾回收器需要能够正确地处理。
5. 我们先来看看第一点，V8 是如何实现垃圾回收器的暂停和恢复执行的。
6. 这里我们需要知道，在没有采用增量算法之前，V8 使用两种状态来标记数据，比如黑色和白色。在执行一次完整的垃圾回收之前，垃圾回收器会将所有的数据设置为白色，用来表示这些数据还没有被标记；然后垃圾回收器在会从 GC Roots 出发，将所有能访问到的数据标记为黑色。
7. 遍历结束之后，被标记为黑色的数据就是活动数据，那些白色数据就是垃圾数据。如下图所示
    <img src="./images/10.jpg" width="600" style="display: block; margin: 5px 0 10px 0;" />
8. 如果内存中的数据只有两种状态，非黑即白，那么当你暂停了当前的垃圾回收器之后，再次恢复垃圾回收器，那么垃圾回收器就不知道从哪个位置继续开始执行了。比如垃圾回收器执行了一小段增量回收后，被 V8 暂停了，然后主线程执行了一段 JavaScript 代码，然后垃圾回收器又被恢复了，那么恢复时内存状态就如下图所示
    <img src="./images/11.jpg" width="600" style="display: block; margin: 5px 0 10px 0;" />
9. 那么，当垃圾回收器再次被启动的时候，它到底是从 A 节点开始标记，还是从 B 节点开始执行标注过程呢？因为没有其他额外的信息，所以垃圾回收器也不知道该如何处理了。TODO，不能从 A 和 B 分别开始吗？是怕重复标记浪费？

#### 三色标记法
1. 为了解决这个问题，V8 采用了 **三色标记法**，除了黑色和白色，还额外引入了灰色：
    * 黑色表示这个节点被 GC Root 引用到了，而且该节点的子节点都已经标记完成了；
    * 灰色表示这个节点被 GC Root 引用到，但子节点还没被垃圾回收器标记处理，也表明目前正在处理这个节点；
    * 白色表示这个节点没有被访问到，如果在本轮遍历结束时还是白色，那么这块数据就会被收回。
2. 引入灰色标记之后，垃圾回收器就可以依据当前内存中有没有灰色节点，来判断整个标记是否完成。如果没有灰色节点了，就可以进行清理工作了；如果还有灰色标记，当下次恢复垃圾回收器时，便从灰色的节点开始继续执行。
3. 接下来，我们再来分析下，标记好的垃圾数据被 JavaScript 修改了，V8 是如何处理的
    ```js
    window.a = Object()
    window.a.b = Object()
    window.a.b.c=Object()
    ``` 
4. 执行到这段代码时，垃圾回收器标记的结果如下图所示
    <img src="./images/12.jpg" width="600" style="display: block; margin: 5px 0 10px 0;" />
5. 然后又执行了另外一个代码
    ```js
    window.a.b = Object() //d
    ```
6. 执行完之后，垃圾回收器又恢复执行了增量标记过程，由于 `b` 重新指向了 `d`，所以 `b` 和 `c` 对象的连接就断开了。这时候代码的应用如下图所示
    <img src="./images/13.jpg" width="600" style="display: block; margin: 5px 0 10px 0;" />
7. 这就出现了一个问题，当垃圾回收器将某个节点标记成了黑色，然后这个黑色的节点被续上了一个白色节点，那么根据上面的三色标记法规则，垃圾回收器不会再从黑色的 `b` 开始标记了，所以这个实际还在使用的 `d` 就不会被标记为黑色。
8. 为了解决这个问题，增量垃圾回收器添加了一个约束条件：不能让黑色节点指向白色节点。通常我们使用 **写屏障** (Write-barrier) 机制实现这个约束条件。
9. 具体来说，当发生了黑色的节点引用了白色的节点，写屏障机制会强制将被引用的白色节点变成灰色的。这样就保证了黑色节点不能指向白色节点的约束条件。
10. 这个方法也被称为 **强三色不变性**，它保证了垃圾回收器能够正确地回收数据，因为在标记结束时的所有白色对象，对于垃圾回收器来说，都是不可到达的，可以安全释放。
11. 所以在 V8 中，每次执行如 `window.a.b = value` 的写操作之后，V8 会插入写屏障代码，强制将 `value` 这块内存标记为灰色。

### 并发回收
1. 虽然通过三色标记法和写屏障机制可以很好地实现增量垃圾回收，但是由于这些操作都是在主线程上执行的，如果主线程繁忙的时候，增量垃圾回收操作依然会增加降低主线程处理任务的 **吞吐量** (throughput)。
2. 结合并行回收可以将一些任务分配给辅助线程，但是并行回收依然会阻塞主线程，那么，有没有办法在不阻塞主线程的情况下，执行垃圾回收操作呢？这就是这里要说的并发回收机制了。
3. 所谓并发回收，是指主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作。并发标记的流程大致如下图所示
    <img src="./images/14.jpg" width="600" style="display: block; margin: 5px 0 10px 0;" />
4. 并发回收的优势非常明显，主线程不会被挂起，JavaScript 可以自由地执行，在执行的同时，辅助线程可以执行垃圾回收操作。
5. 但是并发回收却是这三种技术中最难的一种，这主要由以下两个原因导致的：
    * 第一，当主线程执行 JavaScript 时，堆中的内容随时都有可能发生变化，从而使得辅助线程之前做的工作完全无效；
    * 第二，主线程和辅助线程极有可能在同一时间去更改同一个对象，这就需要额外实现读写锁的一些功能了。
6. 尽管并行回收要额外解决以上两个问题，但是权衡利弊，并行回收这种方式的效率还是远高于其他方式的。
7. 不过，这三种技术在实际使用中，并不是单独的存在，通常会将其融合在一起使用。V8 的主垃圾回收器就融合了这三种机制，来实现垃圾回收
    <img src="./images/15.jpg" width="600" style="display: block; margin: 5px 0 10px 0;" />
    * 首先主垃圾回收器主要使用并发标记，我们可以看到，在主线程执行 JavaScript 时，辅助线程就开始执行标记操作了，所以说标记是在辅助线程中完成的。
    * 标记完成之后，再执行并行清理操作。主线程在执行清理操作时，多个辅助线程也在执行清理操作。另外，主垃圾回收器还采用了增量标记的方式，清理的任务会穿插在各种 JavaScript 任务之间执行。


## References
* [Memory Management MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)
* [《Professional JavaScript for Web Developers》](https://book.douban.com/subject/7157249/)
* [How JavaScript works: memory management + how to handle 4 common memory leaks](https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec)
* [上面引用的翻译](https://juejin.im/post/5a2559ae6fb9a044fe4634ba)
* [并发与并行的区别是什么？](https://www.zhihu.com/question/33515481)
* [《深入理解计算机系统》](https://book.douban.com/subject/26912767/)
