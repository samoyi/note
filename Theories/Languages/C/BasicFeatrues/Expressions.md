# Expressions


<!-- TOC -->

- [Expressions](#expressions)
    - [算术运算符](#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6)
        - [运算符 / 和运算符 % 的注意点](#%E8%BF%90%E7%AE%97%E7%AC%A6--%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6-%25-%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9)
    - [赋值运算符](#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6)
        - [左值](#%E5%B7%A6%E5%80%BC)
        - [复合赋值](#%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC)
    - [自增运算符和自减运算符](#%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6)
    - [“由实现定义” 的行为](#%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%AE%9A%E4%B9%89-%E7%9A%84%E8%A1%8C%E4%B8%BA)
    - [References](#references)

<!-- /TOC -->


## 算术运算符
1. 当把 `int` 型操作数和 `float` 型操作数混合在一起时，运算结果是 `float` 型的。

### 运算符 `/` 和运算符 `%` 的注意点
* 运算符 `/` 可能产生意外的结果。当两个操作数都是整数时，运算符 `/` 会丢掉分数部分来 “截取” 结果。因此，`1 / 2` 的结果是 `0` 而不是 `0.5`。即使保存为浮点数类型也没用
    ```cpp
    float f = 1/2;
    printf("%f", f); // 0.000000
    ```
    因为等号 `1/2` 的结果已经是 0，再赋值转型也没用了。
* 运算符 `%` 要求操作数是整数。如果两个操作数中有一个不是整数，程序将无法编译通过。
* 把零用作 `/` 或 `%` 的右操作数会导致未定义的行为。
* 当运算符 `/` 和运算符 `%` 用于负操作数时，其结果难以确定。根据 C89 标准，如果两个操作数中有一个为负数，那么除法的结果既可以向上取整也可以向下取整。（例如，-9/7 的结果既可以是 -1 也可以是 -2。）在 C89 中，如果 `i` 或者 `j` 是负数，`i%j` 的符号与具体实现有关。（例如，`-9%7` 的值可能是 -2 或者 5。）但是在 C99 中，除法的结果总是向零截取的，也就是直接删除小数部分（因此 `-9/7` 的结果是 -1），`i%j` 的值的符号与 `i` 的相同（因此 `-9%7` 的值是 -2）。


## 赋值运算符
### 左值
1. 大多数 C 语言运算符允许它们的操作数是变量、常量或者包含其他运算符的表达式。然而，赋值运算符要求它的左操作数必须是 **左值**（lvalue）。
2. 左值表示存储在计算机内存中的对象，而不是常量或计算的结果。变量是左值，而诸如 `10` 或 `2 * i` 这样的表达式则不是左值。

### 复合赋值
1. 在极少数情况下，由于 `v` 自身的副作用，`v+=e` 并不等同于 `v=v+e`。
2. 计算 `v+=e` 只会求一次 `v` 的值，而计算 `v=v+e` 则会求两次 `v` 的值。在后一种情况下，对 `v` 求值可能引起的任何副作用也都会出现两次。不懂怎么出现，在 JS 中使用属性的 getter 来测试，两个方法都是只会调用一次 getter。
3. 另外注意优先级
    ```cpp
    int i, j, k;

    i = 7; j = 8;
    i *= j + 1;
    
    printf("%d", i); // 是 63 而不是 57
    ```
    复合赋值的优先级是和赋值的一样低的
    ```cpp
    int n = 30;
    printf("%d", n / 10 > 0); // 1
    printf("%d", n /= 10 > 0); // 30。优先级比关系运算符还低
    ```

## 自增运算符和自减运算符
1. `++i` 意味着 “立即自增 `i`” ，而 `i++` 则意味着 “现在先用 `i` 的原始值，稍后再自增 `i`”。
2. 这个 “稍后” 有多久呢？C 语言标准没有给出精确的时间，但是可以放心地假设 `i` 将在下一条语句执行前进行自增
    ```cpp
    int i = 1;
    printf("%d ", i++ - 1); // 0
    printf("%d", i);        // 2
    ```


## “由实现定义” 的行为
1. 术语 **由实现定义**（implementation-defined）出现频率很高，因此值得花些时间讨论一下。C 标准故意对 C 语言的部分内容未加指定，并认为其细节可以由 “实现” 来具体定义。
2. 所谓实现是指程序在特定的平台上编译、链接和执行所需要的软件。因此，根据实现的不同，程序的行为可能会稍有差异。
3. 留下语言的一部分内容未加指定看起来可能有点奇怪，甚至很危险，但这正反映了 C 语言的基本理念。C 语言的目标之一是高效，这常常意味着要与硬件行为相匹配。-9 除以 7 时，有些 CPU 产生的结果是 -1，有些为 -2。C89 标准简单地反映了这一现实。
4. 最好避免编写依赖于由实现定义的行为的程序。如果不可能做到，起码要仔细查阅手册——C 标准要求在文档中说明由实现定义的行为。


## References
* [C语言程序设计](https://book.douban.com/subject/4279678/)