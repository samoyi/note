# Selection Statements


<!-- TOC -->

- [Selection Statements](#selection-statements)
    - [逻辑表达式](#逻辑表达式)
        - [关系运算符](#关系运算符)
        - [判等运算符](#判等运算符)
        - [逻辑运算符](#逻辑运算符)
            - [比较结果（注意和 JS 的区别）](#比较结果注意和-js-的区别)
    - [`if` 语句](#if-语句)
        - [“悬空`else`” 的问题](#悬空else-的问题)
        - [条件表达式](#条件表达式)
        - [C99 中的布尔值](#c99-中的布尔值)
    - [`switch` 语句](#switch-语句)
    - [References](#references)

<!-- /TOC -->


## 逻辑表达式
### 关系运算符
1. 而在 C 语言中，诸如 `i < j` 这样的比较运算会产生整数：`0`（假）或 `1`（真）。
2. 关系运算符的优先级低于算术运算符。例如，表达式 `i + j < k - 1` 意思是 `(i + j)<(k - 1)`。
3. 表达式 `i < j < k` 在 C 语言中是合法的，但可能不是你所期望的含意。因为 `<` 运算符是左结合的，所以这个表达式等价于 `(i < j) < k`，表达式首先检测 `i` 是否小于 `j`，然后用比较后产生的结果（`1` 或 `0`）来和 `k` 进行比较。

### 判等运算符
判等运算符的优先级低于关系运算符。例如，表达式 `i < j == j < k` 等价于表达式 `(i < j) == (j < k)`。

### 逻辑运算符
1. 操作数的值经常是 `0` 或 `1`，但这不是必需的。逻辑运算符将任何非零值操作数作为真值来处理，同时将任何零值操作数作为假值来处理。
2. 运算符 `!` 的优先级和一元正负号的优先级相同，运算符 `&&` 和运算符 `||` 的优先级低于关系运算符和判等运算符。例如，表达式 `i < j && k == m` 等价于表达式 `(i < j) && (k == m)`。
3. 运算符 `!` 是右结合的，而运算符 `&&` 和运算符 `||` 都是左结合的。

#### 比较结果（注意和 JS 的区别）
1. 如果 `表达式` 的值为 `0`，那么 `!表达式` 的结果为 `1`；
2. 如果 `表达式1` 和 `表达式2` 的值都是非零值，那么 `表达式1 && 表达式2` 的结果为 `1`；
    ```cpp
    printf("%d", 2 && 3); // 1 不是 3
    ```
3. 如果 `表达式1` 或 `表达式2` 的值中任意一个是（或者两者都是）非零值，那么 `表达式1 || 表达式2` 的结果为 `1`
    ```cpp
    printf("%d", 0 || 3); // 1 不是 3
    ```
4. 在所有其他情况下，这些运算符产生的结果都为 `0`。


## `if` 语句
### “悬空`else`” 的问题
1. 思考下面这个例子：
    ```cpp
    if (y != 0)
        if (x != 0)
            result = x / y;
    else
        printf("Error: y is equal to 0\n");
    ```
2. 上面的 `else` 子句究竟属于哪一个 `if` 语句呢？缩进格式暗示它属于最外层的 `if` 语句。然而，C 语言遵循的规则是 `else` 子句应该属于离它最近的且还未和其他 `else` 匹配的 `if` 语句。
3. 在此例中，`else` 子句实际上属于最内层的 `if` 语句，所以正确的缩进格式应该如下所示：
    ```cpp
    if (y != 0)
        if (x != 0)
            result = x / y;
        else
            printf("Error: y is equal to 0\n");
    ```
4. 为了使 `else` 子句属于外层的 `if` 语句，可以把内层的 `if` 语句用花括号括起来：
    ```cpp
    if (y != 0) {
        if (x != 0)
            result = x / y;
    } else
        printf("Error: y is equal to 0\n");
    ```

### 条件表达式
当 `int` 型和 `float` 型的值混合在一个条件表达式中时，表达式的类型为 `float` 型
```cpp
int i = 2;
float f = 3.14;

printf("%d\n", 1 ? i: f); // 0
printf("%f\n", 1 ? i: f); // 2.000000
printf("%f\n", 0 ? i: f); // 3.140000

return 0;
```

### C99 中的布尔值
1. C99 提供了 `_Bool` （C89 标准指出，以下划线后跟一个大写字母开头的名字是保留字，程序员不应该使用）型，所以在 C 语言的这一版本中，布尔变量可以声明为：
    ```cpp
    _Bool flag;
    ```
2. `_Bool` 是整数类型（更准确地说是无符号整型），所以 `_Bool` 变量实际上就是整型变量；但是和一般的整型不同，`_Bool` 只能赋值为 `0` 或 `1`。一般来说，往 `_Bool` 变量中存储非零值会导致变量赋值为 `1`。
3. 对于 `_Bool` 变量来说，算术运算是合法的（不过不建议这样做），它的值也可以进行打印（显示 `0` 或者 `1`）。
4. 除了 `_Bool` 类型的定义，C99 还提供了一个新的头 `<stdbool.h>`，这使得操作布尔值更加容易。该头提供了 `bool` 宏，用来代表 `_Bool`。如果程序中包含了 `<stdbool.h>`，可以这样写：
    ```cpp
    bool flag;  /* same as _Bool flag; */
    ```
5. `<stdbool.h>` 头还提供了 `true` 和 `false` 两个宏，分别代表 `1` 和 `0`。于是可以写
    ```cpp
    flag = false;
    ...
    flag = true;
    ```


## `switch` 语句
1. `switch` 语句往往比 `if` 语句执行速度快，特别是在有许多情况要判定的时候。
2. `switch` 后边必须跟着由圆括号括起来的整型表达式。C 语言把字符当成整数来处理，因此在 `switch` 语句中可以对字符进行判定。但是，不能用浮点数和字符串。
3. **常量表达式**（constant expression）很像是普通的表达式，只是不能包含变量和函数调用。因此，`5` 是常量表达式，`5 + 10` 也是常量表达式，但 `n + 10` 不是常量表达式（除非 `n` 是表示常量的宏）。分支标号中的常量表达式的值必须是整数（字符也可以）。
4. 每个分支标号的后边可以跟任意数量的语句。不需要用花括号把这些语句括起来。这可是 C 语言中少数几个不需要花括号的地方。
5. C 语言不允许有重复的分支标号，但对分支的顺序没有要求，特别是 `default` 分支不一定要放置在最后。
6. 虽然 `switch` 语句中的最后一个分支不需要 `break` 语句，但通常还是会放一个` break` 语句在那里，以防止将来增加分支数目时出现 “丢失 `break`” 的问题。


## References
* [C语言程序设计](https://book.douban.com/subject/4279678/)