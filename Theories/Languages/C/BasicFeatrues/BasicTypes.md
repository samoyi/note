# Basic Types


<!-- TOC -->

- [Basic Types](#basic-types)
    - [整数类型](#整数类型)
        - [有符号整数和无符号整数](#有符号整数和无符号整数)
        - [6 种整数类型](#6-种整数类型)
            - [C99 中的整数类型](#c99-中的整数类型)
        - [整数常量](#整数常量)
            - [C99 中的整数常量](#c99-中的整数常量)
        - [整数溢出](#整数溢出)
        - [读/写整数](#读写整数)
    - [浮点类型](#浮点类型)
        - [IEEE 浮点标准](#ieee-浮点标准)
        - [浮点常量](#浮点常量)
        - [读/写浮点数](#读写浮点数)
    - [References](#references)

<!-- /TOC -->


## 整数类型
1. C 语言支持两种根本不同的数值类型：**整数类型**（也称整型）和 **浮点类型**（也称浮点型）。整数类型的值是整数，而浮点类型的值则可能还有小数部分。
2. 整数类型又分为两大类：有符号型和无符号型。
3. C 语言的整数类型有不同的尺寸。`int` 类型通常为32位，但在老的 CPU 上可能是 16 位。
4. 有些程序所需的数很大，无法以 `int` 类型存储，所以 C 语言还提供了 **长整型**。某些时候，为了节省空间，我们会指示编译器以比正常存储小的空间来存储一些数，称这样的数称为 **短整型**。

### 有符号整数和无符号整数
1. 有符号整数如果为正数或零，那么最左边的位（符号位）为 0；如果是负数，则符号位为 1。
2. 因此，最大的 16 位整数的二进制表示形式是 `0111111111111111`，对应的值是 $32 767$（即 $2^{15}-1$）；而最大的 32 位整数是 `01111111111111111111111111111111`，对应的数值是 $2 147 483 647$（即 $2^{31}-1$）。
3. 不带符号位的整数（最左边的位是数值的一部分）的整数称为无符号整数。最大的 16 位无符号整数是 $65 535$（即 $2^{16}-1$），而最大的 32 位无符号整数是 $4 294 967 295$（即 $2^{32}-1$）。
4. 默认情况下，C 语言中的整型变量都是有符号的，也就是说最左位保留为符号位。若要告诉编译器变量没有符号位，需要把它声明成 `unsigned` 类型。无符号整数主要用于系统编程和底层与机器相关的应用。

### 6 种整数类型
1. 为了使构造的整数类型正好满足需要，可以指明变量是 `long` 类型或 `short` 类型，`singed` 类型或 `unsigned` 类型，甚至可以把说明符组合起来（如 `long unsigned int`）。然而，实际上只有下列 6 种组合可以产生不同的类型：
    ```cpp
    short int
    unsigned short int

    int
    unsigned int

    long int
    unsigned long int
    ```
2. 其他组合都是上述某种类型的同义词。（例如，除非额外说明，否则所有整数都是有符号的。因此，`long signed int` 和 `long int` 是一样的类型。）
3. 另外，说明符的顺序没什么影响，所以 `unsigned short int` 和 `short unsigned int` 是一样的。
4. C 语言允许通过省略单词 `int` 来缩写整数类型的名字。例如，u`nsigned short int` 可以缩写为 `unsigned short`，而 `long int` 则可以缩写为 `long`。
5. 6 种整数类型的每一种所表示的取值范围都会根据机器的不同而不同，但是有两条所有编译器都必须遵守的原则：
    * C 标准要求 `short int`、`int` 和 `long int` 中的每一种类型都要覆盖一个确定的最小取值范围。
    * 标准要求 `int` 类型不能比 `short int` 类型短，`long int` 类型不能比 `int` 类型短。但是，`short int` 类型的取值范围有可能和 `int` 类型的范围是一样的，`int` 类型的取值范围也可以和 `long int` 的一样。
6. 下面是 16 位机上整数类型通常的取值范围，注意 `short int` 和 `int` 有相同的取值范围 
    <table width="90%" border="1">
        <thead>
            <tr>
                <th>
                    <p>类型</p>
                </th>
                <th>
                    <p>最小值</p>
                </th>
                <th>
                    <p>最大值</p>
                </th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    <p><code>short int</code></p>
                </td>
                <td>
                    <p>-32 768</p>
                </td>
                <td>
                    <p>32 767</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>unsigned short int</code></p>
                </td>
                <td>
                    <p>0</p>
                </td>
                <td>
                    <p>65 535</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>int</code></p>
                </td>
                <td>
                    <p>-32 768</p>
                </td>
                <td>
                    <p>32 767</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>unsigned int</code></p>
                </td>
                <td>
                    <p>0</p>
                </td>
                <td>
                    <p>65 535</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>long int</code></p>
                </td>
                <td>
                    <p>-2 147 483 648</p>
                </td>
                <td>
                    <p>2 147 483 647</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>unsigned long int</code></p>
                </td>
                <td>
                    <p>0</p>
                </td>
                <td>
                    <p>4 294 967 295</p>
                </td>
            </tr>
        </tbody>
    </table>
7. 下面是 32 位机上整数类型通常的取值范围，这里的 `int` 和 `long int` 有着相同的取值范围
    <table width="90%" border="1">
        <thead>
            <tr>
                <th>
                    <p>类型</p>
                </th>
                <th>
                    <p>最小值</p>
                </th>
                <th>
                    <p>最大值</p>
                </th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    <p><code>short int</code></p>
                </td>
                <td>
                    <p>-32 768</p>
                </td>
                <td>
                    <p>32 767</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>unsigned short int</code></p>
                </td>
                <td>
                    <p>0</p>
                </td>
                <td>
                    <p>65 535</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>int</code></p>
                </td>
                <td>
                    <p>-2 147 483 648</p>
                </td>
                <td>
                    <p>2 147 483 647</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>unsigned int</code></p>
                </td>
                <td>
                    <p>0</p>
                </td>
                <td>
                    <p>4 294 967 295</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>long int</code></p>
                </td>
                <td>
                    <p>-2 147 483 648</p>
                </td>
                <td>
                    <p>2 147 483 647</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>unsigned long int</code></p>
                </td>
                <td>
                    <p>0</p>
                </td>
                <td>
                    <p>4 294 967 295</p>
                </td>
            </tr>
        </tbody>
    </table>
8. 再强调一下，上面给出的取值范围不是 C 标准强制的，会随着编译器的不同而不同。对于特定的实现，确定整数类型范围的一种方法是检查 `<limits.h>` 头。该头是标准库的一部分，其中定义了表示每种整数类型的最大值和最小值的宏。

#### C99 中的整数类型
1. C99 提供了两个额外的标准整数类型：`long long int` 和 `unsigned long long int`。增加这两种整数类型有两个原因，一是为了满足日益增长的对超大型整数的需求，二是为了适应支持 64 位运算的新处理器的能力。
2. 这两个 `long long` 类型要求至少 64 位宽，所以 `long long int` 类型值的范围通常为 $-2^{63} （-9 223 372 036 854 775 808）$ 到 $2^{63}-1（9 223 372 036 854 775 807）$，而` unsigned long long int` 类型值的范围通常为0到 $2^{64}-1（18 446 744 073 709 551 615）$。
3. C99 中把 `short int`、`int`、`long int` 和 `long long int` 类型（以及 `signed char` 类型）称为 **标准有符号整型**，而把 `unsigned short int`、`unsigned int`、`unsigned long int` 和 `unsigned long long int` 类型（以及 `unsigned char` 类型和 `_Bool` 类型）称为 **标准无符号整型**。
4. 除了标准的整数类型以外，C99 标准还允许在具体实现时定义 **扩展的整数类型**（包括有符号的和无符号的）。例如，编译器可以提供有符号和无符号的 128 位整数类型。

### 整数常量
1. C 语言允许用十进制、八进制和十六进制形式书写整数常量。
2. 任何时候都可以从一种书写方式切换到另一种书写方式，甚至可以混合使用：`10 + 015 + 0x20` 的值为 `55`（十进制）。
3. 十进制整数常量的类型通常为 `int`，但如果常量的值大得无法存储在 `int` 型中，就用 `long int` 类型。如果出现 `long int` 不够用的罕见情况，编译器会用 `unsigned long int` 作最后的尝试。
4. 确定八进制和十六进制常量的规则略有不同：编译器会依次尝试 `int`、`unsigned int`、`long int` 和 `unsigned long int` 类型，直至找到能表示该常量的类型。
5. 为了强制编译器把常量作为长整数来处理，只需在后边加上一个字母 `L`（或 `l`）：
    ```cpp
    15L  0377L  0x7fffL
    ```
6. 为了指明是无符号常量，可以在常量后边加上字母 `U`（或 `u`）：
    ```cpp
    15U  0377U  0x7fffU
    ```
7. `L `和 `U` 可以结合使用，以表明常量既是长整型又是无符号的：`0xffffffffUL`。（字母 `L`、`U` 的顺序和大小写无所谓。）

#### C99 中的整数常量
1. 在 C99 中，以 `LL` 或 `ll`（两个字母大小写要一致）结尾的整数常量是 `long long int` 型的。如果在 `LL` 或 `ll` 的前面或后面增加字母 `U`（或 `u`），则该整数常量为 `unsigned long long int` 型。
2. C99 确定整数常量类型的规则与 C89 有些不同。对于没有后辍的十进制常量，其类型是 `int`、`long int` 或 `long long int` 中能表示该值的 “最小” 类型。对于八进制或者十六进制常量，可能的类型顺序为 `int`、`unsigned int`、`long int`、`unsigned long int`、 和 `unsigned long long int`。
3. 常量后面的任何后辍都会改变可能类型的列表。例如，以 `U`（或 `u`）结尾的常量类型一定是 `unsigned int`、`unsigned long int` 和 `unsigned long long int` 中的一种，以 `L`（或 `l`）结尾的十进制常量类型一定是 `long int` 或 `long long int` 中的一种。如果常量的数值过大以至不能用标准的整数类型表示，则可以使用扩展的整数类型。

### 整数溢出
1. 对整数执行算术运算时，其结果有可能因为太大而无法表示。整数溢出时的行为要根据操作数是有符号型还是无符号型来确定。
2. 有符号整数运算中发生溢出时，程序的行为是未定义的。未定义行为的结果是不确定的。最可能的情况是，仅仅是运算的结果出错了，但程序也有可能崩溃，或出现其他意想不到的状况。
3. 无符号整数运算过程中发生溢出时，结果是有定义的：正确答案对 $2^n$ 取模，其中 $n$ 是用于存储结果的位数。例如，如果对无符号的 16 位数 $65 535$ 加 $1$，其结果可以保证为 $0$。

### 读/写整数
1. 假设有一个程序因为其中一个 `int` 变量发生了 “溢出” 而无法工作。我们的第一反应是把变量的类型从 `int` 变为 `long int`。但仅仅这样做是不够的，我们还必须检查数据类型的改变对程序其他部分的影响，尤其是需要检查该变量是否用在` printf` 函数或 `scanf` 函数的调用中。如果用了，需要改变调用中的格式串，因为 `%d` 只适用于 `int` 类型。
2. 读写无符号整数时，使用字母 `u`、`o` 或 `x` 代替转换说明中的 `d`。 `u` 说明符，该数将以十进制形式读写，`o` 表示八进制形式，而 `x` 表示十六进制形式
    ```cpp
    unsigned int u;

    scanf("%u", &u);     /* reads  u in base 10 */
    printf("%u", u);     /* writes u in base 10 */
    scanf("%o", &u);     /* reads  u in base  8 */
    printf("%o", u);     /* writes u in base  8 */
    scanf("%x", &u);     /* reads  u in base 16 */
    printf("%x", u);     /* writes u in base 16 */
    ```
3. 读写短整数时，在 `d`、`o`、`u` 或 `x` 前面加上字母 `h`：
    ```cpp
    short s;

    scanf("%hd", &s);
    printf("%hd", s);
    ```
4. 读写长整数时，在 `d`、`o`、`u` 或 `x` 前面加上字母 `l`：
    ```cpp
    long l;

    scanf("%ld",  &l);
    printf("%ld",  l);
    ```
5. 读写长长整数时（仅限 C99），在 `d`、`o`、`u` 或 `x` 前面加上字母 `ll`：
    ```cpp
    long long ll;

    scanf("%lld",  &ll);
    printf("%lld",  ll);
    ```


## 浮点类型
1. 整数类型并不适用于所有应用。有些时候需要变量能存储带小数点的数，或者能存储极大数或极小数。这类数可以用浮点（因小数点是 “浮动的” 而得名）格式进行存储。
2. C 语言提供了 3 种浮点类型，对应三种不同的浮点格式。
    * `float`：单精度浮点数。
    * `double`：双精度浮点数。
    * `long double`：扩展精度浮点数。
3. 当精度要求不严格时（例如，计算带一位小数的温度），`float` 类型是很适合的类型。`double` 提供更高的精度，对绝大多数程序来说都够用了。`long double` 支持极高精度的要求，很少会用到。
4. C 标准没有说明 `float`、`double` 和 `long double` 类型提供的精度到底是多少，因为不同的计算机可以用不同方法存储浮点数。大多数现代计算机都遵循 IEEE 754 标准（即 IEC 60559）的规范。

### IEEE 浮点标准
1. 由 IEEE 开发的 IEEE 标准提供了两种主要的浮点数格式：单精度（32位）和双精度（64位）。
2. 数值以科学计数法的形式存储，每一个数都由三部分组成：符号、指数和小数。指数部分的位数说明了数值的可能大小程度，而小数部分的位数说明了精度。
3. 单精度格式中，指数长度为 8 位，而小数部分占了 23 位。因此，单精度数可以表示的最大值大约是 $3.40×10^{38}$（$2^{2^7}$），其中精度是 6 个十进制数字。TODO， 6 个十进制数字是怎么来的？
4. IEEE 标准还描述了另外两种格式：单扩展精度和双扩展精度。标准没有指明这些格式中的位数，但要求单扩展精度类型至少为 43 位，而双扩展精度类型至少为 79 位。
5. 下表给出了根据 IEEE 标准实现时浮点类型的特征。（表中给出了规范化的最小正值，非规范化的数可以更小。）`long double` 类型没有显示在此表中，因为它的长度随着机器的不同而变化，而最常见的大小是 80 位和 128 位

    类型 | 最小正值 | 最大值 | 精度
    --|--|--|--
    `float` | $1.17549×10^{-38}$ | $3.40282×10^{38}$ | 6 个数字
    `double` | $2.22507×10^{-308}$ | $1.79769×10^{308}$ | 15 个数字
    
6. 在不遵循 IEEE 标准的计算机上，上表是无效的。事实上，在一些机器上，`float` 可以有和 `double` 相同的数值集合，或者 `double` 可以有和 `long double` 相同的数值集合。可以在头 `<float.h>`中找到定义浮点类型特征的宏。
7. 在 C99 中，浮点类型分为两种：一种是实浮点类型，包括 `float`、`double` 和 `long double` 类型；另一种是 C99 新增的复数类型，包括 `float _Complex`、`double _Complex` 和 `long double _Complex`。

### 浮点常量
1. 浮点常量可以有许多种书写方式。例如，下面这些常量全都是表示数 57.0 的有效方式：
    ```cpp
    57.0  57.  57.0e0  57E0  5.7e1  5.7e+1  .57e2  570.e-1
    ```
2. 浮点常量必须包含小数点或指数；其中，指数指明了对前面的数进行缩放所需的 10 的幂次。如果有指数，需要在指数数值前放置字母 `E`（或 `e`）。可选符号 `+` 或 `-` 可以出现在字母 `E`（或 `e`）的后边。
3. 默认情况下，浮点常量都以双精度数的形式存储。换句话说，当 C 语言编译器在程序中发现常量 `57.0` 时， 它会安排数据以 `double` 类型变量的格式存储在内存中。这条规则通常不会引发任何问题，因为在需要时 `double` 类型的值可以自动转化为 `float` 类型值。
4. 在某些极个别的情况下，可能会需要强制编译器以 `float` 或 `long double` 格式存储浮点常量。为了表明只需要单精度，可以在常量的末尾处加上字母 `F` 或 `f`（如 `57.0F`）；而为了说明常量必须以 `long double` 格式存储，可以在常量的末尾处加上字母 `L` 或 `l`（如 `57.0L`）。
5. C99 提供了十六进制浮点常量的书写规范。 十六进制浮点常量以 `0x` 或 `0X` 开头（跟十六进制整数常量类似）。这一特性很少用到。

### 读/写浮点数
1. 前面已讨论过，转换说明符 `%e`、`%f` 和 `%g` 用于读写单精度浮点数。读写 `double` 和 `long double` 类型的值所需的转换说明符略有不同。
2. 读取 `double` 类型的值时，在 `e`、`f` 或 `g` 前放置字母 `l`：
    ```cpp
    double d;

    scanf("%lf", &d);
    ```
3. 只能在 `scanf` 函数格式串中使用 `l`，不能在 `printf` 函数格式串中使用。在 `printf` 函数格式串中，转换 `e`、`f` 和 `g` 可以用来写 `float` 类型或 `double` 类型的值。（C99 允许 `printf` 函数调用中使用 `%le`、`%lf` 和 `%lg`，不过字母 `l` 不起作用。）
4. 读写 `long double` 类型的值时，在 `e`、`f` 或 `g` 前放置字母 `L`：
    ```cpp
    long double ld;

    scanf("%Lf", &ld);
    printf("%Lf", ld);
    ```





























































## References
* [C语言程序设计](https://book.douban.com/subject/4279678/)