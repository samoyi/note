# Basic Types


<!-- TOC -->

- [Basic Types](#basic-types)
    - [整数类型](#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B)
        - [有符号整数和无符号整数](#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0)
        - [种整数类型](#%E7%A7%8D%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B)
            - [C99 中的整数类型](#c99-%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B)
        - [整数常量](#%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F)
            - [C99 中的整数常量](#c99-%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F)
        - [整数溢出](#%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA)
        - [读/写整数](#%E8%AF%BB%E5%86%99%E6%95%B4%E6%95%B0)
    - [浮点类型](#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B)
        - [IEEE 浮点标准](#ieee-%E6%B5%AE%E7%82%B9%E6%A0%87%E5%87%86)
        - [浮点常量](#%E6%B5%AE%E7%82%B9%E5%B8%B8%E9%87%8F)
        - [十六进制的浮点常量](#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84%E6%B5%AE%E7%82%B9%E5%B8%B8%E9%87%8F)
        - [读/写浮点数](#%E8%AF%BB%E5%86%99%E6%B5%AE%E7%82%B9%E6%95%B0)
            - [为什么使用 %lf 读取 double 类型的值，而用 %f 进行显示呢？](#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-%25lf-%E8%AF%BB%E5%8F%96-double-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E8%80%8C%E7%94%A8-%25f-%E8%BF%9B%E8%A1%8C%E6%98%BE%E7%A4%BA%E5%91%A2)
    - [字符类型](#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B)
        - [字符操作](#%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C)
        - [有符号字符和无符号字符](#%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%AD%97%E7%AC%A6%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%AD%97%E7%AC%A6)
        - [算术类型](#%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B)
            - [C89 中的算术类型](#c89-%E4%B8%AD%E7%9A%84%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B)
            - [C99 中的算术类型](#c99-%E4%B8%AD%E7%9A%84%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B)
        - [转义序列](#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97)
        - [用 scanf 和 printf 读/写字符](#%E7%94%A8-scanf-%E5%92%8C-printf-%E8%AF%BB%E5%86%99%E5%AD%97%E7%AC%A6)
        - [用 getchar 和 putchar 读/写字符](#%E7%94%A8-getchar-%E5%92%8C-putchar-%E8%AF%BB%E5%86%99%E5%AD%97%E7%AC%A6)
        - [读入字符时对多字符（包括换行符）的处理](#%E8%AF%BB%E5%85%A5%E5%AD%97%E7%AC%A6%E6%97%B6%E5%AF%B9%E5%A4%9A%E5%AD%97%E7%AC%A6%E5%8C%85%E6%8B%AC%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%9A%84%E5%A4%84%E7%90%86)
        - [什么时候需要考虑字符变量是有符号的还是无符号的  不懂](#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%AD%97%E7%AC%A6%E5%8F%98%E9%87%8F%E6%98%AF%E6%9C%89%E7%AC%A6%E5%8F%B7%E7%9A%84%E8%BF%98%E6%98%AF%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%9A%84--%E4%B8%8D%E6%87%82)
    - [类型转换](#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2)
        - [常用算术转换](#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%9C%AF%E8%BD%AC%E6%8D%A2)
            - [转换规则](#%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99)
                - [任一操作数的类型是浮点类型的情况](#%E4%BB%BB%E4%B8%80%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%83%85%E5%86%B5)
                - [两个操作数的类型都不是浮点类型的情况](#%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%83%BD%E4%B8%8D%E6%98%AF%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%83%85%E5%86%B5)
                - [有符号操作数和无符号操作数组合](#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%93%8D%E4%BD%9C%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E5%90%88)
        - [赋值过程中的转换](#%E8%B5%8B%E5%80%BC%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%BD%AC%E6%8D%A2)
        - [C99 中的隐式转换](#c99-%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2)
        - [强制类型转换](#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2)
    - [类型定义](#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89)
        - [类型定义的优点](#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E7%9A%84%E4%BC%98%E7%82%B9)
        - [类型定义和可移植性](#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%92%8C%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7)
            - [缺陷](#%E7%BC%BA%E9%99%B7)
    - [sizeof 运算符](#sizeof-%E8%BF%90%E7%AE%97%E7%AC%A6)
    - [习题](#%E4%B9%A0%E9%A2%98)
    - [References](#references)

<!-- /TOC -->


## 整数类型
1. C 语言支持两种根本不同的数值类型：**整数类型**（也称整型）和 **浮点类型**（也称浮点型）。整数类型的值是整数，而浮点类型的值则可能还有小数部分。
2. 整数类型又分为两大类：有符号型和无符号型。
3. C 语言的整数类型有不同的尺寸。`int` 类型通常为32位，但在老的 CPU 上可能是 16 位。
4. 有些程序所需的数很大，无法以 `int` 类型存储，所以 C 语言还提供了 **长整型**。某些时候，为了节省空间，我们会指示编译器以比正常存储小的空间来存储一些数，称这样的数称为 **短整型**。

### 有符号整数和无符号整数
1. 有符号整数如果为正数或零，那么最左边的位（符号位）为 0；如果是负数，则符号位为 1。
2. 因此，最大的 16 位整数的二进制表示形式是 `0111111111111111`，对应的值是 $32 767$（即 $2^{15}-1$）；而最大的 32 位整数是 `01111111111111111111111111111111`，对应的数值是 $2 147 483 647$（即 $2^{31}-1$）。
3. 不带符号位的整数（最左边的位是数值的一部分）的整数称为无符号整数。最大的 16 位无符号整数是 $65 535$（即 $2^{16}-1$），而最大的 32 位无符号整数是 $4 294 967 295$（即 $2^{32}-1$）。
4. 默认情况下，C 语言中的整型变量都是有符号的，也就是说最左位保留为符号位。若要告诉编译器变量没有符号位，需要把它声明成 `unsigned` 类型。无符号整数主要用于系统编程和底层与机器相关的应用。

### 6 种整数类型
1. 为了使构造的整数类型正好满足需要，可以指明变量是 `long` 类型或 `short` 类型，`singed` 类型或 `unsigned` 类型，甚至可以把说明符组合起来（如 `long unsigned int`）。然而，实际上只有下列 6 种组合可以产生不同的类型：
    ```cpp
    short int
    unsigned short int

    int
    unsigned int

    long int
    unsigned long int
    ```
2. 其他组合都是上述某种类型的同义词。（例如，除非额外说明，否则所有整数都是有符号的。因此，`long signed int` 和 `long int` 是一样的类型。）
3. 另外，说明符的顺序没什么影响，所以 `unsigned short int` 和 `short unsigned int` 是一样的。
4. C 语言允许通过省略单词 `int` 来缩写整数类型的名字。例如，`unsigned short int` 可以缩写为 `unsigned short`，而 `long int` 则可以缩写为 `long`。
5. 6 种整数类型的每一种所表示的取值范围都会根据机器的不同而不同，但是有两条所有编译器都必须遵守的原则：
    * C 标准要求 `short int`、`int` 和 `long int` 中的每一种类型都要覆盖一个确定的最小取值范围。
    * 标准要求 `int` 类型不能比 `short int` 类型短，`long int` 类型不能比 `int` 类型短。但是，`short int` 类型的取值范围有可能和 `int` 类型的范围是一样的，`int` 类型的取值范围也可以和 `long int` 的一样。
6. 下面是 16 位机上整数类型通常的取值范围，注意 `short int` 和 `int` 有相同的取值范围 
    <table width="90%" border="1" style="margin-bottom: 20px;">
        <thead>
            <tr>
                <th>
                    <p>类型</p>
                </th>
                <th>
                    <p>最小值</p>
                </th>
                <th>
                    <p>最大值</p>
                </th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    <p><code>short int</code></p>
                </td>
                <td>
                    <p>-32 768</p>
                </td>
                <td>
                    <p>32 767</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>unsigned short int</code></p>
                </td>
                <td>
                    <p>0</p>
                </td>
                <td>
                    <p>65 535</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>int</code></p>
                </td>
                <td>
                    <p>-32 768</p>
                </td>
                <td>
                    <p>32 767</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>unsigned int</code></p>
                </td>
                <td>
                    <p>0</p>
                </td>
                <td>
                    <p>65 535</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>long int</code></p>
                </td>
                <td>
                    <p>-2 147 483 648</p>
                </td>
                <td>
                    <p>2 147 483 647</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>unsigned long int</code></p>
                </td>
                <td>
                    <p>0</p>
                </td>
                <td>
                    <p>4 294 967 295</p>
                </td>
            </tr>
        </tbody>
    </table>
7. 下面是 32 位机上整数类型通常的取值范围，这里的 `int` 和 `long int` 有着相同的取值范围
    <table width="90%" border="1" style="margin-bottom: 20px;">
        <thead>
            <tr>
                <th>
                    <p>类型</p>
                </th>
                <th>
                    <p>最小值</p>
                </th>
                <th>
                    <p>最大值</p>
                </th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    <p><code>short int</code></p>
                </td>
                <td>
                    <p>-32 768</p>
                </td>
                <td>
                    <p>32 767</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>unsigned short int</code></p>
                </td>
                <td>
                    <p>0</p>
                </td>
                <td>
                    <p>65 535</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>int</code></p>
                </td>
                <td>
                    <p>-2 147 483 648</p>
                </td>
                <td>
                    <p>2 147 483 647</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>unsigned int</code></p>
                </td>
                <td>
                    <p>0</p>
                </td>
                <td>
                    <p>4 294 967 295</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>long int</code></p>
                </td>
                <td>
                    <p>-2 147 483 648</p>
                </td>
                <td>
                    <p>2 147 483 647</p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>unsigned long int</code></p>
                </td>
                <td>
                    <p>0</p>
                </td>
                <td>
                    <p>4 294 967 295</p>
                </td>
            </tr>
        </tbody>
    </table>
8. 注意上面同一种有符号类型的范围中，负数最小值的绝对值比正数最大值的绝对值大一。以 `short int` 类型为例，除了符号位以外，一共有 15 个二进制位。15 位能表示的可能性一共有 32768 种（从 `000000000000000` 到 `111111111111111`）。所以负数的最小值其实是正常的（从 `1000000000000000` 到 `1111111111111111`），但正数的最大值却少了一个。因为零的符号位也是 `0`，占用了一种情况。    
9. 再强调一下，上面给出的取值范围不是 C 标准强制的，会随着编译器的不同而不同。对于特定的实现，确定整数类型范围的一种方法是检查 `<limits.h>` 头。该头是标准库的一部分，其中定义了表示每种整数类型的最大值和最小值的宏。

#### C99 中的整数类型
1. C99 提供了两个额外的标准整数类型：`i":?#%^ int` 和 `unsigned long long int`。增加这两种整数类型有两个原因，一是为了满足日益增长的对超大型整数的需求，二是为了适应支持 64 位运算的新处理器的能力。
2. 这两个 `long long` 类型要求至少 64 位宽，所以 `long long int` 类型值的范围通常为 $-2^{63}$（-9 223 372 036 854 775 808） 到 $2^{63}-1$（9 223 372 036 854 775 807），而 `unsigned long long int` 类型值的范围通常为 $0$ 到 $2^{64}-1$（18 446 744 073 709 551 615）。
3. C99 中把 `short int`、`int`、`long int` 和 `long long int` 类型（以及 `signed char` 类型）称为 **标准有符号整型**，而把 `unsigned short int`、`unsigned int`、`unsigned long int` 和 `unsigned long long int` 类型（以及 `unsigned char` 类型和 `_Bool` 类型）称为 **标准无符号整型**。
4. 除了标准的整数类型以外，C99 标准还允许在具体实现时定义 **扩展的整数类型**（包括有符号的和无符号的）。例如，编译器可以提供有符号和无符号的 128 位整数类型。

### 整数常量
1. C 语言允许用十进制、八进制和十六进制形式书写整数常量。
2. 任何时候都可以从一种书写方式切换到另一种书写方式，甚至可以混合使用：`10 + 015 + 0x20` 的值为 `55`（十进制）。
3. 十进制整数常量的类型通常为 `int`，但如果常量的值大得无法存储在 `int` 型中，就用 `long int` 类型。如果出现 `long int` 不够用的罕见情况，编译器会用 `unsigned long int` 作最后的尝试。
4. 确定八进制和十六进制常量的规则略有不同：编译器会依次尝试 `int`、`unsigned int`、`long int` 和 `unsigned long int` 类型，直至找到能表示该常量的类型。
5. 为了强制编译器把常量作为长整数来处理，只需在后边加上一个字母 `L`（或 `l`）：
    ```cpp
    15L  0377L  0x7fffL
    ```
6. 为了指明是无符号常量，可以在常量后边加上字母 `U`（或 `u`）：
    ```cpp
    15U  0377U  0x7fffU
    ```
7. `L `和 `U` 可以结合使用，以表明常量既是长整型又是无符号的：`0xffffffffUL`。（字母 `L`、`U` 的顺序和大小写无所谓。）

#### C99 中的整数常量
1. 在 C99 中，以 `LL` 或 `ll`（两个字母大小写要一致）结尾的整数常量是 `long long int` 型的。如果在 `LL` 或 `ll` 的前面或后面增加字母 `U`（或 `u`），则该整数常量为 `unsigned long long int` 型。
2. C99 确定整数常量类型的规则与 C89 有些不同。对于没有后辍的十进制常量，其类型是 `int`、`long int` 或 `long long int` 中能表示该值的 “最小” 类型。对于八进制或者十六进制常量，可能的类型顺序为 `int`、`unsigned int`、`long int`、`unsigned long int`、 和 `unsigned long long int`。
3. 常量后面的任何后辍都会改变可能类型的列表。例如，以 `U`（或 `u`）结尾的常量类型一定是 `unsigned int`、`unsigned long int` 和 `unsigned long long int` 中的一种，以 `L`（或 `l`）结尾的十进制常量类型一定是 `long int` 或 `long long int` 中的一种。如果常量的数值过大以至不能用标准的整数类型表示，则可以使用扩展的整数类型。

### 整数溢出
1. 对整数执行算术运算时，其结果有可能因为太大而无法表示。整数溢出时的行为要根据操作数是有符号型还是无符号型来确定。
2. 有符号整数运算中发生溢出时，程序的行为是未定义的。未定义行为的结果是不确定的。最可能的情况是，仅仅是运算的结果出错了，但程序也有可能崩溃，或出现其他意想不到的状况。
3. 无符号整数运算过程中发生溢出时，结果是有定义的：正确答案对 $2^n$ 取模，其中 $n$ 是用于存储结果的位数。例如，如果对无符号的 16 位数 $65 535$ 加 $1$，其结果可以保证为 $0$。

### 读/写整数
1. 假设有一个程序因为其中一个 `int` 变量发生了 “溢出” 而无法工作。我们的第一反应是把变量的类型从 `int` 变为 `long int`。但仅仅这样做是不够的，我们还必须检查数据类型的改变对程序其他部分的影响，尤其是需要检查该变量是否用在` printf` 函数或 `scanf` 函数的调用中。如果用了，需要改变调用中的格式串，因为 `%d` 只适用于 `int` 类型。
2. 读写无符号整数时，使用字母 `u`、`o` 或 `x` 代替转换说明中的 `d`。 `u` 说明符，该数将以十进制形式读写，`o` 表示八进制形式，而 `x` 表示十六进制形式
    ```cpp
    unsigned int u;

    scanf("%u", &u);     /* reads  u in base 10 */
    printf("%u", u);     /* writes u in base 10 */
    scanf("%o", &u);     /* reads  u in base  8 */
    printf("%o", u);     /* writes u in base  8 */
    scanf("%x", &u);     /* reads  u in base 16 */
    printf("%x", u);     /* writes u in base 16 */
    ```
3. 读写短整数时，在 `d`、`o`、`u` 或 `x` 前面加上字母 `h`：
    ```cpp
    short s;

    scanf("%hd", &s);
    printf("%hd", s);
    ```
4. 读写长整数时，在 `d`、`o`、`u` 或 `x` 前面加上字母 `l`：
    ```cpp
    long l;

    scanf("%ld",  &l);
    printf("%ld",  l);
    ```
5. 读写长长整数时（仅限 C99），在 `d`、`o`、`u` 或 `x` 前面加上字母 `ll`：
    ```cpp
    long long ll;

    scanf("%lld",  &ll);
    printf("%lld",  ll);
    ```
6. 对于有符号的八进制和十六进制整数，只要有符号整数的值不是负值，就可以用 `%o` 和 `%x` 显示。这些转换导致 `printf` 函数把有符号整数看成是无符号的；换句话说，`printf` 函数将假设符号位是数的绝对值部分。只要符号位为 `0`，就没有问题。如果符号位为 `1`，那么 `printf` 函数将显示出一个超出预期的大数。
7. 没有直接的方法可以书写负数的八进制或十六进制形式。幸运的是，需要这样做的情况非常少。当然，我们可以判定这个数是否是负数，然后自己显示一个负号：
    ```cpp
    if (i < 0)
        printf("-%x", -i);
    else
        printf("%x", i);
    ```


## 浮点类型
1. 整数类型并不适用于所有应用。有些时候需要变量能存储带小数点的数，或者能存储极大数或极小数。这类数可以用浮点（因小数点是 “浮动的” 而得名）格式进行存储。
2. C 语言提供了 3 种浮点类型，对应三种不同的浮点格式。
    * `float`：单精度浮点数。
    * `double`：双精度浮点数。
    * `long double`：扩展精度浮点数。
3. 当精度要求不严格时（例如，计算带一位小数的温度），`float` 类型是很适合的类型。`double` 提供更高的精度，对绝大多数程序来说都够用了。`long double` 支持极高精度的要求，很少会用到。
4. C 标准没有说明 `float`、`double` 和 `long double` 类型提供的精度到底是多少，因为不同的计算机可以用不同方法存储浮点数。大多数现代计算机都遵循 IEEE 754 标准（即 IEC 60559）的规范。

### IEEE 浮点标准
1. 由 IEEE 开发的 IEEE 标准提供了两种主要的浮点数格式：单精度（32位）和双精度（64位）。
2. 数值以科学计数法的形式存储，每一个数都由三部分组成：符号、指数和小数。指数部分的位数说明了数值的可能大小程度，而小数部分的位数说明了精度。
3. 单精度格式中，指数长度为 8 位，而小数部分占了 23 位。因此，单精度数可以表示的最大值大约是 $3.40×10^{38}$（$2^{2^7}$），其中精度是 6 个十进制数字。TODO， 6 个十进制数字是怎么来的？
4. IEEE 标准还描述了另外两种格式：单扩展精度和双扩展精度。标准没有指明这些格式中的位数，但要求单扩展精度类型至少为 43 位，而双扩展精度类型至少为 79 位。
5. 下表给出了根据 IEEE 标准实现时浮点类型的特征。（表中给出了规范化的最小正值，非规范化的数可以更小。）`long double` 类型没有显示在此表中，因为它的长度随着机器的不同而变化，而最常见的大小是 80 位和 128 位

    类型 | 最小正值 | 最大值 | 精度
    --|--|--|--
    `float` | $1.17549×10^{-38}$ | $3.40282×10^{38}$ | 6 个数字
    `double` | $2.22507×10^{-308}$ | $1.79769×10^{308}$ | 15 个数字
    
6. 在不遵循 IEEE 标准的计算机上，上表是无效的。事实上，在一些机器上，`float` 可以有和 `double` 相同的数值集合，或者 `double` 可以有和 `long double` 相同的数值集合。可以在头 `<float.h>`中找到定义浮点类型特征的宏。
7. 在 C99 中，浮点类型分为两种：一种是实浮点类型，包括 `float`、`double` 和 `long double` 类型；另一种是 C99 新增的复数类型，包括 `float _Complex`、`double _Complex` 和 `long double _Complex`。

### 浮点常量
1. 浮点常量可以有许多种书写方式。例如，下面这些常量全都是表示数 57.0 的有效方式：
    ```cpp
    57.0  57.  57.0e0  57E0  5.7e1  5.7e+1  .57e2  570.e-1
    ```
2. 浮点常量必须包含小数点或指数；其中，指数指明了对前面的数进行缩放所需的 10 的幂次。如果有指数，需要在指数数值前放置字母 `E`（或 `e`）。可选符号 `+` 或 `-` 可以出现在字母 `E`（或 `e`）的后边。
3. 默认情况下，浮点常量都以双精度数的形式存储。换句话说，当 C 语言编译器在程序中发现常量 `57.0` 时， 它会安排数据以 `double` 类型变量的格式存储在内存中。这条规则通常不会引发任何问题，因为在需要时 `double` 类型的值可以自动转化为 `float` 类型值。
4. 在某些极个别的情况下，可能会需要强制编译器以 `float` 或 `long double` 格式存储浮点常量。为了表明只需要单精度，可以在常量的末尾处加上字母 `F` 或 `f`（如 `57.0F`）；而为了说明常量必须以 `long double` 格式存储，可以在常量的末尾处加上字母 `L` 或 `l`（如 `57.0L`）。

### 十六进制的浮点常量
1. C99 提供了十六进制浮点常量的书写规范。这一特性很少用到。
2. 十六进制浮点常量以 `0x` 或 `0X` 开头，且必须包含指数（指数跟在字母 `P` 或 `p` 后面）。
3. 指数可以有符号，常量可以以 `f`、`F`、`l` 或 `L` 结尾。指数以十进制数表示，但代表的是 2 的幂而不是 10 的幂。例如，`0x1.Bp3` 表示 $1.6875\times2^3=13.5$。
4. 十六进制位 `B` 对应的位模式为 1011；由于 `B` 出现在小数点的右边，所以其每一位代表一个 2 的负整数幂，把它们（$2^{-1}+2^{-3}+2^{-4}$）相加得到 0.6875。
5. 十六进制浮点常量主要用于指定精度要求较高的浮点常量（包括 $e$ 和 $π$ 等数学常量）。十进制数具有精确的二进制表示，而十进制常量在转换为二进制时则可能会受到舍入误差的些许影响。十六进制数对于定义极值（例如 `<float.h>` 头中宏的值）常量也是很有用的，这些常量很容易用十六进制表示但难以用十进制表示。

### 读/写浮点数
1. 前面已讨论过，转换说明符 `%e`、`%f` 和 `%g` 用于读写单精度浮点数。读写 `double` 和 `long double` 类型的值所需的转换说明符略有不同。
2. 读取 `double` 类型的值时，在 `e`、`f` 或 `g` 前放置字母 `l`：
    ```cpp
    double d;

    scanf("%lf", &d);
    ```
3. 只能在 `scanf` 函数格式串中使用 `l`，不能在 `printf` 函数格式串中使用。在 `printf` 函数格式串中，转换 `e`、`f` 和 `g` 可以用来写 `float` 类型或 `double` 类型的值。（C99 允许 `printf` 函数调用中使用 `%le`、`%lf` 和 `%lg`，不过字母 `l` 不起作用。）
4. 读写 `long double` 类型的值时，在 `e`、`f` 或 `g` 前放置字母 `L`：
    ```cpp
    long double ld;

    scanf("%Lf", &ld);
    printf("%Lf", ld);
    ```

#### 为什么使用 `%lf` 读取 `double` 类型的值，而用 `%f` 进行显示呢？
1. 首先，注意，`scanf` 函数和 `printf` 函数都是不同寻常的函数，因为它们都没有将函数的参数限制为固定数量。
2. `scanf` 函数和 `printf` 函数有可变长度的参数列表。当调用带有可变长度参数列表的函数时，编译器会安排 `float` 参数自动转换成为 `double` 类型，其结果是 `printf` 函数无法区分 `float` 类型和 `double` 类型的参数。这解释了在 `printf` 函数调用中为何可以用 `%f` 既表示 `float` 类型又表示 `double` 类型的参数。
3. 另一方面，`scanf` 函数是通过指针指向变量的。`%f` 告诉 `scanf` 函数在所传地址位置上存储一个 `float` 类型值，而 `%lf` 告诉 `scanf` 函数在该地址上存储一个 `double` 类型值。
4. 这里 `float` 和 `double` 的区别是非常重要的。如果给出了错误的转换说明，那么 `scanf` 函数将可能存储错误的字节数量（没有提到的是，`float` 类型的位模式可能不同于 `double` 类型的位模式）。


## 字符类型
1. `char` 类型的值可以根据计算机的不同而不同，因为不同的机器可能会有不同的字符集。
2. 当今最常用的字符集是 ASCII（美国信息交换标准码）字符集，它用 7 位代码表示 128 个字符。在 ASCII 码中，数字 0~9 用 0110000~0111001 码来表示，大写字母 A~Z 用 1000001~1011010 码表示。ASCII 码常被扩展用于表示 256 个字符，相应的字符集 Latin-1 包含西欧和许多非洲语言中的字符。
3. 注意，字符常量需要用单引号括起来，而不是双引号。

### 字符操作
1. 在 C 语言中字符的操作非常简单，因为存在这样一个事实：C 语言把字符当作小整数进行处理。毕竟所有字符都是以二进制的形式进行编码的，而且无需花费太多的想象就可以将这些二进制代码看成整数。
2. 例如，在 ASCII 码中，字符的取值范围是 0000000~1111111，可以看成是 0~127 的整数。字符 `'a'` 的值为 97，`'A'` 的值为 65，`'0'` 的值为 48，而 `' '` 的值为 32。
3. 在 C 中，字符和整数之间的关联是非常强的，字符常量事实上是 `int` 类型而不是 `char` 类型。
4. 当计算中出现字符时，C 语言只是使用它对应的整数值。思考下面这个例子，假设采用 ASCII 字符集：
    ```cpp
    char ch;
    int i;

    i = 'a';         /* i is now 97    */
    ch = 65;         /* ch is now  'A' */
    ch = ch + 1;     /* ch is now  'B' */
    ch++;            /* ch is now  'C' */
    ```
5. 可以像比较数那样对字符进行比较。下面的 `if` 语句测试 `ch` 中是否含有小写字母，如果有，那么它会把 `ch` 转化为相应的大写字母。
    ```cpp
    if (ch >= 'a' && ch <= 'z')
        ch = ch - 'a' + 'A';
    ```
6. 诸如 `'a'<= ch` 这样的比较使用的是字符所对应的整数值，这些数值依据使用的字符集有所不同，所以程序使用 `<`、`<=`、`>` 和 `>=` 来进行字符比较可能不易移植。
7. 字符拥有和数相同的属性，这一事实会带来一些好处。例如，可以让 `for` 语句中的控制变量遍历所有的大写字母：
    ```cpp
    for (ch = 'A'; ch <= 'Z'; ch++)...
    ```
8. 另一方面，以数的方式处理字符可能会导致编译器无法检查出来的多种编程错误，还可能会导致我们编写出诸如 `'a' * 'b' / 'c'` 这类无意义的表达式。此外，这样做也可能会妨碍程序的可移植性，因为程序可能会基于一些对字符集的假设。（例如，上述 `for` 循环假设从字母 A 到字母 Z 的代码都是连续的。）

### 有符号字符和无符号字符
1. 既然 C 语言允许把字符作为整数来使用，那么 `char` 类型应该像整数类型一样也存在有符号型和无符号型两种。通常有符号字符的取值范围是 -128~127，而无符号字符的取值范围则是 0~255。
2. C 语言标准没有说明普通 `char` 类型数据是有符号型还是无符号型，有些编译器把它们当作有符号型来处理，有些编译器则将它们当作无符号型来处理。（甚至还有一些编译器允许程序员通过编译器选项来选择把 `char` 类型当成有符号型还是无符号型。）
3. 大多数时候，人们并不真的关心 `char` 类型是有符号型还是无符号型。但是，我们偶尔确实需要注意，特别是当使用字符型变量存储一个小值整数的时候。基于上述原因， 标准 C 允许使用单词 `signed` 和 `unsigned` 来修饰 `char` 类型：
    ```cpp
    signed char sch;
    unsigned char uch;
    ```
4. 由于字符和整数之间有密切关系，C89 采用术语 **整值类型**（integral type）来（统称）包含整数类型和字符类型。枚举类型也属于整值类型。C99 不使用术语 “整值类型”，而是扩展了整数类型的含义使其包含字符类型和枚举类型。C99 中的` _Bool` 型是无符号整数类型。

### 算术类型
整数类型和浮点类型统称为 **算术类型**。

#### C89 中的算术类型
* 整值类型：
    * 字符数型（`char`）；
    * 有符号整型（`signed char`、`short int`、`int`、`long int`）；
    * 无符号整型（`unsigned char`、`unsigned short int`、`unsigned int`、`unsigned long int`）；
    * 枚举类型。
* 浮点类型（`float`、`double`、`long double`）。

#### C99 中的算术类型
* 整数类型：
    * 字符类型（`char`）；
    * 有符号整型, 包括标准的（`signed char`、`short int`、`int`、`long int`、`long long int`）和扩展的；
    * 无符号整型，包括标准的（`unsigned char`、`unsigned short int`、`unsigned int`、`unsigned long int`、`unsigned long long int`、`_Bool`）和扩展的；
    * 枚举类型。
* 浮点类型：
    * 实数浮点类型（`float`、`double`、`long double`）；
    * 复数类型（`float_Complex`、`double_Complex`、`long double_Complex`）。

### 转义序列
1. 正如在前面示例中见到的那样，字符常量通常是用单引号括起来的单个字符。然而，一些特殊符号（比如换行符）是无法采用上述方式书写的，因为它们不可见（非打印字符），或者无法从键盘输入。
2. 因此，为了使程序可以处理字符集中的每一个字符，C 语言提供了一种特殊的表示法——**转义序列**（escape sequence）。
3. 转义序列共有两种：**字符转义序列**（character escape）和 **数字转义序列**（numeric escape）。下面给出了完整的字符转义序列集合
    <table width="90%" border="1" style="margin-bottom: 20px;">
        <thead>
            <tr>
                <th><p>名称</p></th>
                <th><p>转义序列</p></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><p>警报（响铃）符</p></td>
                <td>
                    <p><code>\a</code></p>
                </td>
            </tr>
            <tr>
                <td><p>回退符</p></td>
                <td>
                    <p><code>\b</code></p>
                </td>
            </tr>
            <tr>
                <td><p>换页符</p></td>
                <td>
                    <p><code>\f</code></p>
                </td>
            </tr>
            <tr>
                <td><p>换行符</p></td>
                <td>
                    <p><code>\n</code></p>
                </td>
            </tr>
            <tr>
                <td><p>回车符</p></td>
                <td>
                    <p><code>\r</code></p>
                </td>
            </tr>
            <tr>
                <td><p>水平制表符</p></td>
                <td>
                    <p><code>\t</code></p>
                </td>
            </tr>
            <tr>
                <td><p>垂直制表符</p></td>
                <td>
                    <p><code>\v</code></p>
                </td>
            </tr>
            <tr>
                <td><p>反斜杠</p></td>
                <td>
                    <p><code>\\</code></p>
                </td>
            </tr>
            <tr>
                <td><p>问号</p></td>
                <td>
                    <p><code>\?</code></p>
                </td>
            </tr>
            <tr>
                <td><p>单引号</p></td>
                <td>
                    <p><code>\'</code></p>
                </td>
            </tr>
            <tr>
                <td><p>双引号</p></td>
                <td>
                    <p><code>\"</code></p>
                </td>
            </tr>
        </tbody>
    </table>
4. 字符转义序列使用起来很容易，但是它们有一个问题：转义序列列表没有包含所有无法打印的 ASCII 字符，只包含了最常用的字符。字符转义序列也无法用于表示基本的 128 个 ASCII 字符以外的字符。数字转义序列可以表示任何字符，所以它可以解决上述问题。
5. 为了把特殊字符书写成数字转义序列，首先需要查找字符的八进制或十六进制值。例如，某个 ASCII 码转义字符（十进制值为 27）对应的八进制值为 33，对应的十六进制值为 1B。上述八进制或十六进制码可以用来书写转义序列。
6. **八进制转义序列** 由字符 `\` 和跟随其后的一个最多含有三位数字的八进制数组成。此数必须表示为无符号字符，所以最大值通常是八进制的 377（十进制 $2^8-1$）。例如，可以将转义字符写成 `\33` 或 `\033`。跟八进制常量不同，转义序列中的八进制数不一定要用 `0` 开头。
7. **十六进制转义序列** 由 `\x` 和跟随其后的一个十六进制数组成。虽然标准 C 对于十六进制数的位数没有限制，但其必须表示成无符号字符。因此，如果字符长度是 8 bit，那么十六进制数的值不能超过 FF（十进制 $2^8-1$）。若采用这种表示法，可以把转义字符写成 `\x1b` 或 `\x1B` 的形式。字符 `x` 必须小写，但是十六进制的数字（例如 `b`）不限大小写。
8. 作为字符常量使用时，转义序列必须用一对单引号括起来。例如，表示转义字符的常量可以写成 `'\33'`（或 `'\x1b'`）的形式。转义序列可能有点隐晦，所以采用 `#define` 的方式给它们命名通常是个不错的主意：
    ```cpp
    #define ESC '\33'    /* ASCII escape character */
    ```
9. 转义序列不是唯一一种用于表示字符的特殊表示法。三字符序列提供了一种表示字符 `#`、`[`、`\`、`]`、`^`、`{`、`|`、`}` 和 `~` 的方法，这些字符在一些国家的键盘上是打不出来的。C99 增加了通用字符名。通用字符名跟转义序列相似，不同之处在于通用字符名可以用在标识符中。

### 用 `scanf` 和 `printf` 读/写字符
1. 转换说明 `%c` 允许 `scanf` 函数和 `printf` 函数对单个字符进行读/写操作：
    ```cpp
    char ch;

    scanf("%c", &ch);    /* reads a single character */
    printf("%c", ch);    /* writes a single character */
    ```
2. 在读入字符前，`scanf` 函数不会跳过空白字符。如果下一个未读字符是空格，那么在前面的例子中，`scanf` 函数返回后变量 `ch` 将包含一个空格。为了强制 `scanf` 函数在读入字符前跳过空白字符，需要在格式串中的转换说明 `%c` 前面加上一个空格，`scanf` 格式串中的空白意味着 “跳过零个或多个空白字符”：
    ```cpp
    scanf(" %c", &ch);   /* skips white space, then reads ch */
    ```
3. 因为通常情况下 `scanf` 函数不会跳过空白，所以它很容易检查到输入行的结尾：检查刚读入的字符是否为换行符。例如，下面的循环将读入并且忽略掉当前输入行中剩下的所有字符，下次调用 `scanf` 函数时，将读入下一输入行中的第一个字符：
    ```cpp
    do {
    scanf("%c", &ch);
    } while  (ch != '\n');
    ```

### 用 `getchar` 和 `putchar` 读/写字符
1. C 语言还提供了另外一些读/写单个字符的方法。特别是， 可以使用 `getchar` 函数和 `putchar` 函数来取代 `scanf` 函数和 `printf` 函数。
2. `putchar` 函数用于写单个字符：
    ```cpp
    putchar(ch);
    ```
3. 每次调用 `getchar` 函数时，它会读入一个字符并将其返回。为了保存这个字符，必须使用赋值操作将其存储到变量中：
    ```cpp
    ch = getchar();
    ```
4. 事实上，`getchar` 函数返回的是一个 `int` 类型的值而不是 `char` 类型的值。因此，如果一个变量用于存储 `getchar` 函数读取的字符，其类型设置为 `int` 而不是 `char` 也没啥好奇怪的。
5. 和 `scanf` 函数一样，`getchar` 函数也不会在读取时跳过空白字符。
6. 执行程序时，使用 `getchar` 函数和 `putchar` 函数（胜于 `scanf` 函数和 `printf` 函数）可以节约时间。 `getchar` 函数和 `putchar` 函数执行速度快有两个原因：
    * 这两个函数比 `scanf` 函数和 `printf` 函数简单得多，因为 `scanf` 函数和 `printf` 函数是设计用来按不同的格式读/写多种不同类型数据的。
    * 为了额外的速度提升，通常 `getchar` 函数和 `putchar` 函数是作为宏来实现的。
7. `getchar` 函数还有一个优于 `scanf` 函数的地方：因为返回的是读入的字符，所以 `getchar` 函数可以应用在多种不同的 C 语言惯用法中。下面的例子可以跳过不定数量的空格字符
    ```cpp
    char ch;
    
    while ((ch = getchar()) == ' ')
        ;
    
    putchar(ch);

    return 0;
    ```
8. 下面的例子统计输入字符串的长度
    ```cpp
    int len = 0;

    printf("Enter a message: ");

    while ( getchar() != '\n' ) {
        len++;
    }

    printf("Your message was %d character(s) long.", len);
    ```
    效果如下
    ```sh
    Enter a message: Brevity is the soul of wit.
    Your message was 27 character(s) long.
    ```

### 读入字符时对多字符（包括换行符）的处理
1. `scanf` 和 `getchar` 都倾向于遗留下它 “扫视” 过但未读取的字符（包括换行符）。
2. 考虑下面的例子
    ```cpp
    char c1, c2;

    c1 = getchar(); // 使用 scanf("%c", &c1) 也一样
    printf("c1 is \"%c\" \n", c1);

    c2 = getchar(); // 使用 scanf("%c", &c2) 也一样
    printf("c2 is \"%c\" \n", c2);
    ```
3. 预期是：
    1. 输入 `a` 按回车，打印出 `c1 is "a"`，然后换行。
    2. 输入 `b` 按回车，打印出 `c2 is "b"`，然后换行。
    3. 程序结束
4. 但如果第一次就输入了 `ab`，第一个 `getchar` 只会读取 `a` 而留下 `b`。后面第二个 `getchar` 不会再要求用户输入，而是直接读取之前留下的 `b`，然后执行后面的打印并退出程序。
5. 更容易出错的情况是，即使你第一次确实值输入了 `a` 并按回车，之后也不会按照预期发展，而后直接打印出如下内容并退出程序
    ```sh
    c1 is "a" 
    c2 is "
    " 
    ```
6. 因为第一个 `getchar` 读取 `a` 之后留下了换行符，所以第二个 `getchar` 仍然不会再要求用户输入，`c2` 直接读取到了换行并打印。
7. 解决换行问题还是要用前面说到的 `scanf` 加空格的方法，用这个空格去匹配前面的若干个空白字符，然后 `%c` 就能匹配到正确的字符
    ```cpp
    scanf(" %c", &c2);
    ```

### 什么时候需要考虑字符变量是有符号的还是无符号的  不懂
1. 如果在变量中只存储 7 位的字符，那么不需要考虑，因为符号位将为零。但是，如果计划存储 8 位字符，那么将希望变量是 `unsigned char` 类型。思考下面的例子：
    ```cpp
    ch = '\xdb';
    ```
2. 如果已经把变量 `ch` 声明成 `char` 类型，那么编译器可能选择把它看作是有符号的字符来处理（许多编译器这么做）。只要变量 `ch` 只是作为字符来使用，就不会有什么问题。
3. 但是如果 `ch` 用在一些需要编译器将其值转换为整数的上下文中，那么可能就有问题了：转换为整数的结果将是负数，因为变量 `ch` 的符号位为 `1`。
4. 还有另外一种情况：在一些程序中，习惯使用 `char` 类型变量存储单字节的整数。如果编写了这类程序，就需要决定每个变量应该是 `signed char` 类型的还是 `unsigned char` 类型的，这就像需要决定普通整型变量应该是 `int` 类型还是 `unsigned int` 类型一样。


## 类型转换
1. 在执行算术运算时，计算机比 C 语言的限制更多。为了让计算机执行算术运算，通常要求操作数有相同的大小（即位的数量相同），并且要求存储的方式也相同。
2. 计算机可能可以直接将两个 16 位整数相加，但是不能直接将 16 位整数和32位整数相加，也不能直接将 32 位整数和 32 位浮点数相加。
3. C 语言则允许在表达式中混合使用基本类型。在单个表达式中可以组合整数、浮点数，甚至是字符。当然，在这种情况下 C 编译器可能需要生成一些指令将某些操作数转换成不同类型，使得硬件可以对表达式进行计算。
4. 例如，如果对 16 位 `short` 型数和 32 位 `int` 型数进行加法操作，那么编译器将安排把 16 位 `short` 型值转换成 32 位值。如果是 `int` 型数据和 `float` 型数据进行加法操作，那么编译器将安排把 `int` 型值转换成为 `float` 格式。这个转换过程稍微复杂一些，因为 `int` 型值和 `float` 型值的存储方式不同。
5. 因为编译器可以自动处理这些转换而无需程序员介入，所以这类转换称为 **隐式转换**（implicit conversion）。C 语言还允许程序员使用强制运算符执行 **显式转换**（explicit conversion）。 
6. 当发生下列情况时会进行隐式转换。
    * 当算术表达式或逻辑表达式中操作数的类型不相同时。（C 语言执行所谓的 **常用算术转换**。）
    * 当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。
    * 当函数调用中的实参类型与其对应的形参类型不匹配时。
    * 当 `return` 语句中表达式的类型和函数返回值的类型不匹配时。

### 常用算术转换
1. 常用算术转换可用于大多数二元运算符（包括算术运算符、关系运算符和判等运算符）的操作数。例如，假设变量 `f` 为 `float` 类型，而变量 `i` 为 `int` 类型。常用算术转换将会应用在表达式 `f + i` 的操作数上，因为两者的类型不同。
2. 显然把变量 `i` 转换成 `float` 类型比把变量 `f` 转换成 `int` 类型更安全。整数始终可以转换成为 `float` 类型；可能会发生的最糟糕的事是精度会有少量损失。相反，把浮点数转换成为 `int` 类型，将有小数部分的损失；更糟糕的是，如果原始数大于最大可能的整数或者小于最小的整数，那么将会得到一个完全没有意义的结果。
3. 常用算术转换的策略是把操作数转换成可以安全地适用于两个数值的 “最狭小的” 数据类型。粗略地说，如果某种类型要求的存储字节比另一种类型少，那么这种类型就比另一种类型更狭小。
4. 为了统一操作数的类型，通常可以将相对较狭小类型的操作数转换成另一个操作数的类型来实现，这就是所谓的 **提升**。最常用的提升是 **整值提升**（integral promotion），它把字符或短整数转换成 `int` 类型（或者某些情况下是 `unsigned int` 类型）。

#### 转换规则
##### 任一操作数的类型是浮点类型的情况
1. 按照下面的示意将类型较狭小的操作数进行提升：
    ```
    long double
        ↑
        double
        ↑
        float
    ```
2. 也就是说，如果一个操作数的类型为 `long double`，那么把另一个操作数的类型转换成 `long double` 类型。否则，如果一个操作数的类型为 `double` 类型，那么把另一个操作数转化成 `double` 类型。否则，如果一个操作数的类型是 `float` 类型，那么把另一个操作数转换成 `float` 类型。
3. 注意，这些规则涵盖了混合整数和浮点类型的情况。例如，如果一个操作数的类型是 `long int` 类型，并且另一个操作数的类型是 `double` 类型，那么把 `long int` 类型的操作数转换成 `double` 类型。

##### 两个操作数的类型都不是浮点类型的情况
1. 首先对两个操作数进行整值提升，保证没有一个操作数是字符类型或短整型。然后按照下图对类型较狭小的操作数进行提升：
    ```cpp
    unsigned long int
            ↑
        long int
            ↑
      unsigned int
            ↑
          int
    ```
2. 有一种特殊情况，只有在 `long int` 类型和 `unsigned int` 类型长度（比如 32 位）相同时才会发生。在这类情况下，如果一个操作数的类型是 `long int`，而另一个的类型是 `unsigned int`，那么两个操作数都会转换成 `unsigned long int` 类型。

##### 有符号操作数和无符号操作数组合
1. 当把有符号操作数和无符号操作数组合时，把有符号操作数（实测只有负数会这样） “转换” 成无符号的值。转换过程中需要加上或者减去 $n+1$ 的倍数，其中 $n$ 是无符号类型能表示的最大值。这条规则可能会导致某些隐蔽的编程错误。 
2. 假设 `int` 类型的变量 `i` 的值为 -1，而 `unsigned int` 类型的变量 `u` 的值为 1。如果用 `<` 运算符比较变量 `i` 和变量 `u`，那么期望的结果应该是 1。
3. 但是，在比较前，变量 `i` 转换成为 `unsigned int` 类型。因为负数不能被表示成无符号整数，所以转换后的值将不再为 `-1`，而是加上 `4294967296` 的结果（假定 `4294967295` 是最大的无符号整数），即 `4294967295`。因而 `i < u` 比较的结果将为 0
    ```cpp
    int i = -1;
    unsigned int u = 10;

    printf("%d\n", i < u); // 0
    printf("%u", i); // 4294967295
    ```
4. 所以这个 `-1` 实际上的意义就是倒数第一个无符号整数，负整数 `-N` 转换为无符号整数就是倒数第 `N` 个无符号整数。
5. 有些编译器会在程序试图比较有符号数与无符号数时给出一条类似 “comparison between signed and unsigned” 的警告消息。
6. 由于此类陷阱的存在，所以最好尽量避免使用无符号整数，特别是不要把它和有符号整数混合使用。

### 赋值过程中的转换
1. 常用算术转换不适用于赋值运算。C 语言会遵循另一条简单的转换规则，那就是把赋值运算右边的表达式转换成左边变量的类型。
2. 如果变量的类型至少和表达式类型一样 “宽”，那么这种转换将没有任何障碍。例如：
    ```cpp
    char c;
    int i;
    float f;
    double d;

    i = c;   /* c is converted to int    */
    f = i;   /* i is converted to float  */
    d = f;   /* f is converted to double */
    ```
3. 其他情况下是有问题的。把浮点数赋值给整型变量会丢掉该数的小数部分：
    ```cpp
    int i;

    i = 842.97;   /* i is now 842  */
    i = -842.97;  /* i is now -842 */
    ```
4. 此外，把某种类型的值赋给类型更狭小的变量时， 如果该值在变量类型范围之外，那么将会得到无意义的结果。甚至更糟，这类赋值可能会导致编译器或 lint 之类的工具发出警告
    ```cpp
    c = 10000;    /*** WRONG ***/
    i = 1.0e20;   /*** WRONG ***/
    f = 1.0e100;  /*** WRONG ***/
    ```
5. 如果浮点常量被赋值给 `float` 型变量时，一个很好的方法是在浮点常量尾部加上后辍 `f`：
    ```cpp
    f = 3.14159f;
    ```
    如果没有后辍，常量 `3.14159` 将是 `double` 类型，可能会引起警告消息。

### C99 中的隐式转换
1. C99 中的隐式转换和 C89 中的隐式转换略有不同，这主要是因为 C99 增加了一些类型（`_Bool`、`long long` 类型、扩展的整数类型和复数类型）。
2. 为了定义转换规则，C99 允许每个整数类型具有 “整数转换等级”。下面按从最高级到最低级的顺序排列（简单起见，这里忽略了扩展的整数类型和枚举类型）
    1. `long long int`、`unsigned long long int`
    2. `long int`、`unsigned long int`
    3. `int`、`unsigned int`
    4. `short int`、`unsigned short int`
    5. `char`、`signed char`、`unsigned char`
    6. `_Bool`
3. C99 用 **整数提升**（integer promotion）取代了 C89 中的 **整值提升**（integral promotion），可以将任何等级低于 `int` 和`unsigned int` 的类型转换为 `int`（只要该类型的所有值都可以用 `int` 类型表示）或 `unsigned int`。
4. 与 C89 一样，C99 中执行常用算术转换的规则可以划分为两种情况：
  * **任一操作数的类型是浮点类型的情况**。只要两个操作数都不是复数型，规则与前面一样。
  * **两个操作数的类型都不是浮点类型的情况**。首先对两个操作数进行整数提升。如果这时两个操作数的类型相同，过程结束。否则，依次尝试下面的规则，一旦遇到可应用的规则就不再考虑别的规则：
      * 如果两个操作数都是有符号型或者都是无符号型，将整数转换等级较低的操作数转换为等级较高的操作数的类型；
      * 如果无符号操作数的等级高于或等于有符号操作数的等级，将有符号操作数转换为无符号操作数的类型。
      * 如果有符号操作数类型可以表示无符号操作数类型的所有值，将无符号操作数转换为有符号操作数的类型。
      * 否则，将两个操作数都转换为与有符号操作数的类型相对应的无符号类型。
5. 另外，所有算术类型都可以转换为 `_Bool` 类型。如果原始值为0则转换结果为 0，否则结果为 1。

### 强制类型转换
1. 虽然 C 语言的隐式转换使用起来非常方便，但我们有些时候还需要从更大程度上控制类型转换。基于这种原因，C 语言提供了强制类型转换。
2. 强制类型转换表达式的格式如下：
    ```
    (类型名) 表达式
    ```
    这里的类型名表示的是表达式应该转换成的类型。
3. 下面的例子显示了使用强制类型转换表达式计算 `float` 类型值小数部分的方法：
  ```cpp
  float f, frac_part;

  frac_part = f - (int)f;
  ```
4. C 语言把 `(类型名)` 视为一元运算符。一元运算符的优先级高于二元运算符，所以编译器会把表达式
  ```cpp
  (float) dividend / divisor
  ```
  解释为
  ```cpp
   ((float) dividend) / divisor
   ```
5. 有些时候，需要使用强制类型转换来避免溢出。思考下面这个例子：
    ```cpp
    long i;
    int j = 1000;

    i = j * j;   /* overflow may occur */
    ```
    乍看之下，这条语句没有问题。表达式 `j * j` 的值是 1 000 000，并且变量 `i` 是 `long int` 类型的，所以 `i` 应该能很容易地存储这种大小的值。问题是，当两个 `int` 类型值相乘时，结果也应该是 `int` 类型的，但是 `j * j` 的结果太大，以致在某些机器上无法表示成 `int` 型，从而导致溢出。
6. 幸运的是，可以使用强制类型转换避免这种问题的发生：
    ```cpp
    i = (long) j * j;
    ```
    因为强制运算符的优先级高于 `*`，所以第一个变量 `j` 会被转换成 `long int` 类型，同时也迫使第二个 `j` 进行转换。
7. 注意，下面的转换方法是不对的，，因为溢出在强制类型转换之前就已经发生了。
    ```cpp
    i = (long) (j * j);   /*** WRONG ***/
    ```


## 类型定义
1. 我们可以使用 `#define BOOL int` 指令创建一个宏来定义布尔型数据，但是一个更好的设置布尔类型的方法是利用所谓的 **类型定义**（type definition）的特性：
    ```cpp
    typedef int Bool;
    ```
2. 将类型名的首字母大写不是必须的，只是一些C语言程序员的习惯。
3. 采用 `typedef` 定义 `Bool` 会导致编译器在它所识别的类型名列表中加入 `Bool`。现在，`Bool` 类型可以和内置的类型名一样用于变量声明、强制类型转换表达式和其他地方了。例如，可以使用 `Bool` 声明变量：
    ```cpp
    Bool flag;    /* same as int flag; */
    ```
    编译器将会把 `Bool` 类型看成是 `int` 类型的同义词；因此，变量 `flag` 实际就是一个普通的 `int` 类型变量。
4. `typedef` 命名的对象具有和变量相同的作用域规则；定义在函数体内的 `typedef` 名字在函数外是无法识别的。而宏的名字在预处理时会在任何出现的地方被替换掉。

### 类型定义的优点
1. 类型定义使程序更加易于理解（假定程序员是仔细选择了有意义的类型名）。例如，假设变量 `cash_in` 和变量 `cash_out` 将用于存储美元数量。把 `Dollars` 声明成
    ```cpp
    typedef float Dollars;
    ```
    并且随后写出
    ```cpp
    Dollars cash_in, cash_out;
    ```
    这样的写法比下面的写法更有实际意义：
    ```cpp
    float cash_in, cash_out;
    ```
2. 类型定义还可以使程序更容易修改。如果稍后决定 `Dollars` 实际应该定义为 `double` 类型的，那么只需要改变类型定义就足够了：
    ```cpp
    typedef double Dollars;
    ```

### 类型定义和可移植性
1. 类型定义是编写可移植程序的一种重要工具。程序从一台计算机移动到另一台计算机可能引发的问题之一就是不同计算机上的类型取值范围可能不同。
2. 如果 `i` 是 `int` 类型的变量，那么赋值语句 `i = 100000;` 在使用 32 位整数的机器上是没问题的，但是在使用 16 位整数的机器上就会出错。
3. 假设编写的程序需要用变量来存储产品数量, 取值范围在 0~50 000。为此可以使用 `long int` 类型的变量（因为这样保证可以存储至少在 2 147 483 647 以内的数），但是用户更愿意使用 `int` 类型的变量，因为算术运算时 `int` 类型值比 `long int` 类型值运算速度快；同时， `int` 类型变量占用的空间较少。
4. 我们可以定义自己的 “数量” 类型，而避免使用 `int` 类型声明数量变量：
    ```cpp
    typedef int Quantity;
    ```
5. 并且使用这种类型来声明变量：
    ```cpp
    Quantity q;
    ```
6. 当把程序转到使用较短整数的机器上时，只需要改变 `Quantity` 的定义：
    ```cpp
    typedef long Quantity;
    ```

#### 缺陷
1. 可惜的是，这种技术无法解决所有的问题，因为 `Quantity` 定义的变化可能会影响类型变量的使用方式。我们至少需要改动使用了 `Quantity` 类型变量的 `printf` 函数调用和 `scanf` 函数调用，用转换说明 `%ld` 替换` %d`。
2. C 语言库自身使用 `typedef` 为那些可能依据 C 语言实现的不同而不同的类型创建类型名；这些类型的名字经常以 `_t` 结尾，比如 `ptrdiff_t`、`size_t` 和 `wchar_t`。这些类型的精确定义不尽相同，下面是一些常见的例子：
    ```cpp
    typedef long int ptrdiff_t;
    typedef unsigned long int size_t;
    typedef int wchar_t;
    ```
3. 在 C99 中，`<stdint.h>` 头使用 `typedef` 定义占用特定位数的整数类型名。例如，`int32_t` 是恰好占用 32 位的有符号整型。这是一种有效的定义方式，能使程序更易于移植。


## `sizeof` 运算符
1. 表达式 `sizeof(类型名)` 的值是一个无符号整数，代表存储属于类型名的值所需要的字节数。
2. 表达式 `sizeof(char)` 的值始终为 1，但是对其他类型计算出的值可能会有所不同。在 32 位的机器上，表达式 `sizeof(int)` 的值通常为 4。
3. 注意，`sizeof` 运算符是一种特殊的运算符， 因为编译器本身通常就能够确定 `sizeof` 表达式的值。在 C89 中编译器总是可以的，但在 C99 中有一个例外。编译器不能确定变长数组的大小，因为数组中的元素个数在程序执行期间是可变的。
4. 通常情况下，`sizeof` 运算符也可以应用于常量、变量和表达式。如果 `i` 和 `j` 是整型变量，那么 `sizeof(i)` 在 32 位机器上的值为 4，这和表达式 `sizeof(i+j)` 的值一样。
5. 跟应用于类型时不同，`sizeof` 应用于表达式时不要求圆括号，我们可以用 `sizeof i` 代替 `sizeof(i)`。但是，由于运算符优先级的问题，圆括号有时还是需要的。编译器会把表达式 `sizeof i + j` 解释为 `(sizeof i) + j`，这是因为 `sizeof` 作为一元运算符的优先级高于二元运算符 `+`。为了避免出现此类问题，最好始终加上圆括号。
6. 显示 `sizeof` 值时要注意，因为 `sizeof` 表达式的类型是 `size_t`，这是一种由实现定义的类型。在 C89 中，最好在显示前把表达式的值转换成一种已知的类型。
7. `size_t` 一定是无符号整型，所以最安全的方法是把 `sizeof` 表达式强制转换成 `unsigned long` 类型（C89 中最大的无符号类型），然后使用转换说明符 `%lu` 显示：
    ```cpp
    printf("Size of int: %lu\n", (unsigned long) sizeof(int));
    ```
8. 在 C99 中，`size_t` 类型可以比 `unsigned long` 更长。但 C99 中的 `printf` 可以直接显示出 `size_t` 类型值而不需要强制转换。方法是在转换说明中的一般整数（通常用 `u`）代码前使用字母 `z`：
    ```cpp
    printf("Size of int: %zu\n", sizeof(int));     /* C99 only */
    ```


## 习题
* 编程题 12
    ```cpp
    char ch;
    float left, right;

    printf("Enter an expression: ");

    scanf("%f", &left);

    while ( (ch = getchar()) != '\n' ) {

        scanf("%f", &right);

        switch (ch) {
            case '+': 
                left = left + right;
                break;
            case '-': 
                left = left - right;
                break;
            case '*': 
                left = left * right;
                break;
            case '/': 
                left = left / right;
                break;
        }
    }

    printf("Value of expression: %f", left);
    ```


## References
* [C语言程序设计](https://book.douban.com/subject/4279678/)