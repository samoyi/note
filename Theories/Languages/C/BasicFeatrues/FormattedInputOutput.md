# Formatted Input/Output


<!-- TOC -->

- [Formatted Input/Output](#formatted-inputoutput)
    - [`printf` 函数](#printf-函数)
        - [基本格式](#基本格式)
        - [数量和类型的匹配](#数量和类型的匹配)
        - [转换说明](#转换说明)
            - [最小字段宽度](#最小字段宽度)
            - [精度](#精度)
        - [转义序列](#转义序列)
    - [`scanf` 函数](#scanf-函数)
        - [`&`](#)
        - [`scanf` 函数的工作方法](#scanf-函数的工作方法)
            - [对空白字符的处理](#对空白字符的处理)
            - [识别整数或浮点数](#识别整数或浮点数)
        - [格式串中的普通字符](#格式串中的普通字符)
    - [References](#references)

<!-- /TOC -->


## `printf` 函数
### 基本格式
1. `printf` 函数被设计用来显示 **格式串**（format string）的内容，并且在该串中的指定位置插入可能的值。
2. 调用 `printf` 函数时必须提供格式串，格式串后面的参数是需要在显示时插入到该串中的值：
    ```cpp
    printf(格式串, 表达式1, 表达式2, ...);
    ```
3. 格式串包含普通字符和 **转换说明**（conversion specification），其中转换说明以字符 `%` 开头。
4. 转换说明是用来表示打印过程中待填充的值的占位符。跟随在字符 `%` 后边的信息指定了把数值从内部形式（二进制）转换成打印形式（字符）的方法，这也就是 “转换说明” 这一术语的由来。
5. 例如，转换说明 `%d` 指定 `printf` 函数把 `int` 型值从二进制形式转换成十进制数字组成的字符串，转换说明 `%f` 对 `float` 型值也进行类似的转换。
6. 格式串中的普通字符完全如在字符串中出现的那样显示出来，而转换说明则要用待显示的值来替换。

### 数量和类型的匹配
1. C 语言编译器不会检测格式串中转换说明的数量是否和输出项的数量相匹配。
2. 下面这个 `printf` 函数调用所拥有的转换说明的数量就多于要显示的值的数量：
    ```cpp
    int i, j;

    i = 10;
    j = 20;
    
    printf("%d %d\n", i); // 10 6422352
    ```
    `printf` 函数将正确显示变量 `i` 的值，接着显示另一个（无意义的）整数值。
3. 函数调用带有太少的转换说明也会出现类似的问题：
    ```cpp
    printf("%d\n", i, j); // 10
    ```
    在这种情况下，`printf` 函数会显示变量i的值，但是不显示变量 `j` 的值。
4. 此外，C 语言编译器也不检测转换说明是否适合要显示项的数据类型。如果程序员使用不正确的转换说明，程序将会简单地产生无意义的输出
    ```cpp
    i = 10;
    x = 43.2892f;
    printf("%d %f\n", x, i); // -2147483648 0.000000
    ```
    因为 `printf` 函数必须服从于格式串，所以它将如实地显示出一个 `float` 型值，接着是一个 `int` 型值。可惜这两个值都将是无意义的。

### 转换说明
1. 转换说明可以用 `%m.pX` 格式或 `%-m.pX` 格式，这里的 `m` 和 `p` 都是整数常量，而 `X` 是字母。 
2. `m` 和 `p` 都是可选的。如果省略 `p`， `m` 和 `p` 之间的小数点也要去掉。
3. 在转换说明 `%10.2f` 中， `m` 是 `10`， `p` 是 `2`，而 `X` 是 `f`。在转换说明 `%10f` 中， `m` 是 `10`， `p`（连同小数
点一起）省去了；而在转换说明 `%.2f` 中， `p` 是 `2`， `m` 省去了。

#### 最小字段宽度
1. **最小字段宽度**（minimum field width）`m` 指定了要显示的最少字符数量。
2. 如果要显示的数值所需的字符数少于 `m`，那么值在字段内是右对齐的。（换句话说，在值前面放置额外的空格。）例如，转换说明 `%4d` 将以 `" 123"` 的形式显示数 `123`
    ```cpp
    int n = 123;

    printf("^%4d$\n", n); // ^ 123$
    ```
3. 如果要显示的值所需的字符数多于 `m`，那么字段宽度会自动扩展为所需的尺寸。因此，转换说明 `%4d` 将以 "12345" 的形式显示数 `12345`，而不会丢失数字
    ```cpp
    int n = 12345;

    printf("^%4d$\n", n); // ^12345$
    ```
4. 在 `m` 前放上一个负号会导致左对齐；转换说明 `%-4d` 将以 `"123 "` 的形式显示 `123`
    ```cpp
    int n = 123;

    printf("^%-4d$\n", n); // ^123 $
    ```
5. 位数不足前补 0 的方法
    ```cpp
    int m, d, y;

    printf("Enter a date (mm/dd/yyyy): \n");
    scanf("%d/%d/%d", &m, &d, &y);                        // Enter a date (mm/dd/yyyy): 2/17/2011
    printf("You entered the date %d-%02d-%02d", y, m, d); // You entered the date 2011-02-17
    ```

#### 精度
1. **精度**（precision）`p` 的含义很难描述，因为它依赖于 **转换说明符**（conversion specifier）`X` 的选择。
2. `X` 表明在显示数值前需要对其进行哪种转换。对数值来说最常用的转换说明符有以下几个
    * `d` ——表示十进制（基数为 10）形式的整数。`p` 指明了待显示的数字的最少个数（必要时在数前加上额外的零）；如果省略 `p`，则默认它的值为 1。
    * `e` ——表示指数（科学记数法）形式的浮点数。`p` 指明了小数点后应该出现的数字的个数（默认值为 6）。如果 `p` 为 0，则不显示小数点。
        ```cpp
        printf("^%15.5e$", 30.253); // ^   3.02530e+001$
        // 输出字符串总长 15 位，其中小数点后 5 位
        ```
    * `f` ——表示 “定点十进制” 形式的浮点数，没有指数。`p` 的含义与在说明符 `e` 中的一样。
    * `g` ——表示指数形式或者定点十进制形式的浮点数，形式的选择根据数的大小决定。`p` 说明可以显示的有效数字（没有小数点后的数字）的最大数量。与转换说明符 `f` 不同，`g` 的转换将不显示尾随的零。此外，如果要显示的数值没有小数点后的数字，`g` 就不会显示小数点
        ```cpp
        printf("%-6.2g\n", .0000009979); // 1e-006   TODO
        ```
3. 编写程序时无法预知数的大小或者数值变化范围很大的情况下，说明符 `g` 对于数的显示是特别有用的。在用于显示大小适中的数时，说明符 `g` 采用定点十进制形式。但是，在显示非常大或非常小的数时，说明符 `g` 会转换成指数形式以便减少所需的字符数。
4. 除了说明符 `%d`、`%e`、`%f` 和 `%g` 以外，还有许多其他的说明符。
5. 例子
    ```cpp
    int i;
    float x;

    i = 40;
    x = 839.21f;

    printf("|%d|%5d|%-5d|%5.3d|\n", i, i, i, i); // |40|   40|40   |  040|
    printf("|%10.3f|%10.3e|%-10g|\n", x, x, x);  // |   839.210|8.392e+002|839.21    |

    return 0;
    ```

### 转义序列
1. 格式串中常用的代码 `\n` 被称为 **转义序列**（escape sequence）。转义序列使字符串包含一些特殊字符而不会使编译器引发问题，这些字符包括非打印的（控制）字符和对编译器有特殊含义的字符（如 `"`）。
2. 后面会提供完整的转义序列表，现在先看一组示例
    * 警报（响铃）符：`\a`。
    * 回退符：`\b`。
    * 换行符：`\n`。
    * 水平制表符：`\t`。打印 `\t` 的效果不是由 C 语言定义的，而是依赖于所使用的操作系统。水平制表符之间的距离通常是 8 个字符宽度，但 C 语言本身无法保证这一点。
3. 当这些转义序列出现在 `printf` 函数的格式串中时，它们表示在显示中执行的操作。在大多数机器上，输出 `\a` 会产生一声鸣响，输出 `\b` 会使光标从当前位置回退一个位置，输出 `\n` 会使光标跳到下一行的起始位置，输出 `\t` 会把光标移动到下一个制表符的位置。
4. 字符串可以包含任意数量的转义序列。下面的 `printf` 函数示例，其中的格式串包含了 6 个转义序列：
    ```cpp
    printf("Item\tUnit\tPurchase\n\tPrice\tDate\n");
    // Item    Unit    Purchase
    //         Price   Date
    ```
5. 另一个常用的转义序列是 `\"`，它表示字符 `。因为字符 `"` 标记字符串的开始和结束，所以它不能出现在没有使用上述转义序列的字符串内
    ```cpp
    printf("\"Hello!\""); // "Hello!"
    ```
6. 不能在字符串中只放置单独一个字符 `\`，编译器将认为它是一个转义序列的开始。为了显示单独一个字符 `\`，需要在字符串中放置两个 `\` 字符：
    ```cpp
    printf("a\\b"); // a\b
    ```
7. 如果想输出一个字符 `%`，要使用两个 `%`
    ```cpp
    printf("%%\n");
    ```


## `scanf` 函数
1. 像 `printf` 函数的格式串一样，`scanf` 函数的格式串也可以包含普通字符和转换说明两部分。`scanf` 函数转换说明的用法和 `printf` 函数转换说明的用法本质上是一样的。
2. 在许多情况下，`scanf` 函数的格式串只包含转换说明
    ```cpp
    int i, j;
    float x, y;

    // 假设用户分别输入：1  -20  .3  -4.0e3
    scanf ("%d%d%f%f", &i, &j, &x, &y);
    
    printf ("%d %d %f %f", i, j, x, y); // 1 -20 0.300000 -4000.000000

    return 0;
    ```
3. `scanf` 函数调用中像 `"%d%d%f%f"` 这样 “紧密压缩” 的格式串是很普遍的，而 `printf` 函数的格式串很少有这样紧挨着的转换说明。
4. 像 `prinf` 函数一样，`scanf` 函数也有一些不易觉察的陷阱。使用 `scanf` 函数时，程序员必须检查转换说明的数量是否与输入变量的数量相匹配，并且检查每个转换是否适合相对应的变量。与用 `printf` 函数一样，编译器无法检查出可能的匹配不当。

### `&`
1. 符号 `&` 用于创建一个指向变量的指针。
2. 通常把符号 `&` 放在 `scanf` 函数调用中每个变量的前面。符号 `&` 常常（但不总是）是需要的，记住使用它是程序员的责任。
3. 如果 `scanf` 函数调用中忘记在变量前面放置符号 `&`，将会产生不可预知且可能是毁灭性的结果。
4. 程序崩溃是常见的结果。最起码不会把从输入读进来的值存储到变量中，变量将保留原有的值（如果没有给变量赋初值，那么这个原有值可能是没有意义的）。
5. 一些编译器可以检查出这种错误，并产生一条类似 “format argument is not a pointer” 的警告消息。

### `scanf` 函数的工作方法
1. 实际上 `scanf` 函数可以做的事情远远多于目前为止已经提到的这些。`scanf` 函数本质上是一种 “模式匹配” 函数，试图把输入的字符组与转换说明相匹配。
2. 像 `printf` 函数一样，`scanf` 函数是由格式串控制的。调用时，`scanf` 函数从左边开始处理字符串中的信息。对于格式串中的每一个转换说明，`scanf` 函数从输入的数据中定位适当类型的项，并在必要时跳过空格。然后，`scanf` 函数读入数据项，并且在遇到不可能属于此项的字符时停止。
3. 如果读入数据项成功，那么 `scanf` 数会继续处理格式串的剩余部分；如果某一项不能成功读入，那么 `scanf` 函数将不再查看格式串的剩余部分（或者余下的输入数据）而立即返回。 
4. 一个分数相加的例子
    ```cpp
    #include <stdio.h>

    int main(void)
    {
        int num1, denom1, num2, denom2, result_num, result_denom;

        printf("Enter first fraction: ");
        scanf("%d/%d", &num1, &denom1);

        printf("Enter second fraction: ");
        scanf("%d/%d", &num2, &denom2);

        result_num = num1 * denom2 + num2 * denom1;
        result_denom = denom1 * denom2;
        printf("The sum is %d/%d\n", result_num, result_denom);

        return 0;
    }

    // Enter first fraction: 5/6
    // Enter second fraction: 3/4
    // The sum is 38/24
    ```

#### 对空白字符的处理
1. 在寻找数的起始位置时，`scanf` 函数会忽略 **空白字符**（white-space character，包括空格符、水平和垂直制表符、换页符和换行符）。
2. 因此，我们可以把数字放在同一行或者分散在几行内输入。考虑下面的 `scanf` 函数调用：
    ```cpp
    scanf("%d%d%f%f", &i, &j, &x, &y);
    ```
    假设用户一次录入 3 行输入：
    ```sh
    1
    -20   .3
    -4.0e3
    ```
    也可以读取到预期的数值
    ```cpp
    printf ("%d %d %f %f", i, j, x, y); // 1 -20 0.300000 -4000.000000
    ```
3. 因为 `scanf` 函数会把它们看成是一个连续的字符流，在寻找每个数的起始位置时会跳过空白字符，所以它可以成功读取这些数。
4. `printf` 格式串经常以 `\n` 结尾，但是在 `scanf` 格式串末尾放置换行符通常是一个坏主意。对 `scanf` 函数来说，格式串中的换行符等价于空格，两者都会引发 `scanf` 函数提前进入到下一个非空白字符。例如，如果格式串是 `"%d\n"`，那么 `scanf` 函数将跳过空白字符，读取一个整数，然后跳到下一个非空白字符处。像这样的格式串可能会导致交互式程序一直 “挂起” 直到用户输入一个非空白字符为止。
5. 实际上，在 `scanf` 格式串末尾放置空白字符都会导致这种情况
    ```cpp
    scanf("%d ", &x);
    ```
    属于一个整数并回车，程序只会换行而不会结束，你必须再输入一个非空字符。或者一开始就直接输入一个整数加空格再加一个非空字符，例如 `"22 33"`。

#### 识别整数或浮点数
1. 在要求读入整数时，`scanf` 函数首先寻找正号或负号，然后读取数字直到读到一个非数字时才停止。
2. 当要求读入浮点数时，`scanf` 函数会寻找一个正号或负号（可选），随后是一串数字（可能含有小数点），再后是一个指数（可选）。指数由字母 `e`（或者字母 `E`）、可选的符号和一个或多个数字构成。
3. 在用于 `scanf` 函数时，转换说明 `%e`、`%f` 和 `%g` 是可以互换的，这 3 种转换说明在识别浮点数方面都遵循相同的规则。
4. 当 `scanf` 函数遇到一个不可能属于当前项的字符时，它会把此字符 “放回原处”，以便在扫描下一个输入项或者下一次调用 `scanf` 函数时再次读入。思考下面 4 个数的排列：
    ```sh
    1-20.3-4.0e3¤
    ```
4. 我们使用与以前一样的 `scanf` 函数调用：
    ```cpp
    scanf("%d%d%f%f", &i, &j, &x, &y);

    printf ("%d %d %f %f", i, j, x, y); // 1 -20 0.300000 -4000.000000
    ```
5. 下面列出了 `scanf` 函数处理这组新输入的方法。
    1. 转换说明 `%d`。第一个非空的输入字符是 `1`；因为整数可以以 `1 `开始，所以 `scanf` 函数接着读取下一个字符，即 `-`。`scanf` 函数识别出字符 `-` 不能出现在整数内，所以把 $1$ 存入变量i中，而把字符 `-` 放回原处。
    2. 转换说明 `%d`。随后，`scanf` 函数读取字符 `-`、`2`、`0`和`.`。因为整数不能包含小数点，所以 `scanf` 函数把 $-20$ 存入变量 `j` 中，而把字符 `.` 放回原处。
    3. 转换说明 `%f`。接下来 `scanf` 函数读取字符 `.`、`3` 和 `-`。因为浮点数不能在数字后边有负号，所以 `scanf` 函数把 $0.3$ 存入变量 `x` 中，而将字符 `-` 放回原处。
    4. 转换说明 `%f`。最后，`scanf` 函数读取字符 `-`、`4`、`.`、`0`、`e`、`3` 和 `¤`（换行符）。因为浮点数不能包含换行符，所以 `scanf` 函数把 $-4.0\times10^3$ 存入变量 `y` 中，而把换行符放回原处。因为换行符没有读取，它将留给下一次 `scanf` 函数调用。

### 格式串中的普通字符
1. 通过编写含有普通字符和转换说明的格式串能更进一步地理解模式匹配的概念。处理格式串中的普通字符时，`scanf` 函数采取的动作依赖于这个字符是否为空白字符。
2. 当在格式串中遇到一个或多个连续的空白字符时，`scanf` 函数从输入中重复读空白字符直到遇到一个非空白字符（把该字符 “放回原处”）为止。
3. 格式串中空白字符的数量无关紧要，格式串中的一个空白字符可以与输入中任意数量的空白字符相匹配。
4. 在格式串中包含空白字符并不意味着输入中必须包含空白字符。格式串中的一个空白字符可以与输入中任意数量的空白字符相匹配，包括零个。
5. 当在格式串中遇到非空白字符时，`scanf` 函数将把它与下一个输入字符进行比较。如果两个字符相匹配，那么 `scanf` 函数会放弃输入字符而继续处理格式串。不懂，什么意思。如果两个字符不匹配，那么 `scanf` 函数会把不匹配的字符放回输入中，然后异常退出，而不进一步处理格式串或者从输入中读取字符。
6. 所以除了转换说明，格式串常常不需要包含字符。假设 `scanf` 格式串应该类似于 `printf` 格式串是另一个常见错误，这种不正确的假定可能引发` scanf` 函数行为异常。我们来看一下执行下面这个 `scanf` 函数调用时，到底发生了什么：
    ```cpp
    scanf("%d, %d", &i, &j);
    ```
    `scanf` 函数首先寻找输入中的整数，把这个整数存入变量 `i` 中；然后，`scanf` 函数将试图把逗号与下一个输入字符相匹配。如果下一个输入的字符是空格而不是逗号，那么 `scanf` 函数将终止操作，而不再读取变量 `j` 的值。

### 其他
### `%i`
1. `%i`也可以用于读写整数，在 `printf` 格式串中使用时，它和 `%d` 没有区别。
2. 但是，在 `scanf` 格式串中 `%d` 只能与十进制形式的整数相匹配，而 `%i` 则可以匹配用八进制、十进制或十六进制表示的整数。
3. 如果输入的数有前缀 `0`（如 `056`），那么 `%i` 会把它作为八进制数来处理；如果输入的数有前缀 `0x` 或 `0X`（如 `0x56`），那么 `%i` 会把它作为十六进制数来处理。
4. 如果用户意外地将 `0` 放在数的开始处，那么用 `%i` 代替 `%d` 读取数可能有意想不到的结果。由于这是一个陷阱，所以建议坚持采用 `%d`。


## References
* [C语言程序设计](https://book.douban.com/subject/4279678/)