# The Standard Library



<!-- TOC -->

- [The Standard Library](#the-standard-library)
    - [标准库的使用](#标准库的使用)
        - [对标准库中所用名字的限制](#对标准库中所用名字的限制)
        - [使用宏隐藏的函数](#使用宏隐藏的函数)
    - [`<stddef.h>`：常用定义](#stddefh常用定义)
        - [`offsetof`](#offsetof)
    - [`<stdbool.h>`：布尔类型和值](#stdboolh布尔类型和值)
    - [练习](#练习)
    - [References](#references)

<!-- /TOC -->


## 标准库的使用
1. 大多数编译器都会使用更大的库，额外添加的头当然不属于标准库的范畴，所以我们不能假设其他的编译器也支持这些头。
2. 这类头通常提供一些针对特定机型或特定操作系统的函数，它们可能会提供允许对屏幕或键盘做更多控制的函数。用于支持图形或窗口界面的头也是很常见的。
3. 标准头主要由函数原型、类型定义以及宏定义组成。如果我们的文件中调用了头中声明的函数，或是使用了头中定义的类型或宏，就需要在文件开头将相应的头包含进来。
4. 当一个文件包含多个标准头时，`#include` 指令的顺序无关紧要。多次包含同一个标准头也是合法的。

### 对标准库中所用名字的限制
1. 任何包含了标准头的文件都必须遵守两条规则
    * 该文件不能将头中定义过的宏的名字用于其他目的。例如，如果某个文件包含了 `<stdio.h>`，就不能重新定义 `NULL` 了，因为使用这个名字的宏已经在 `<stdio.h>` 中定义过了。
    * 具有文件作用域的库名（尤其是 `typedef` 名）也不可以在文件层次重定义。因此，一旦文件包含了 `<stdio.h>`，由于 `<stdio.h>` 中已经将 `size_t` 定义为 `typedef` 名，那么在文件作用域内都不能将 `size_t` 重定义为任何标识符。
2. 上述这些限制是显而易见的，但 C 语言还有一些其他的限制，可能是你想不到的
    * **由一个下划线和一个大写字母开头或由两个下划线开头的标识符** 是为标准库保留的标识符。程序不允许为任何目的使用这种形式的标识符。
    * **由一个下划线开头的标识符** 被保留用作具有文件作用域的标识符和标记。除非在函数内部声明，否则不应该使用这类标识符。
    * **在标准库中所有具有外部链接的标识符** 被保留用作具有外部链接的标识符。特别是所有标准库函数的名字都被保留。因此，即使文件没有包含 `<stdio.h>`，也不应该定义名为 `printf` 的外部函数，因为在标准库中已经有一个同名的函数了。
3. 这些规则对程序的所有文件都起作用，不论文件包含了哪个头。虽然这些规则并不总是强制性的，但不遵守这些规则可能会导致程序不具有可移植性。
4. 上面列出的规则不仅适用于库中现有的名字，也适用于留作未来使用的名字。例如，C 保留了以 `str` 和一个小写字母开头的标识符，从而具有这类名字的函数就可以被添加到 `<string.h>` 头中。

### 使用宏隐藏的函数
1. C 程序员经常会用带参数的宏来替代小的函数，这在标准库中同样很常见。 C 标准允许在头中定义与库函数同名的宏，为了起到保护作用，还要求有实际的函数存在（不懂）。
2. 因此，对于库的头，声明一个函数并同时定义一个有相同名字的宏的情况并不少见。`getchar` 是声明在 `<stdio.h>` 中的库函数，它具有如下原型：
    ```cpp
    int getchar(void);
    ```
3. `<stdio.h>` 通常也把 `getchar` 定义为一个宏：
    ```cpp
    #define getchar() getc(stdin)
    ```
    在默认情况下，对 `getchar` 的调用会被看作宏调用（因为宏名会在预处理时被替换）。
4. 在大多数情况下，我们喜欢使用宏来替代实际的函数，因为这样可能会提高程序的运行速度。然而在某些情况下，我们可能需要的是一个真实的函数，可能是为了尽量缩小可执行代码的大小。
5. 如果确实存在这种需求，我们可以使用 `#undef` 指令来删除宏定义。例如，我们可以在包含了 `<stdio.h>` 后删除宏 `getchar` 的定义：
    ```cpp
    #include <stdio.h>
    #undef getchar
    ```
6. 即使 `getchar` 不是宏，这样的做法也不会带来任何坏处，因为当给定的名字没有被定义成宏时，`#undef` 指令不会起任何作用。
7. 此外，我们也可以通过给名字加圆括号来禁用个别宏调用：
    ```cpp
    ch = (getchar)();        /* instead of ch = getchar(); */
    ```


## `<stddef.h>`：常用定义
1. `<stddef.h>` 头提供了常用类型和宏的定义，但没有声明任何函数。定义的类型包括以下几个
    * `ptrdiff_t`。当进行指针相减运算时，其结果的类型。
    * `size_t`。`sizeof` 运算符返回的类型。
    * `wchar_t`。一种足够大的、可以用于表示所有支持的地区的所有字符的类型。
2. 所有这 3 种类型都是整数类型。其中 `ptrdiff_t` 必须是有符号类型，而 `size_t` 则必须是无符号类型。
3. `<stddef.h>` 头中还定义了两个宏。一个是 `NULL`，用来表示空指针。另一个宏 `offsetof`。
4. 一些在 `<stddef.h>` 中定义的类型和宏在其他头中也会出现。因此，只有少数程序真的需要包含 `<stddef.h>`。

### `offsetof`
1. 宏 `offsetof` 需要两个参数：**类型**（一种结构类型）和 **成员指示符**（结构的一个成员）。`offsetof` 宏会计算结构的起点到指定成员间的字节数。
2. 考虑下面的例子：
    ```cpp
    struct s {
        char a;
        int b[2];
        float c;
    };


    int main(void)
    {   

        printf("%d\n", offsetof(struct s, a)); // 0
        printf("%d\n", offsetof(struct s, b));
        printf("%d\n", offsetof(struct s, c));

        return 0;
    }
    ```
3. `offsetof(struct s, a)` 的值一定是 0，C 语言确保结构的第一个成员的地址与结构自身地址相同。
4. 我们无法确定地说出 `b` 和 `c` 的偏移量是多少。一种可能是 `offsetof(struct s, b)` 是 1（因为 `a` 的长度是一个字节），而 `offsetof(struct s, c)` 是 9（假设整数是 32 位）。然而，一些编译器会在结构中留下一些空洞（不使用的字节），从而会影响到 `offsetof` 产生的值。例如，如果编译器在 `a` 后面留下了 3 个字节的空洞，那么 `b` 和 `c` 的偏移量分别是 4 和 12。
5. 但这正是 `offsetof` 宏的用途所在：对任意编译器，它都能返回正确的偏移量，从而使我们可以编写可移植的程序。
6. `offsetof` 有很多用途。例如，假如我们需要将结构 `s` 的前两个成员写入文件，但忽略成员 `c`。我们不写 `sizeof(struct s)` 个字节，因为这样会将整个结构写入，而只要写 `offsetof(struct s, c)` 个字节。


## `<stdbool.h>`：布尔类型和值 
1. `<stdbool.h>` 头定义了 4 个宏：
    * `bool`（定义为 `_Bool`）；
    * `true`（定义为 `1`）；
    * `false`（定义为 `0`）；
    * `__bool_true_false_are_defined`（定义为 `1`）。
2. 在尝试定义自己的 `bool`、`true` 或 `false` 之前，可以使用预处理指令（如 `#if` 或者 `#ifdef`）来测试这个宏。


## 练习
* 编程题 1
```cpp
#include <stdio.h>
#include <stddef.h>


struct s {
    char a;
    int b[2];
    float c;
};


int main(void)
{   

    printf("%d\n", offsetof(struct s, a)); // 0
    printf("%d\n", offsetof(struct s, b)); // 4    // char 补成了 4 个字节
    printf("%d\n", offsetof(struct s, c)); // 12

    struct s s1;
    printf("%d\n", sizeof(s1.a));     // 1
    printf("%d\n", sizeof(s1.b));     // 8
    printf("%d\n", sizeof(s1.c));     // 4
    printf("%d\n", sizeof(s1));       // 16    // char 补成了 4 个字节

    return 0;
}
```


## References
* [C语言程序设计](https://book.douban.com/subject/4279678/)
