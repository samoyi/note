# Pointers and Arrays


<!-- TOC -->

- [Pointers and Arrays](#pointers-and-arrays)
    - [Summary](#summary)
    - [指针的算术运算](#指针的算术运算)
        - [指针加上整数](#指针加上整数)
        - [指针减去整数](#指针减去整数)
        - [两个指针相减](#两个指针相减)
        - [指针比较](#指针比较)
        - [指向复合常量的指针](#指向复合常量的指针)
    - [指针用于数组处理](#指针用于数组处理)
        - [`*` 运算符和 `++`/`--` 运算符的组合](#-运算符和----运算符的组合)
    - [References](#references)

<!-- /TOC -->


## Summary
1. 当指针指向数组元素时，C 语言允许对指针进行算术运算（加法和减法），通过这种运算我们可以用指针代替数组下标对数组进行处理。
2. 用指针处理数组的主要原因是效率，但是这里的效率提升已经不再像当初那么重要了，这主要归功于编译器的改进。


## 指针的算术运算
1. 因为指针可以指向数组元素。例如，假设已经声明 `a` 和 `p` 如下：
    ```cpp
    int a[10], *p;
    ```
2. 通过下列写法可以使 `p` 指向 `a[0]`：
    ```cpp
    p = &a[0];
    ```
3. 现在可以通过 `p` 访问 `a[0]`。例如，可以通过下列写法把值 `5` 存入 `a[0]` 中：
    ```cpp
    *p = 5;
    ```
4. 通过在 `p` 上执行 **指针算术运算**（或者 **地址算术运算**）可以访问数组 `a` 的其他所有元素。C 语言支持 3 种格式的指针算术运算：
    * 指针加上整数；
    * 指针减去整数；
    * 两个指针相减。
5. 在一个不指向任何数组元素的指针上执行算术运算会导致未定义的行为。此外，只有在两个指针指向同一个数组时，把它们相减才有意义。
6. 下面的所有例子都假设有如下声明：
    ```cpp
    int a[10], *p, *q, i;
    ```

### 指针加上整数
1. 指针 `p` 加上整数 `j` 产生指向特定元素的指针，这个特定元素是 `p` 原先指向的元素后的j个位置。
2. 更确切地说， 如果 `p` 指向数组元素 `a[i]`，那么` p+j` 指向 `a[i + j]`（当然，前提是 `a[i + j]` 必须存在）。

### 指针减去整数
如果 `p` 指向数组元素 `a[i]`，那么 `p - j` 指向 `a[i - j]`。

### 两个指针相减
1. 当两个指针相减时，结果为指针之间的距离（用数组元素的个数来度量）。
2. 因此，如果 `p` 指向 `a[i]` 且 `q` 指向 `a[j]`，那么 `p-q` 就等于 `i-j`。

### 指针比较
1. 可以用关系运算符和判等运算符进行指针比较。
2. 只有在两个指针指向同一数组时，用关系运算符进行的指针比较才有意义。
3. 比较的结果依赖于数组中两个元素的相对位置。例如，在下面的赋值后 `p <= q` 的值是 `0`，而 `p >= q` 的值是 `1`
    ```cpp
    p = &a[5];
    q = &a[1];
    ```

### 指向复合常量的指针 
指针指向由复合字面量创建的数组中的某个元素是合法的
```cpp
int *p = (int []){3, 0, 3, 4, 1};
```


## 指针用于数组处理
1. 指针的算术运算允许通过对指针变量进行重复自增来访问数组的元素。下面这个对数组 `a` 中元素求和的程序段说明了这种方法
    ```cpp
    #define N 10
    ...
    int a[N], sum, *p;
    ...
    sum = 0;
    for (p = &a[0]; p < &a[N]; p++)
        sum += *p;
    ```
2. `for` 语句中的条件 `p < &a[N]` 值得特别说明一下。尽管元素 `a[N]` 不存在\，但是对它使用取地址运算符是合法的。因为循环不会尝试检查 `a[N]` 的值，所以在上述方式下使用 `a[N]` 是非常安全的。不懂，不检查怎么停止循环的。
3. 支持采用指针算术运算的最常见论调是，这样做可以节省执行时间。但是，这依赖于具体的实现——对有些编译器来说，实际上依靠下标的循环会产生更好的代码。

### `*` 运算符和 `++`/`--` 运算符的组合
1. C 程序员经常在处理数组元素的语句中组合 `*`（间接寻址）运算符和 `++` 运算符。思考一个简单的例子：把值存入一个数组元素中，然后前进到下一个元素。利用数组下标可以这样写：
    ```cpp
    a[i++] = j;
    ```
2. 如果 `p` 指向数组元素，那么相应的语句将会是
```cpp
*p++ = j;
```
3. 因为后缀 `++` 的优先级高于 `*`，所以编译器把上述语句看成是
    ```cpp
    *(p++) = j;
    ```
    `p++` 的值是 `p`，因此，`*(p++)` 的值将是 `*p`，即 `p` 当前指向的对象。
4. `*p++` 不是唯一合法的 `*` 和 `++` 的组合
    表达式 | 含义
    --|--
    `*p++` 或 `*(p++)` | 自增前表达式的值是 `*p`，以后再自增 `p`
    `(*p)++` | 自增前表达式的值是 `*p`，以后再自增 `*p`
    `*++p` 或 `*(++p)` | 先自增 `p`，自增后表达式的值是 `*p`
    `++*p` 或 `++(*p)` | 先自增 `*p`，自增后表达式的值是 `*p`
5. 最频繁见到的就是 `*p++`，它在循环中是很方便的。对数组 `a` 的元素求和时，可以把
    ```cpp
    for (p = &a[0]; p < &a[N]; p++)
        sum += *p;
    ```
    改写成
    ```cpp
    p = &a[0];
    while (p < &a[N])
        sum += *p++;
    ```

















































































## References
* [C语言程序设计](https://book.douban.com/subject/4279678/)