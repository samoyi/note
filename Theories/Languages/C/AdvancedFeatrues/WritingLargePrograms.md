# Writing Large Programs


<!-- TOC -->

- [Writing Large Programs](#writing-large-programs)
    - [源文件](#源文件)
    - [头文件](#头文件)
        - [`#include` 指令](#include-指令)
            - [可移植性技巧](#可移植性技巧)
        - [共享宏定义和类型定义](#共享宏定义和类型定义)
        - [共享函数原型](#共享函数原型)
        - [共享变量声明](#共享变量声明)
        - [保护头文件](#保护头文件)
        - [头文件中的 `#error` 指令](#头文件中的-error-指令)
    - [文本格式化程序示例程序划分成多个文件](#文本格式化程序示例程序划分成多个文件)
        - [流程](#流程)
        - [完整源码](#完整源码)
        - [运行方式](#运行方式)
    - [References](#references)

<!-- /TOC -->


常见的程序由多个 **源文件**（source file）组成，通常还有一些 **头文件**（header file）。源文件包含函数的定义和外部变量，而头文件包含可以在源文件之间共享的信息。


## 源文件
1. 可以把程序分割成任意数量的源文件。根据惯例，源文件的扩展名为 `.c`。其中一个源文件必须包含一个名为 `main` 的函数，此函数作为程序的起始点。
2. 把程序分成多个源文件有许多显著的优点。
    * 把相关的函数和变量分组放在同一个文件中可以使程序的结构清晰。
    * 可以分别对每一个源文件进行编译。如果程序规模很大而且需要频繁改变（这一点在程序开发过程中是非常普遍的）的话，这种方法可以极大地节约时间。
    * 把函数分组放在不同的源文件中更利于复用。


## 头文件
1. `#include` 指令告诉预处理器打开指定的文件，并且把此文件的内容插入到当前文件中。
2. 因此，如果想让几个源文件可以访问相同的信息，可以把此信息放入一个文件中，然后利用 `#include` 指令把该文件的内容带进每个源文件中。
3. 把按照此种方式包含的文件称为 **头文件**（有时称为 **包含文件**）。根据惯例，头文件的扩展名为 `.h`。
4. C 标准使用术语 “源文件” 来指示程序员编写的全部文件，包括 `.c` 文件和 `.h` 文件。这里的 “源文件” 只是指 `.c` 文件。

### `#include` 指令
1. `#include` 指令主要有两种书写格式。第一种格式用于属于 C 语言自身库的头文件：
    ```cpp
    #include <文件名>
    ```
    第二种格式用于所有其他头文件，也包含任何自己编写的文件：
    ```cpp
    #include "文件名"
    ```
2. 这两种格式间的细微差异在于编译器定位头文件的方式。 下面是大多数编译器遵循的规则。
    * `#include <文件名>`：搜寻系统头文件所在的目录（或多个目录）。（例如，在 UNIX 系统中，通常把系统头文件保存在目录 `/usr/include` 中。）
    * `#include "文件名"`：先搜寻当前目录，然后搜寻系统头文件所在的目录（或多个目录）。
3. 通常可以改变搜寻头文件的位置，这种改变经常利用诸如 `-I` 路径这样的命令行选项来实现。
4. 不要在包含自己编写的头文件时使用尖括号：
    ```cpp
    #include <myheader.h>  /*** WRONG ***/
    ```
    因为预处理器可能在保存系统头文件的地方寻找 `myheader.h`，显然是找不到的。
5. 在 `#include` 指令中的文件名可以含有帮助定位文件的信息，比如目录的路径或驱动器号：
    ```cpp
    #include "c:\cprogs\utils.h"     /* Windows path */
    #include "/cprogs/utils.h"       /* UNIX path */
    ```
6. 虽然 `#include` 指令中的双引号使得文件名看起来像字符串字面量，但是预处理器不会把它们作为字符串字面量来处理。这是幸运的，因为在上面的 Windows 例子中，字符串字面量中出现的 `\c` 和 `\u` 将会被作为转义序列处理。
7. `#include` 指令还有一种不太常用的格式：
    ```cpp
    #include 记号
    ```
8. 其中 **记号** 是任意预处理记号序列。预处理器会扫描这些记号，并替换遇到的宏。宏替换完成以后，`#include` 指令的格式一定与前面两种之一相匹配。
9. 这种 `#include` 指令的优点是可以用宏来定义文件名，而不需要把文件名“硬拷贝”到指令里面去，如下所示：
    ```cpp
    #if defined(IA32)
        #define CPU_FILE "ia32.h"
    #elif defined(IA64)
        #define CPU_FILE "ia64.h"
    #elif defined(AMD64)
        #define CPU_FILE "amd64.h"
    #endif

    #include CPU_FILE
    ```

#### 可移植性技巧
1. 通常最好的做法是在 `#include` 指令中不包含路径或驱动器的信息。当把程序转移到其他机器上，或者更糟的情况是转移到其他操作系统上时，这类信息会使编译变得很困难。
2. 例如，下面的这些 `#include` 指令指定了驱动器或路径信息，而这些信息不可能一直是有效的：
    ```cpp
    #include "d:utils.h"
    #include "\cprogs\include\utils.h"
    #include "d:\cprogs\include\utils.h"
    ```
3. 下列这些指令相对好一些。它们没有指定驱动器，而且使用的是相对路径而不是绝对路径：
    ```cpp
    #include "utils.h"
    #include "..\include\utils.h"
    ```

### 共享宏定义和类型定义
1. 大多数大型程序包含需要由几个源文件（或者，最极端的情况是用于全部源文件）共享的宏定义和类型定义。这些定义应该放在头文件中。
2. 例如，假设正在编写的程序使用名为 `BOOL`、`TRUE` 和 `FALSE` 的宏。（C99 中不需要这么做，因为 `<stdbool.h>` 头中定义了类似的宏。）我们把这些定义放在一个名为 `boolean.h` 的头文件中
    ```cpp
    #define BOOL int
    #define TRUE 1
    #define FALSE 0
    ```
3. 任何需要这些宏的源文件只需简单包含下面这一行：
    ```cpp
    #include "boolean.h"
    ```
4. 类型定义在头文件中也是很普遍的。例如，不用定义 `BOOL` 宏，而是可以用 `typedef` 创建一个 `Bool` 类型。如果这样做，`boolean.h` 文件将有下列显示：
    ```cpp
    #define TRUE 1
    #define FALSE 0
    typedef int Bool;
    ```

### 共享函数原型
1. 假设源文件包含函数 `f` 的调用，而函数 `f` 是定义在另一个文件 `foo.c` 中的。调用没有声明的函数 `f` 是非常危险的。
2. 如果没有函数原型可依赖，编译器会假定函数 `f` 的返回类型是 `int` 类型的，并假定形式参数的数量和函数 `f` 的调用中的实际参数的数量是匹配的。通过默认的实际参数提升，实际参数自身自动转化为 “标准格式”。
3. 编译器的假定很可能是错误的，但是，因为一次只能编译一个文件，所以是没有办法进行检查的。如果这些假定是错误的，那么程序很可能无法工作，而且没有线索可以用来查找原因。基于这个原因，C99 禁止在编译器看到函数声明或定义之前对函数进行调用。
4. 当调用在其他文件中定义的函数 `f` 时，要始终确保编译器在调用之前已看到函数 `f` 的原型。
5. 我们的第一个想法是在调用函数 `f` 的文件中声明它。这样可以解决问题，但是可能产生维护方面的 “噩梦”。假设有 50 个源文件要调用函数 `f`，如何能确保函数 `f` 的原型在所有文件中都一样呢？如何能保证这些原型和 `foo.c` 文件中函数 `f` 的定义相匹配呢？
6. 解决办法是显而易见的：把函数 `f` 的原型放进一个头文件中，然后在所有调用函数 `f` 的地方包含这个头文件。
7. 既然在文件 `foo.c` 中定义了函数 `f`，我们把头文件命名为 `foo.h`。除了在调用函数 `f` 的源文件中包含 `foo.h`，还需要在 `foo.c` 中包含它，从而使编译器可以验证 `foo.h` 中函数 `f` 的原型和 `foo.c` 中 `f` 的函数定义相匹配。
8. 在调用 `f` 的文件只需要引用 `foo.h` 就行了，不需要引用 `foo.c`。但是在 VSCode 调试的时候，是只会编译当前文件
    ```sh
    gcc pun.c -o pun
    ```
    并没有编译 `foo.c`，所以要修改一下命令的参数，把 `foo.c` 也一同编译
    ```sh
    gcc pun.c foo.c -o pun
    ```
9. 另外不知道为什么，我在调用 `f` 的文件只引用 `foo.c` 不引用 `foo.h` 是正常的，即使函数 `f` 返回的是字符串而不是嘉定的 `int` 类型。
10. 在含有函数 `f` 定义的源文件中始终包含声明函数 `f` 的头文件。如果不这样做可能导致难以发现的错误，因为在程序别处对函数 `f` 的调用可能会和函数 `f` 的定义不匹配。
11. 如果文件 `foo.c` 包含其他函数，大多数函数都应该在包含函数 `f` 的声明的那个头文件中声明。毕竟，文件 `foo.c` 中的其他函数大概会与函数 `f` 有关。任何含有函数 `f` 调用的文件可能会需要文件 `foo.c` 中的其他一些函数。然而，仅用于文件 `foo.c` 的函数不需要在头文件中声明，如果声明了容易造成误解。

### 共享变量声明
1. 为了共享函数，要把函数的定义放在一个源文件中，然后在需要调用此函数的其他文件中放置声明。共享外部变量的方法和此方式非常类似。
2. 目前不需要区别变量的声明和它的定义。为了声明变量 `i`，可以这样写：
    ```cpp
    int i;               /* declares i and defines it as well */
    ```
3. 这样不仅声明 `i` 是 `int` 类型的变量，而且也对 `i` 进行了定义，从而使编译器为 `i` 留出了空间。
4. 为了声明变量 `i` 而不是定义它，需要在变量声明的开始处放置 `extern` 关键字：
    ```cpp
    extern int i;        /* declares i without defining it */
    ```
5. `extern` 告诉编译器，变量 `i` 是在程序中的其他位置定义的（很可能是在不同的源文件中），因此不需要为 `i` 分配空间。
6. 顺便说一句，`extern` 可以用于所有类型的变量。在数组的声明中使用 `extern` 时，可以省略数组的长度：
    ```cpp
    extern int a[];
    ```
    因为此刻编译器不用为数组 `a`分配空间，所以也就不需要知道数组 `a` 的长度了。
7. 为了在几个源文件中共享变量 `i`，首先把变量 `i `的定义放置在一个文件中：
    ```cpp
    int i;
    ```
8. 如果需要对变量 `i` 初始化，可以把初始化式放在这里。
9. 在编译这个文件时，编译器会为变量 `i` 分配内存空间，而其他文件将包含变量 `i` 的声明：
    ```cpp
    extern int i;
    ```
10. 通过在每个文件中声明变量 `i`，使得在这些文件中可以访问/或修改变量 `i`。然而，由于关键字 `extern` 的存在，编译器不会在每次编译这些文件时为变量 `i` 分配额外的内存空间。
11. 当在文件中共享变量时，会面临和共享函数时相似的挑战：确保变量的所有声明和变量的定义一致。当同一个变量的声明出现在不同文件中时，编译器无法检查声明是否和变量定义相匹配。例如，一个文件可以包含定义
    ```cpp
    int i;
    ```
    同时另一个文件包含声明
    ```cpp
    extern long i;
    ```
    这类错误可能导致程序的行为异常。
12. 为了避免不一致，通常把共享变量的声明放置在头文件中。需要访问特定变量的源文件可以包含相应的头文件。此外，含有变量定义的源文件需要包含含有相应变量声明的头文件，这样编译器就可以检查声明与定义是否匹配。
13. 例子
    ```cpp
    // variables.h

    extern int i;
    ```
    ```cpp
    // variables.c

    #include "variables.h"
    int i = 6;
    ```
    ```cpp
    // test.c

    #include <stdio.h>
    #include "variables.h"

    int main(int argc, char *argv[])
    {
        printf("%d", i); // 6
        i = 7;
        printf("%d", i); // 7

        return 0;
    }
    ```
14. 虽然在文件中共享变量是 C 语言界中的长期惯例，但是它有重大的缺点。

### 保护头文件
1. 如果源文件包含同一个头文件两次，那么可能产生编译错误。
2. 当头文件包含其他头文件时，这种问题十分普遍。例如，假设 `file1.h` 包含 `file3.h`，`file2.h` 包含 `file3.h`，而 `prog.c` 同时包含 `file1.h` 和 `file2.h`，那么在编译 `prog.c` 时，`file3.h` 就会被编译两次。
3. 两次包含同一个头文件不总是会导致编译错误。如果文件只包含宏定义、函数原型和/或变量声明，那么将不会有任何困难。然而，如果文件包含类型定义，则会带来编译错误。
4. 安全起见，保护全部头文件避免多次包含可能是个好主意，那样的话可以在稍候添加类型定义而不用冒可能因忘记保护文件而产生的风险。
5. 此外，在程序开发期间，避免同一个头文件的不必要重复编译可以节省一些时间。
6. 为了防止头文件多次包含，用 `#ifndef` 和 `#endif` 指令来封闭文件的内容。例如，可以用如下方式保护文件 `boolean.h`：
    ```cpp
    #ifndef BOOLEAN_H
    #define BOOLEAN_H

    #define TRUE 1
    #define FALSE 0
    typedef int Bool;

    #endif
    ```
7. 在首次包含这个文件时，没有定义宏 `BOOLEAN_H`，所以预处理器允许保留 `#ifndef` 和 `#endif` 之间的多行内容。但是如果再次包含此文件，那么预处理器将把 `#ifndef` 和 `#endif` 之间的多行内容删除。
8. 宏的名字（`BOOLEAN_H`）并不重要，但是，给它取类似于头文件名的名字是避免和其他的宏冲突的好方法。由于不能把宏命名为 `BOOLEAN.H` （标识符不能含有句点），所以像 `BOOLEAN_H` 这样的名字是个很好的选择。

### 头文件中的 `#error` 指令
1. `#error` 指令经常放置在头文件中，用来检查不应该包含头文件的条件。
2. 例如，如果头文件中用到了一个在最初的 C89 标准之前不存在的特性，为了避免把头文件用于旧的非标准编译器，可以在头文件中包含 `#ifdef` 指令来检查 `__STDC__` 宏是否存在：
    ```cpp
    #ifndef __STDC__
    #error This header requires a Standard C compiler
    #endif
    ```


## 文本格式化程序示例程序划分成多个文件
### 流程
1. 现在应用我们已经知道的关于头文件和源文件的知识来开发一种把一个程序划分成多个文件的简单方法。假设已经设计好程序，换句话说，已经决定程序需要什么函数以及如何把函数分为逻辑相关的组。下面是处理的方法。
2. 把每个函数集合放入一个不同的源文件中（比如用名字 `foo.c` 来表示一个这样的文件）。
3. 另外，创建和源文件同名的头文件，只是扩展名为 `.h`（在此例中，头文件是 `foo.h`）。
4. 在 `foo.h` 文件中放置 `foo.c`中定义的函数的函数原型。在 `foo.h` 文件中不需要也不应该声明只在 `foo.c` 内部使用的函数。下面的 `read_char` 函数就是一个这样的例子。
5. 每个需要调用定义在 `foo.c` 文件中的函数的源文件都应包含 `foo.h` 文件。此外，`foo.c` 文件也应包含 `foo.h` 文件，这是为了编译器可以检查 `foo.h` 文件中的函数原型是否与 `foo.c` 文件中的函数定义相一致。
6. `main` 函数将出现在某个文件中，这个文件的名字与程序的名字相匹配。如果希望称程序为 `bar`，那么 `main` 函数就应该在文件 `bar.c` 中。`main` 函数所在的文件中也可以有其他函数，前提是程序中的其他文件不会调用这些函数。

### 完整源码
路径 `./examples/justify/`

### 运行方式
1. 在测试目录里，包含以下文件。其中 `quote` 里面是等待被格式化的文本
    * `justify.c`
    * `line.c`
    * `line.h`
    * `quote`
    * `word.c`
    * `word.h`
2. 在 bash 命令行里 cd 到该测试目录里，然后输入如下命令进行编译
    ```sh
    gcc justify.c line.c word.c -o justify
    ```
    之后会在当前目录生成可执行文件 `justify.exe`
3. 然后输入如下命令运行该可执行文件，使用 `quote` 里面的文本运行程序，然后自动生成 `newquote` 文件并写入输出
    ```sh
    ./justify.exe <quote >newquote
    ```


































































## References
* [C语言程序设计](https://book.douban.com/subject/4279678/)