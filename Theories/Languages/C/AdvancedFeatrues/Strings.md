# Strings


<!-- TOC -->

- [Strings](#strings)
    - [字符串字面量](#字符串字面量)
        - [字符串字面量中的转义序列](#字符串字面量中的转义序列)
        - [延续字符串字面量](#延续字符串字面量)
        - [如何存储字符串字面量](#如何存储字符串字面量)
        - [字符串字面量的操作](#字符串字面量的操作)
        - [字符串字面量与字符常量](#字符串字面量与字符常量)
    - [字符串变量](#字符串变量)
        - [初始化字符串变量](#初始化字符串变量)
        - [字符数组与字符指针](#字符数组与字符指针)
    - [字符串的读和写](#字符串的读和写)
        - [用 `printf` 函数和 `puts` 函数写字符串](#用-printf-函数和-puts-函数写字符串)
        - [用 `scanf` 函数和 `gets` 函数读字符串](#用-scanf-函数和-gets-函数读字符串)
        - [逐个字符读字符串](#逐个字符读字符串)
    - [访问字符串中的字符](#访问字符串中的字符)
    - [References](#references)

<!-- /TOC -->


## 字符串字面量
**字符串字面量**（string literal）是用一对双引号括起来的字符序列。

### 字符串字面量中的转义序列
TODO，八进制数和十六进制数的转义序列

### 延续字符串字面量
1. 如果发现字符串字面量太长而无法放置在单独一行以内，只要把第一行用字符 `\` 结尾，那么 C 语言就允许在下一行延续字符串字面量。
    ```cpp
    printf("When you come to a fork in the road, take it.   \
    --Yogi Berra");
    ```
2. 除了（看不到的）末尾的换行符，在同一行不可以有其他字符跟在 `\` 后面。
3. 使用 `\` 有一个缺陷：字符串字面量必须从下一行的起始位置继续。因此，这就破坏了程序的缩进结构
    ```cpp
    int main(void)
    {
        printf("abcd\
        efg");           // abcd    efg

        printf("abcd\
    efg");               // abcdefg
        return 0;
    }
    ```
4. 处理长字符串字面量有一种更好的方法：当两条或更多条字符串字面量相邻时（仅用空白字符分割），编译器会把它们合并成一条字符串。这条规则允许把字符串分割放在两行或者更多行中
    ```cpp
    int main(void)
    {
        printf("abcd"
                "efg"); // abcdefg
        return 0;
    }
    ```

### 如何存储字符串字面量
1. 从本质而言，C 语言把字符串字面量作为字符数组来处理。
2. 当 C 语言编译器在程序中遇到长度为 $n$ 的字符串字面量时，它会为字符串字面量分配长度为 $n+1$ 的内存空间。这块内存空间将用来存储字符串字面量中的字符，以及一个用来标志字符串末尾的额外字符（空字符）。
3. 空字符是一个所有位都为 `0` 的字节，因此用转义序列 `\0` 来表示。
4. 例如，字符串字面量 `"abc"` 是作为有 4 个字符的数组来存储的（`a`、`b`、`c` 和 `\0`）：
    <img src="./images/04.png" width="200" style="display: block; margin: 5px 0 10px;" />
5. 字符串字面量可以为空。字符串 `""` 作为单独一个空字符来存储：
    <img src="./images/05.png" width="50" style="display: block; margin: 5px 0 10px;" />
6. 既然字符串字面量是作为数组来存储的，那么编译器会把它看作是 `char *` 类型的指针。例如，`printf` 函数和 `scanf` 函数都接收 `char *` 类型的值作为它们的第一个参数。思考下面的例子：
    ```cpp
    printf("abc");
    ```
    当调用 `printf` 函数时，会传递 `"abc"` 的地址，即指向存储字母 `a` 的内存单元的指针。

### 字符串字面量的操作
1. 通常情况下可以在任何 C 语言允许使用 `char *` 指针的地方使用字符串字面量。例如，字符串字面量可以出现在赋值运算符的右边：
    ```cpp
    char *p;

    p = "abc";
    ```
    这个赋值操作不是复制 `"abc"` 中的字符，而是使p指向字符串的第一个字符。
2. C 语言允许对指针取下标，因此可以对字符串字面量取下标：
    ```cpp
    char ch;

    ch = "abc"[1];
    ```
    `ch` 的新值将是字母 `b`。
3. 因为保存字符串的数组是字符长度加一，所以下标还可以取到最后的空字符
    ```cpp
    char ch = "abc"[3];
    printf("[%c]", ch); // [ ]
    ```
4. 字符串字面量的这种特性并不常用，但有时也比较方便。思考下面的函数，这个函数把 0~15 的数转换成等价的十六进制的字符形式：
    ```cpp
    char digit_to_hex_char(int digit)
    {
        return "0123456789ABCDEF"[digit];
    }
    ```
5. 试图改变字符串字面量会导致未定义的行为：
    ```cpp
    char *p = "abc";

    *p = 'd';   /*** WRONG ***/
    ```

### 字符串字面量与字符常量
1. 只包含一个字符的字符串字面量不同于字符常量。字符串字面量 `"a"` 是用 **指针** 来表示的，这个指针指向存放字符 `"a"`（后面紧跟空字符）的内存单元。字符常量 `'a'` 是用 **整数**（字符集的数值码）来表示的。
2. 不要在需要字符串的时候使用字符（反之亦然）。函数调用
    ```cpp
    printf("\n");
    ```
    是合法的，因为 `printf` 函数期望指针作为它的第一个参数。然而，下面的调用却是非法的：
    ```cpp
    printf('\n');    /*** WRONG ***/
    ```
    同样这样也是错误的
    ```cpp
    char ch = "a"; // warning: initialization makes integer from pointer without a cast
    ```


## 字符串变量
1. 一些编程语言为声明字符串变量提供了专门的 `string` 类型。C 语言采取了不同的方式：只要保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串。
2. 假设需要用一个变量来存储最多有 80 个字符的字符串。由于字符串在末尾处需要有空字符，我们把变量声明为含有 81 个字符的数组：
    ```cpp
    #define STR_LEN 80
    ...
    char str[STR_LEN+1];
    ```
3. 这里把 `STR_LEN` 定义为 80 而不是 81，强调的是 `str` 可以存储最多有 80 个字符的字符串；然后才在 `str` 的声明中对 `STR_LEN` 加 1。这是 C 程序员常用的方式。
4. 声明长度为 `STR_LEN+1` 的字符数组并不意味着它总是用于存放长度为 `STR_LEN` 的字符串。字符串的长度取决于空字符的位置，而不是取决于用于存放字符串的字符数组的长度。有 `STR_LEN+1` 个字符的数组可以存放多种长度的字符串，范围是从空字符串到长度为 `STR_LEN` 的字符串。

### 初始化字符串变量
1. 字符串变量可以在声明时进行初始化：
    ```cpp
    char date1[8] = "June 14";
    ```
2. 编译器将把字符串 `"June 14"` 中的字符复制到数组 d`ate1` 中，然后追加一个空字符从而使 `date1` 可以作为字符串使用。
3. `"June 14"` 看起来是字符串字面量，但其实不然。C 编译器会把它看成是数组初始化式的缩写形式。实际上，我们可以写成：
    ```cpp
    char date1[8] = {'J', 'u', 'n', 'e', ' ', '1', '4', '\0'};
    ```
4. 如果初始化式太短以致不能填满字符串变量将会如何呢？在这种情况下，编译器会添加空字符。因此，在声明
    ```cpp
    char date2[9] = "June 14";
    ```
    之后，`date2` 将如下所示：
    <img src="./images/06.png" width="400" style="display: block; margin: 5px 0 10px;" />
5. 如果初始化式比字符串变量长，这对字符串而言是非法的，就如同对数组是非法的一样。
6. 然而，C 语言允许初始化式（不包括空字符）与变量有完全相同的长度：
    ```cpp
    char date3[7] = "June 14";
    ```
    由于没有给空字符留空间，所以编译器不会试图存储空字符，这将使得数组无法作为字符串使用。
7. 字符串变量的声明中可以省略它的长度。这种情况下，编译器会自动计算长度：
    ```cpp
    char date4[] = "June 14";
    ```
    编译器为 `date4` 分配 8 个字符的空间。
8. 不指定 `date4` 的长度并不意味着以后可以改变数组的长度。一旦编译了程序，`date4` 的长度就固定是 8 了。

### 字符数组与字符指针
1. 一起来比较一下下面这两个看起来很相似的声明：
    ```cpp
    char date[] = "June 14";
    char *date = "June 14";
    ```
2. 前者声明 `date` 是一个数组，后者声明 `date` 是一个指针。正因为有了数组和指针之间的紧密关系，才使上面这两个声明中的 `date` 都可以用作字符串。尤其是，任何期望传递字符数组或字符指针的函数都能够接收这两种声明的 `date` 作为参数。
3. 然而，需要注意，不能错误地认为上面这两种 `date` 可以互换。两者之间有很大的差异：
    * 在声明为数组时，就像任意数组元素一样，可以修改存储在 `date` 中的字符。在声明为指针时，`date` 指向字符串字面量，字符串字面量是不可以修改的。
        ```cpp
        char date[] = "June 14";
        date[0] = 'j';
        printf("%c", date[0]); // 'j'
        ```
        ```cpp
        char *date = "June 14";
        date[0] = 'j'; // 错误
        ```
    * 在声明为数组时，`date` 是数组名。在声明为指针时，`date` 是变量，这个变量可以在程序执行期间指向其他字符串。
        ```cpp
        char hello[] = "hello";
        char date[] = "June 14";
        date = hello;  // error: assignment to expression with array type
        ```
        ```cpp
        char hello[] = "hello";
        char *date = "June 14";
        printf("%c", date[0]); // 'h'
        ```
4. 如果希望可以修改字符串，那么就要建立字符数组来存储字符串，声明指针变量就不够的。下面的声明使编译器为指针变量分配了足够的内存空间：
    ```cpp
    char *p;
    ```
    可惜的是，它不能为字符串分配空间。因为我们没有指明字符串的长度。
5. 在使用 `p` 作为字符串之前，必须把 `p` 指向字符数组。
    * 一种方法是把 `p` 指向已经存在的字符串变量：
        ```cpp
        char str[STR_LEN+1], *p;

        p = str;
        ```
        现在 `p` 指向了 `str` 的第一个字符，所以可以把 `p`作为字符串使用了。
    * 另一种方法是让 `p` 指向一个动态分配的字符串。


## 字符串的读和写
### 用 `printf` 函数和 `puts` 函数写字符串
1. 转换说明 `%`s`` 允许 `printf` 函数写字符串。考虑下面的例子：
    ```cpp
    char str[] = "Are we having fun yet?";

    printf("%s\n", str);
    ```
2. `printf` 函数会逐个写字符串中的字符，直到遇到空字符才停止。如果空字符丢失，`printf` 函数会越过字符串的末尾继续写，直到最终在内存的某个地方找到空字符为止。
3. 如果只想显示字符串的一部分，可以使用转换说明 $\%.p$`s`，这里 $p$ 是要显示的字符数量
    ```cpp
    printf("%.6s\n", str);
    ```
4. 字符串跟数一样，可以在指定字段内显示。转换说明 $\%m$`s` 会在大小为 $m$ 的字段内显示字符串
    ```cpp
    char str[] = "hello";

    printf("[%10s]\n", str); // [     hello]
    ```
5. 对于超过 $m$ 个字符的字符串，`printf` 函数会显示出整个字符串，而不会截断
    ```cpp
    char str[] = "hello";

    printf("[%2s]\n", str); // [hello]
    ```
6. 如果字符串少于 $m$ 个字符，则会在字段内右对齐输出。如果要强制左对齐，可以在 $m$ 前加一个减号
    ```cpp
    char str[] = "hello";

    printf("[%-10s]\n", str); // [hello     ]
    ```
7. $m$ 值和 $p$ 值可以组合使用：转换说明 $\%m.p$`s` 会使字符串的前 $p$ 个字符在大小为 $m$ 的字段内显示。
8. C 函数库还提供了 `puts` 函数，此函数可以按如下方式使用：
    ```cpp
    puts(str);
    ```
9. `puts` 函数只有一个参数，即需要显示的字符串。在写完字符串后，`puts` 函数总会添加一个额外的换行符，从而前进到下一个输出行的开始处。

### 用 `scanf` 函数和 `gets` 函数读字符串
1. 转换说明 `%s` 允许 `scanf` 函数把字符串读入字符数组：
    ```cpp
    scanf("%s", str);
    ```
2. 在 `scanf` 函数调用中，不需要在 `str` 前添加运算符 `&`，因为 `str` 是数组名，编译器在把它传递给函数时会把它当作指针来处理。
3. 调用时，`scanf` 函数会跳过空白字符，然后读入字符并存储到 `str` 中，直到遇到空白字符为止
    ```cpp
    scanf("%s", str); // 如果输入 hello world，只会录入 hello，后面的内容会被下次录入
    ```
4. `scanf` 函数始终会在字符串末尾存储一个空字符。
5. 用 `scanf` 函数读入字符串永远不会包含空白字符。因此，`scanf` 函数通常不会读入一整行输入。换行符会使 `scanf` 函数停止读入，空格符或制表符也会产生同样的结果。
6. 为了一次读入一整行输入，可以使用 `gets` 函数。`gets` 函数有些不同于 `scanf` 函数
    * `gets` 函数不会在开始读字符串之前跳过空白字符（`scanf` 函数会跳过）。
    * `gets` 函数会持续读入直到找到换行符才停止（`scanf` 函数会在任意空白字符处停止）。
    * `gets` 函数会忽略掉换行符，不会把它存储到数组中，用空字符代替换行符。
7. 在把字符读入数组时， `scanf` 函数和 `gets` 函数都无法检测数组何时被填满。因此，它们存储字符时可能越过数组的边界，这会导致未定义的行为。通过用转换说明 $\%n$`s` 代替 `%s` 可以使 `scanf` 函数更安全。这里的数字 $n$ 指出可以存储的最多字符数。可惜的是，`gets` 函数天生就是不安全的，`fgets` 函数则是一种好得多的选择。

### 逐个字符读字符串
1. 因为对许多程序而言，`scanf` 函数和 `gets` 函数都有风险且不够灵活，C 程序员经常会自己编写输入函数。通过每次一个字符的方式来读入字符串，这类函数可以提供比标准输入函数更大程度的控制。
2. 如果决定设计自己的输入函数，那么就需要考虑下面这些问题。
    * 在开始存储字符串之前，函数应该跳过空白字符吗？
    * 什么字符会导致函数停止读取：换行符、任意空白字符还是其他某种字符？需要存储这类字符还是忽略掉？
    * 如果输入的字符串太长以致无法存储，那么函数应该做些什么：忽略额外的字符还是把它们留给下一次输入操作？
3. 假定我们所需要的函数不会跳过空白字符，在第一个换行符（不存储到字符串中）处停止读取，并且忽略额外的字符。函数将有如下原型：
    ```cpp
    int read_line(char str[], int n);
    ```
4. `str` 表示用来存储输入的数组，而 `n` 是读入字符的最大数量。如果输入行包含多于 `n` 个的字符，`read_line` 函数将忽略多余的字符。
5. `read_line` 函数会返回实际存储在 `str` 中的字符数量（0 到 `n` 之间的任意数）
6. `read_line` 函数主要由一个循环构成。只要 `str` 中还有空间，此循环就会调用 `getchar` 函数逐个读入字符并把它们存储到 `str` 中。在读入换行符时循环终止。
7. 严格地说，如果 `getchar` 函数读入字符失败，也应该终止循环，但是这里暂时忽略这种复杂情况。
8. 下面是 `read_line` 函数的完整定义： 
    ```cpp
    int read_line(char str[],  int n)
    {
        int ch, i = 0;

        while ((ch = getchar()) != '\n')
            if (i < n)
                str[i++] = ch;
        str[i] = '\0';        /* terminates string */
        return i;             /* number of characters stored */
    }
    ```
9. 注意，`ch` 的类型为 `int` 而不是 `char`，这是因为 `getchar` 把它读取的字符作为 `int` 类型的值返回。
10. 返回之前，`read_line` 函数在字符串的末尾放置一个空字符。`scanf` 和 `gets` 等标准函数会自动在输入字符串的末尾放置一个空字符；然而，如果要自己写输入函数，必须手工加上空字符。
11. TODO，长度超过数组指定的长度依然可以使用，使用到了数组外面的内存
    ```cpp
    char str[10];
    int n = 15; // 可以读取 15 个字符，使用了 16 个字节的内存，包括最后的空白字符
    ```


## 访问字符串中的字符
1. 字符串是以数组的方式存储的，因此可以使用下标来访问字符串中的字符。例如，为了对字符串 `s` 中的每个字符进行处理，可以设定一个循环来对计数器 `i` 进行自增操作，并通过表达式 `s[i]` 来选择字符
    ```cpp
    int count_spaces(const char s[])
    {
        int count = 0, i;

        for (i = 0; s[i] != '\0';  i++)
            if (s[i] == ' ')
                count++;
        return count;
    }
    ```
2. 在 `s` 的声明中加上 `const` 表明 `count_spaces` 函数不会改变数组。
3. 如果 `s` 不是字符串，`count_spaces` 将需要第 2 个参数来指明数组的长度。然而，因为 `s` 是字符串，所以 `count_spaces` 可以通过测试空字符来定位 `s` 的末尾。
4. 下面用指针算术运算代替数组取下标来重新编写 `count_spaces` 函数。这次不再需要变量 `i`，而是利用 `s` 自身来跟踪字符串中的位置。通过对 `s` 反复进行自增操作，`count_spaces` 函数可以逐个访问字符串中的字符：
    ```cpp
    int count_spaces(const char *s)
    {
        int count = 0;

        for (; *s != '\0'; s++)
            if (*s == ' ')
                count++;
        return count;
    }
    ```
5. 注意，`const` 没有阻止 `count_spaces` 函数对 `s` 的修改，它的作用是阻止函数改变 `s` 所指向的字符。而且，因为 `s` 是传递给 `count_spaces` 函数的指针的副本，所以对 `s` 进行自增操作不会影响原始的指针。




















































## References
* [C语言程序设计](https://book.douban.com/subject/4279678/)