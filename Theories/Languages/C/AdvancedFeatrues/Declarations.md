# Declarations


<!-- TOC -->

- [Declarations](#declarations)
    - [声明的语法](#声明的语法)
        - [声明说明符分为以下 4 大类](#声明说明符分为以下-4-大类)
            - [存储类型](#存储类型)
            - [类型限定符](#类型限定符)
            - [类型说明符](#类型说明符)
            - [函数说明符](#函数说明符)
        - [声明符](#声明符)
    - [存储类型](#存储类型-1)
        - [变量的性质](#变量的性质)
            - [作用域和链接的区别](#作用域和链接的区别)
            - [块级作用域加外部链接的情况](#块级作用域加外部链接的情况)
        - [`auto` 存储类型](#auto-存储类型)
        - [`static` 存储类型](#static-存储类型)
        - [`extern` 存储类型](#extern-存储类型)
        - [`register` 存储类型](#register-存储类型)
        - [函数的存储类型](#函数的存储类型)
        - [块中的符合字面量](#块中的符合字面量)
        - [小结](#小结)
    - [类型限定符](#类型限定符-1)
    - [声明符](#声明符-1)
        - [解释复杂声明](#解释复杂声明)
        - [使用类型定义来简化声明](#使用类型定义来简化声明)
    - [初始化式](#初始化式)
        - [未初始化的变量](#未初始化的变量)
    - [内联函数 不懂](#内联函数-不懂)
        - [内联定义](#内联定义)
        - [对内联函数的限制](#对内联函数的限制)
        - [在 GCC 中使用内联函数](#在-gcc-中使用内联函数)
    - [练习](#练习)
    - [References](#references)

<!-- /TOC -->


## 声明的语法
1. 一般地，声明具有下列形式：
    ```cpp
    声明说明符 声明符;
    ```
2. **声明说明符**（declaration specifier）描述声明的变量或函数的性质。**声明符**（declarator）给出了它们的名字，并且可以提供关于其性质的额外信息
    <img src="./images/11.png" width="400" style="display: block; margin: 5px 0 10px;" />

### 声明说明符分为以下 4 大类
#### 存储类型
1. 存储类型一共有 4 种：`auto`、`static`、`extern` 和 `register`。
2. 在声明中最多可以出现一种存储类型。
3. 如果存储类型存在，则必须把它放置在最前面。

#### 类型限定符
1. C89 只有两种类型限定符：`const` 和 `volatile`。 C99 还有一个限定符 `restrict`。
2. 声明可以包含零个或多个限定符。

#### 类型说明符
1. 关键字 `void`、`char`、`short`、`int`、`long`、`float`、`double`、`signed` 和 `unsigned` 都是类型说明符，这些单词可以组合使用，并且出现的顺序并不重要（`int unsigned long` 和 `long unsigned int` 完全一样）。
2. 类型说明符也包括结构、联合和枚举的说明。例如，`struct point{int x, y;}`、`struct {int x, y;}` 或者 `struct point`。
3. 用 `typedef` 创建的类型名也是类型说明符。
4. 类型限定符和类型说明符必须跟随在存储类型的后边，但是两者的顺序没有限制。

#### 函数说明符
C99 还有第四种声明说明符，即函数说明符，它只用于函数声明。这一类说明符只有一个，即关键字 `inline`。

### 声明符
1. 声明符包括标识符（简单变量的名字）、后边跟随 `[]` 的标识符（数组名）、前边放置 `*` 的标识符（指针名）和后边跟随 `()` 的标识符（函数名）。
2. 声明符之间用逗号分隔。
3. 表示变量的声明符后边可以跟随初始化式。


## 存储类型
1. 存储类型可以用于变量以及较小范围的函数和形式参数的说明。现在集中讨论变量的存储类型。
2. 术语 **块**（block）表示函数体（花括号包含的部分）或者复合语句（可能包含声明）。 在 C99 中， 选择语句（`if` 和 `switch`）、循环语句（`while`、`do` 和 `for`）以及它们所控制的 “内部” 语句也被视为块，尽管本质上有一些差别。

### 变量的性质
1. C 程序中的每个变量都具有以下 3 个性质。
    * **存储期限**  
        1. 变量的存储期限决定了为变量预留和内存被释放的时间。 
        2. 具有 **自动存储期限** 的变量在所属块被执行时获得内存单元（变长数组除外），并在块终止时释放内存单元，从而会导致变量失去值。
        3. 具有 **静态存储期限** 的变量在程序运行期间占有同一个的存储单元，也就允许变量无限期地保留它的值。
    * **作用域**
        1. 变量的作用域是指可以引用变量的那部分程序文本。
        2. 变量可以有 **块作用域**，变量从声明的地方一直到所在块的末尾都是可见的；
        3. 或者 **文件作用域**，变量从声明的地方一直到所在文件的末尾都是可见的。
    * **链接** 
        1. 变量的链接确定了程序的不同部分可以共享此变量的范围。
        2. 具有 **外部链接** 的变量可以被程序中的几个或许全部文件共享。
        3. 具有 **内部链接** 的变量只能属于单独一个文件，但是此文件中的函数可以共享这个变量。如果具有相同名字的变量出现在另一个文件中，那么系统会把它作为不同的变量来处理。TODO，和 “文件作用域” 什么关系？
        4. **无链接** 的变量属于单独一个函数，而且根本不能被共享。
        5. 看起来链接像是在定义文件外部的 “作用域”。
2. 变量的默认存储期限、作用域和链接都依赖于变量声明的位置
    * 在块（包括函数体）内部声明的变量具有自动存储期限、块作用域，并且无链接。
    * 在程序的最外层（任意块外部）声明的变量具有静态存储期限、文件作用域和外部链接。
3. 对许多变量而言，默认的存储期限、作用域和链接是符合要求的。当这些性质无法满足要求时，可以通过指定明确的存储类型（`auto`、`static`、`extern` 和 `register`）来改变变量的性质。

#### 作用域和链接的区别
1. 作用域是为编译器服务的，而链接则是为链接器服务的。
2. 编译器用标识符的作用域来确定在文件的给定位置访问标识符是否合法。
3. 当编译器把源文件翻译成目标代码时，它会注意到有外部链接的名字，并最终把这些名字存储到目标文件内的一个表中。因此，链接器可以访问到具有外部链接的名字，而内部链接的名字或无链接的名字对链接器而言是不可见的。

#### 块级作用域加外部链接的情况
1. 假设某个源文件定义了变量 `i`：
    ```cpp
    int i;
    ```
2. 假设变量 `i` 的定义放在了任意函数之外，所以默认情况下它具有外部链接。
3. 在另一个文件中，有一个函数 `f` 需要访问变量 `i`，所以 `f` 的函数体把 `i` 声明为 `extern`：
    ```cpp
    void f(void)
    {
        extern int i;
        ...
    }
    ```
4. 在第一个文件中，变量 `i` 具有文件作用域。但是，在函数 `f` 内，`i` 具有块作用域。
5. 如果除函数 `f` 以外的其他函数需要访问变量 `i`，那么它们将需要单独声明 `i`。或者简单地把变量 `i` 的声明移到函数f外，从而使其具有文件作用域。
6. 在整个过程中会混淆的就是：每次声明或定义 `i` 都会建立不同的作用域，有时是文件作用域，有时是块作用域。

### `auto` 存储类型
1. `auto` 存储类型只对属于块的变量有效。
2. `auto` 变量具有自动存储期限、块作用域，并且无链接。
3. `auto` 存储类型几乎从来不用明确地指明，因为对于在块内部声明的变量，它是默认的。

### `static` 存储类型
1. `static` 存储类型可以用于全部变量，而无需考虑变量声明的位置。但是，作用于块外部声明的变量和块内部声明的变量时会有不同的效果。
2. 当用在块外部时，单词 `static` 说明变量具有内部链接。（把本来静态外部变为静态内部）
3. 当用在块内部时，`static` 把变量的存储期限从自动的变成了静态的
    <img src="./images/12.png" width="300" style="display: block; margin: 5px 0 10px;" />
4. 在用于块外部的声明时，`static` 本质上使变量只在声明它的文件内可见。`static` 的此种用法可以用来实现一种称为信息隐藏的技术。
5. 块内声明的 `static` 变量在程序执行期间驻留在同一存储单元内。和每次程序离开所在块就会丢失值的自动变量不同，`static` 变量会无限期地保留值。
6. 块内 `static` 变量具有以下一些有趣的性质
    * `static` 变量只在程序执行前进行一次初始化，而 `auto` 变量则会在每次出现时进行初始化（假设它有初始化式）。
    * 每次函数被递归调用时，它都会获得一组新的 `auto` 变量。但是，如果函数含有 `static` 变量，那么此函数的全部调用都可以共享这个 `static` 变量。
    * 虽然函数不应该返回指向 `auto` 变量的指针，但是函数返回指向 `static` 变量的指针是没有错误的。
7. 声明函数中的一个变量为 `static`，这样做允许函数在 “隐藏” 区域内的调用之间保留信息。隐藏区域是程序其他部分无法访问到的地方。
8. 然而，更经常的用途是用 `static` 来使程序更加有效。思考下列函数：
    ```cpp
    char digit_to_hex_char(int digit)
    {
        const char hex_chars[16] = "0123456789ABCDEF";

        return hex_chars[digit];
    }
    ```
    每次调用 `digit_to_hex_char` 函数时，都会把字符 `0123456789ABCDEF` 复制给数组 `hex_chars` 来对其进行初始化。现在，把数组设为 `static` 的：
    ```cpp
    char digit_to_hex_char(int digit)
    {
        static const char hex_chars[16] = "0123456789ABCDEF";

        return hex_chars[digit];
    }
    ```
    由于 `static` 型变量只进行一次初始化，这样做就改进了 `digit_to_hex_char` 函数的速度。

### `extern` 存储类型
1. `extern` 存储类型使几个源文件可以共享同一个变量。
2. 下列声明给编译器提供的信息是，`i` 是 `int` 型变量：
    ```cpp
    extern int i;
    ```
    但是这样不会导致编译器为变量 `i` 分配存储单元。
3. 用 C 语言的术语来说，上述声明不是变量 `i` 的 **定义**，它只是提示编译器需要访问定义在别处的变量。可能稍后在同一文件中，更常见的是在另一个文件中。
4. 变量在程序中可以有多次 **声明**，但只能有一次 **定义**。
5. 变量的 `extern` 声明不是定义这一规则有一个例外。对变量进行初始化的 `extern` 声明是变量的定义。例如，声明
    ```cpp
    extern int i = 0;
    ```
    等效于
    ```
    int i = 0;
    ```
    这条规则可以防止多个 `extern` 声明用不同方法对变量进行初始化。
6. `extern` 声明中的变量始终具有静态存储期限。
7. 变量的作用域依赖于声明的位置：如果声明在块内部，那么变量具有块作用域；否则，变量具有文件作用域。
8. 确定 `extern` 型变量的链接有一定难度：如果变量在文件中较早的位置（任何函数定义的外部）声明为 `static`，那么它具有内部链接；否则（通常情况下），变量具有外部链接。不懂，之前声明为 `static`，现在又声明为 `extern`？

### `register` 存储类型
1. 声明变量具有 `register` 存储类型就要求编译器把变量存储在寄存器中，而不是像其他变量一样保留在内存中。
2. 寄存器是驻留在计算机 CPU 中的存储单元。存储在寄存器中的数据会比存储在普通内存中的数据访问和更新的速度更快。
3. 指明变量的存储类型是 `register` 是一种请求，而不是命令。编译器可以选择把 `register` 型变量存储在内存中。
4. `register` 存储类型只对声明在块内的变量有效。`register` 变量具有和 `auto` 变量一样的存储期限、作用域和链接。
5. 但是，`register` 变量缺乏 `auto` 变量所具有的一种性质：由于寄存器没有地址，所以对 `register` 变量使用取地址运算符 `&` 是非法的。即使编译器选择把变量存储在内存中，这一限制仍适用。
6. `register` 存储类型最好用于需要频繁进行访问或更新的变量。例如，在 `for` 语句中的循环控制变量就比较适合声明为 `register`：
    ```cpp
    int sum_array(int a[], int n)
    {
        register int i;
        int sum = 0;

        for (i = 0; i < n; i++)
            sum += a[i];
        return sum;
    }
    ```
7. 现在 `register` 存储类型已经不像以前那样在 C 程序员中流行了。当今的编译器比早期的 C 语言编译器复杂多了，许多编译器可以自动确定哪些变量保留在寄存器中可以获得最大的好处。
8. 不过，使用 `register` 仍然可以为编译器优化程序性能提供有用的信息。特别地，编译器知道不能对 `register` 变量取地址，因而不能用指针对其进行修改。在这一方面，`register` 关键字与 C99 的 `restrict` 关键字相关。

### 函数的存储类型
1. 和变量声明一样，函数声明（和定义）也可以包括存储类型，但是选项只有 `extern` 和 `static`。
2. 在函数声明开始处的单词 `extern` 说明函数具有外部链接，也就是允许其他文件调用此函数；`static` 说明是内部链接，也就是说只能在定义函数的文件内部调用此函数。
3. 如果不指明函数的存储类型，那么会假设函数具有外部链接。
4. 思考下面的函数声明：
    ```cpp
    extern int f(int i);
    static int g(int i);
    int h(int i);
    ```
    函数 `f` 具有外部链接，函数 `g` 具有内部链接，而函数 `h`（默认情况下）具有外部链接。由于 `g` 具有内部链接，所以在定义它的文件之外不能直接调用它。
5. 把函数声明为 `static` 不能完全阻止在别的文件中对它进行调用，通过函数指针进行间接调用仍然是可能的。
6. 声明函数是 `static` 是十分有用的。事实上，当声明不打算被其他文件调用的任意函数时，建议使用 `static` 存储类型。这样做的好处包括以下两点。
    * **更容易维护**
        1. 把函数 `f` 声明为 `static` 存储类型保证在函数定义出现的文件之外函数 `f` 都是不可见的。因此，以后修改程序的人可以知道对函数 `f` 的变化不会影响其他文件中的函数。
        2. 一个例外是：另一个文件中的函数如果传入了指向函数 `f` 的指针，它可能会受到函数 `f` 变化的影响。幸运的是，这种问题很容易通过检查定义函数f的文件来发现，因为传递 `f` 的函数一定也定义在此文件中。
    * **减少了“名字空间污染”**：由于声明为 `static` 的函数具有内部链接，所以可以在其他文件中重新使用这些函数的名字。
7. 函数的形式参数具有和 `auto` 变量相同的性质：自动存储期限、块作用域和无链接。唯一能用于形式参数的存储类型是 `register`。

### 块中的符合字面量
1. C99 标准指出，如果复合字面量出现在函数体之外，那么复合字面量所表示的对象具有静态存储期限。否则，它具有自动存储期限，因而对象所占有的内存会在复合字面量所在块的末尾释放。
2. 考虑下面的函数，该函数返回使用复合字面量创建的 `point`结构：
    ```cpp
    struct point create_point(int x, int y)
    {
        return (struct point) {x, y};
    }
    ```
3. 这个函数可以正确工作，因为虽然复合字面量创建的对象会在函数末尾被释放，但是在函数返回时它被复制。原始的对象将不复存在，但副本会保留。
4. 现在假设我们对函数进行微小的改动：
    ```cpp
    struct point *create_point(int x, int y)
    {
        return &(struct point) {x, y};
    }
    ```
5. 这一版本的 `create_point` 函数会导致未定义的行为，因为它返回的指针所指向的对象具有自动存储期限，函数返回后该对象不复存在。
6. 再考虑下面的例子：
    ```cpp
    /* Example 1 - if statement without braces */

    double *coefficients, value;

    if (polynomial_selected == 1)
        coefficients = (double[3]) {1.5, -3.0, 6.0};
    else
        coefficients = (double[3]) {4.5, 1.0, -3.5};
    
    value = evaluate_polynomial(coefficients);
    ```
    这个程序片段能按需要的方式工作。`coefficients` 将指向由复合字面量创建的两个对象之一，并且该对象在调用 `evaluate_polynomial` 时仍然存在。
7. 现在考虑一下，如果在内部语句两边加上花括号
    ```cpp
    /* Example 2 - if statement with braces */

    double *coefficients, value;

    if (polynomial_selected == 1) {
        coefficients = (double[3]) {1.5, -3.0, 6.0};
    } 
    else {
        coefficients = (double[3]) {4.5, 1.0, -3.5};
    }
    value = evaluate_polynomial(coefficients);
    ```
    现在我们遇到问题了。每个复合字面量会创建一个对象，但是该对象只存在于包含相应语句的花括号所形成的块内。调用 `evaluate_polynomial` 时，`coefficients` 指向一个不存在的对象，从而导致未定义的行为。
8. C99 的创立者对这种现象很不满意，因为程序员不可能期望在if语句中简单地增加花括号就会导致未定义的行为。为了避免这一问题，他们决定始终把内部语句视为块。这样一来，示例1和示例2就等价了，都会导致未定义的行为。TODO，编译时加了 `-std=c99` 指令也没有报错。

### 小结
1. 下面的代码段说明了变量和形式参数声明中包含或者省略存储类型的所有可能的方法
    ```cpp
    int a;
    extern int b;
    static int c;

    void f(int d, register int e)
    {
        auto int g;
        int h;
        static int i;
        extern int j;
        register int k;
    }
    ```
2. 下表说明了上述例子中每个变量和形式参数的性质
    <table width="90%" border="1">
        <thead>
            <tr>
                <th><p>名字</p></th>
                <th><p>存储期限</p></th>
                <th><p>作用域</p></th>
                <th><p>链接</p></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    <p><code>a</code></p>
                </td>
                <td><p>静态</p></td>
                <td><p>文件</p></td>
                <td><p>外部</p></td>
            </tr>
            <tr>
                <td>
                    <p><code>b</code></p>
                </td>
                <td><p>静态</p></td>
                <td><p>文件</p></td>
                <td>
                    <p><sup>*</sup></p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>c</code></p>
                </td>
                <td><p>静态</p></td>
                <td><p>文件</p></td>
                <td><p>内部</p></td>
            </tr>
            <tr>
                <td>
                    <p><code>d</code></p>
                </td>
                <td><p>自动</p></td>
                <td><p>块</p></td>
                <td><p>无</p></td>
            </tr>
            <tr>
                <td>
                    <p><code>e</code></p>
                </td>
                <td><p>自动</p></td>
                <td><p>块</p></td>
                <td><p>无</p></td>
            </tr>
            <tr>
                <td>
                    <p><code>g</code></p>
                </td>
                <td><p>自动</p></td>
                <td><p>块</p></td>
                <td><p>无</p></td>
            </tr>
            <tr>
                <td>
                    <p><code>h</code></p>
                </td>
                <td><p>自动</p></td>
                <td><p>块</p></td>
                <td><p>无</p></td>
            </tr>
            <tr>
                <td>
                    <p><code>i</code></p>
                </td>
                <td><p>静态</p></td>
                <td><p>块</p></td>
                <td><p>无</p></td>
            </tr>
            <tr>
                <td>
                    <p><code>j</code></p>
                </td>
                <td><p>静态</p></td>
                <td><p>块</p></td>
                <td>
                    <p><sup>*</sup></p>
                </td>
            </tr>
            <tr>
                <td>
                    <p><code>k</code></p>
                </td>
                <td><p>自动</p></td>
                <td><p>块</p></td>
                <td><p>无</p></td>
            </tr>
        </tbody>
    </table>
    
    \* 由于这里没有显示出变量 `b` 和 `j` 的定义，所以不可能确定它们的链接。在大多数情况下，变量会定义在另一个文件中，并且具有外部链接。


## 类型限定符
1. C 语言中一共有两种类型限定符：`const` 和 `volatile`。C99 还有第三种类型限定符，即 `restrict`，它只用于指针。`volatile` 只用在底层编程中。
2. 把对象声明为 `const` 有以下几个好处。
    * `const` 是文档格式：声明对象是 `const` 类型可以提示任何阅读程序的人，该对象的值不会改变。
    * 编译器可以检查程序没有特意地试图改变该对象的值。
    * 当为特定类型的应用（特别是嵌入式系统）编写程序时，编译器可以用单词 `const` 来识别需要存储到 ROM（只读存储器）中的数据。
3. 一看，`const` 好像与 `#define` 指令一样。然而，实际上 `#define` 和 `const` 之间有明显的差异
    * 可以用 `#define` 指令为数值、字符或字符串常量创建名字。`const` 则可用于产生任何类型的只读对象，包括数组、指针、结构和联合。
    * `const` 对象遵循与变量相同的作用域规则，而用 `#define` 创建的常量不受这些规则的限制。特别是，不能用 `#define` 创建具有块作用域的常量。
    * 和宏的值不同，`const` 对象的值可以在调试器中看到。
    * 不同于宏， `const` 对象不可以用于常量表达式。例如，由于数组边界必须是常量表达式，所以不能写成下列形式：不懂，编译时加上 `-std=c99` 也没有报错，问与答有详细解释
        ```cpp
        const int n = 10;
        int a[n];             /*** WRONG ***/
        ```
        在 C99 中，如果 `a` 具有自动存储期限，那么这个例子是合法的——它会被视为变长数组；但是如果 `a` 具有静态存储期限，那么这个例子是不合法的。
    * 对 `const` 对象应用取地址运算符（`&`）是合法的，因为它有地址。宏没有地址。
4. 没有绝对的原则说明何时使用 `#define` 以及何时使用 `const`。这里建议对表示数或字符的常量使用 `#define`。这样就可以把这些常量作为数组维数，并且在 `switch` 语句或其他要求常量表达式的地方使用它们。


## 声明符
### 解释复杂声明
1. 下面这个声明符是什么意思呢
    ```cpp
    int *(*x[10])(void);
    ```
2. 有下面两条简单的规则可以用来理解任何声明：
    * **始终从内往外读声明符**。换句话说，定位声明的标识符，并且从此处开始解释声明。
    * **在作选择时，始终使 `[]` 和 `()` 优先于 `*`**：
        * 如果 `*` 在标识符的前面，而标识符后边跟着 `[]`，那么标识符表示数组而不是指针。
        * 同样地，如果 `*` 在标识符的前面，而标识符后边跟着 `()`，那么标识符表示函数而不是指针。
        * 当然，可以使用圆括号来使 `[]` 和 `()` 相对于 `*` 的优先级无效。
3. 首先把这些规则应用于简单的示例。在声明
    ```cpp
    int *ap[10];
    ```
    中，`ap` 是标识符。由于 `*` 在 `ap` 的前面，且后边跟着 `[]`，而 `[]` 优先级高，所以 `ap` 是指针数组。
4. 在下列声明中，
    ```cpp
    float *fp(float);
    ```
    `fp` 是标识符。由于 `*` 在标识符的前面，且后边跟着 `()`，而 `()` 优先级高，所以 `fp` 是返回指针的函数。
5. 下列声明
    ```cpp
    void (*pf)(int);
    ```
    由于 `*pf` 包含在圆括号内，所以 `pf` 一定是指针。但是 `(*pf)` 后边跟着 `(int)`，所以 `pf` 必须指向函数，且此函数带有 `int` 型的实际参数。单词 `void` 表明了此函数的返回类型。
6. 再看看最开始的声明：
    ```cpp
    int *(*x[10])(void);
    ```
    首先，定位声明的标识符（`x`）。在 `x` 前有 `*`，而后边又跟着`[]`。因为 `[]` 优先级高于 `*`，所以 `x` 是数组。接下来，从左侧找到数组中元素的类型（指针）。再接下来，到右侧找到指针所指向的数据类型（不带实际参数的函数）。最后，回到左侧看 **每个** 函数返回的内容（指向 `int` 型的指针）。
7. 在 C 语言中有不能声明的特定内容
    * 函数不能返回数组（虽然是错的，但是这个表示返回值的格式挺奇怪）：
        ```cpp
        int f(int)[];      /*** WRONG ***/
        ```
    * 函数不能返回函数：
        ```cpp
        int g(int)(int);   /*** WRONG ***/
        ```
    * 函数型的数组也是不可能的：
        ```cpp
        int a[10](int);    /*** WRONG ***/
        ```
8. 在上述情形中，我们可以用指针来获得所需的效果。函数不能返回数组，但可以返回指向数组的指针；函数不能返回函数，但可以返回指向函数的指针；函数型的数组不合法，但是数组可以包含指向函数的指针。

### 使用类型定义来简化声明
1. 一些程序员利用类型定义来简化复杂的声明。考虑一下前面检查过的 `x` 的声明：
    ```cpp
    int *(*x[10])(void);
    ```
2. 为了使 `x` 的类型更容易理解，可以使用下面一系列的类型定义：
    ```cpp
    typedef int *Fcn(void);
    typedef Fcn *Fcn_ptr;
    typedef Fcn_ptr Fcn_ptr_array[10];
    Fcn_ptr_array x;
    ```
3. 反向阅读可以发现，`x` 具有 `Fcn_ptr_array` 类型，`Fcn_ptr_array` 是 `Fcn_ptr` 值的数组，`Fcn_ptr` 是指向 `Fcn` 类型的指针，而 `Fcn` 是不带实际参数且返回指向 `int` 型值的指针的函数。
4. 这种 `typedef` 的逻辑看起来有些奇怪，因为之前遇到的都是类似于这样的
    ```cpp
    typedef int Bool;
    Bool flag;
    ```
    相当于给 `int` 起了个别名 `Bool`
5. 但如果照搬这种逻辑，试图认为 `*Fcn(void)` 是 `int` 的别名而如下使用，就会导致错误
    ```cpp
    typedef int *Fcn(void);
    *Fcn(void) n = 5;
    ```
6. `typedef int *Fcn(void)` 实际的意思并不是其别名，而是 **`Fcn` 是个函数，没有形参，返回值为指针，指针具有是 `int` 类型**。
7. 同理，`typedef Fcn *Fcn_ptr` 也不是说 “`*Fcn_ptr` 是 `Fcn` 的别名”，而是说 “定义一个新的类型 `Fcn_ptr`，该类型是一个指针，指针的类型是 `Fcn`”。
8. 明确了 `typedef` 的逻辑，现在试着自己实现上面的多重定义
    1. 首先看到 `x` 是 10 项指针数组，所以先起个大概类型名，然后声明 `x`
        ```cpp
        size10_ptr_array x;
        ```
    2. 现在需要定义 `size10_ptr_array` 类型。因为是数组，所以定义的时候必须要有中括号，形式如下
        ```cpp
        typedef 某某1 size10_ptr_array[10];
        ```
    3. 对数组使用 `typedef`，显然不是要定义 “数组的类型”，而是要定义 “数组项的类型”，所以上面的 `某某1` 应该是数组项的类型。可以看到，数组项的类型是指针。因为目前还不知道是什么类型的指针，所以暂时命名为 `x_ptr`
        ```cpp
        typedef x_ptr size10_ptr_array[10];
        size10_ptr_array x;
        ```
    4. 接下来要定义 `x_ptr` 类型。因为 `x_ptr` 是指针，所以定义的时候必须要有 `*`，形式如下
        ```cpp
        typedef 某某2 *x_ptr;
        ```
    5. 继续分析可以看到 `x_ptr` 指向函数。同样，现在也不知道函数是什么参数和返回值，所以暂时命名为 `x_fn`
        ```cpp
        typedef x_fn *x_ptr;
        typedef x_ptr size10_ptr_array[10];
        size10_ptr_array x;
        ```
    6. 接下来定义 `x_fn`。因为 `x_fn` 是函数，所以定义的时候必须要有形参和返回值，形式如下
        ```cpp
        typedef 某某3 返回值 x_fn(参数);
        ```
    7. 继续看到，这个函数的参数是 `void`，返回值是指针，所以上面的形式进一步修改为
        ```cpp
        typedef 某某3 *x_fn(void);
        ```
    8. 函数的返回值是指针，`某某3` 就需要是该指针的类型。可以看到类型是 `int`，所以改成
        ```cpp
        typedef int *x_fn(void);
        typedef x_fn *x_ptr;
        typedef x_ptr size10_ptr_array[10];
        size10_ptr_array x;
        ```
9. 测试一下
    ```cpp
    #include <stdio.h>

    typedef int *x_fn(void);
    typedef x_fn *x_ptr;
    typedef x_ptr size10_ptr_array[10];
    size10_ptr_array x;

    int m = 22;
    int n = 33;

    int *foo (void) {
        printf("%s\n", "foo");
        m += 200;
        return &m;
    }

    int *bar (void) {
        printf("%s\n", "bar");
        n += 300;
        return &n;
    }

    int main(void)
    {

        size10_ptr_array x = {foo, bar};
        int *p_m = (*(x[0]))(); // foo
        int *p_n = (*(x[1]))(); // bar

        printf("%d %d", *p_m, *p_n); // 222 333

        return 0;
    }
    ```
10. 各种类型定义好之后，就可以按照最上面的样子改成更好理解的名字。


## 初始化式
1. 具有静态存储期限的变量的初始化式必须是常量：
    ```cpp
    #define FIRST 1
    #define LAST 100

    static int i = LAST - FIRST + 1;
    ```
    由于 `LAST` 和 `FIRST` 都是宏，所以编译器可以计算出i的初始值。如果 `LAST` 和 `FIRST` 是变量，那么初始化式就是非法的。
2. 声明在任何函数外面的的变量默认是静态的，所以初始化式必须使用常量
    ```cpp
    int i = 5;
    int j = i + 1; // 静态存储期限，错误

    int main(void)
    {
        int i = 5;
        int j = i + 1; // 自动存储期限，正确

        return 0;
    }
    ```
3. 包含在花括号中的数组、结构或联合的初始化式必须只包含常量表达式，不允许有变量或函数调用：
    ```cpp
    #define N 2

    int powers[5] = {1, N, N * N, N * N * N, N * N * N * N};
    ```
    因为 `N` 是常量，所以 `powers` 的初始化式是合法的。如果 `N` 是变量，那么程序将无法通过编译。在 C99 中，仅当变量具有静态存储期限时，这一限制才生效。

### 未初始化的变量
1. 未初始化变量有未定义的值，但并不总是这样的，变量的初始化值依赖于变量的存储期限。
2. 具有自动存储期限的变量没有默认的初始值。不能预测自动变量的初始值，而且每次变量变为有效时值可能不同
    ```cpp
    {
        int n;
        printf("%d", n); // 4194432
        return 0;
    }
    ```
3. 具有静态存储期限的变量默认情况下的值为零
    ```cpp
    int n;

    int main(void)
    {
        
        printf("%d", n); // 0
        return 0;
    }
    ```
3. 用 `calloc` 分配的内存是简单的给字节的位置零，而静态变量不同于此，它是基于类型的正确初始化，即整型变量初始化为 0，浮点变量初始化为 0.0，而指针则初始化为空指针。TODO，怎么测试
4. 出于书写风格的考虑，最好为静态类型的变量提供初始化式，而不是依赖于它们一定为零的事实。如果程序访问了没有明确初始化的变量，那么以后阅读程序的人可能不容易确定变量是否为零，或者是否在程序中的某处通过赋值初始化。


## 内联函数 不懂
1. C99 函数声明中有一个 C89 中不存在的选项：可以包含关键字 `inline`。这个关键字是一个全新的声明说明符，不同于存储类型、类型限定符以及类型说明符。
2. 为了理解 `inline` 的作用，我们需要把 C 编译器在调用函数和从函数返回过程中产生的机器指令可视化。
3. 在机器层面，调用函数之前可能需要预先执行一些指令。
4. 调用本身需要跳转到函数的第一条指令，函数本身可能也需要执行一些额外的指令来启动执行。
5. 如果函数有参数，参数需要被复制，因为 C 通过值传递参数。
6. 从函数返回也需要被调用的函数和调用函数执行差不多工作量。
7. 调用函数和从函数返回所需的工作量称为 “额外开销”，因为我们并没有要求函数执行这些工作。
8. 尽管函数调用中的额外开销只是使程序稍许变慢，但在特定的情况下额外开销会产生累积效应。例如，在函数需要调用数百万次或数十亿次，使用老式的比较慢的处理器（例如在嵌套系统中），或者有着非常严格的时限要求（例如在实时系统中）时。
9. 在 C89 中，避免函数额外开销的唯一方式是使用带参数的宏。但是带参数的宏也有一些缺点。C99 提供了一种更好的解决方案：创建 **内联函数**（inline function）。
10. “内联” 表明编译器把函数的每一次调用都用函数的机器指令来代替。这种方法虽然会使被编译程序的大小增加一些，但是可以避免函数调用的常见额外开销。
11. 不过，把函数声明为 `inline` 并不是强制编译器将代码内联编译，只是建议编译器应该使函数调用尽可能地快，也许在函数调用时才执行内联展开。编译器可以忽略这一建议。

### 内联定义
1. 内联函数用关键字 `inline` 作为一个声明说明符：
    ```cpp
    inline double average(double a, double b)
    {
        return (a + b) / 2;
    }
    ````
2. 下面考虑复杂一点的情形。`average` 有外部链接，所以在其他源文件也可以调用 `average`。但是编译器并没有考虑 `average` 的定义是外部定义（它是 **内联定义**），所以试图在别的文件中调用 `average` 将被认为是错误的。
3. 可以将 `average` 的内联定义放入头文件（命名为 `average.h`）中：
    ```cpp
    #ifndef AVERAGE_H
    #define AVERAGE_H

    inline double average(double a, double b)
    {
    return (a + b) / 2;
    }

    #endif
    ```
4. 接下来，再创建与之匹配的源文件 `average.c`：
    ```cpp
    #include "average.h"

    extern double average(double a, double b);
    ```
5. 现在，任何一个需要调用 `average` 函数的文件只需要简单地包含 `average.h` 就行了，该头文件包含了 `average` 的内联定义。
6. `average.c` 文件包含了 `average` 的原型。由于使用了 `extern` 关键字，因此 `average.h` 中的 `average` 的定义在 `average.c` 中被认为是外部定义。
7. C99 中的一般法则是，如果特定文件中某个函数的所有顶层声明中都有 `inline` 但没有 `extern`，则该函数定义在该文件中是内联的。如果在程序的其他地方使用该函数（包含其内联定义的文件也算），则需要在另一个文件中为其提供外部定义。调用函数时，编译器可以选择进行正常调用（使用函数的外部定义）或者执行内联展开（使用函数的内联定义）。我们没有办法知道编译器会怎样选择，所以一定要确保这两处定义一致。刚刚我们讨论过的方式（使用 `average.h` 和 `average.c`）可以保证定义的一致性。

### 对内联函数的限制
1. 因为内联函数的实现方式和一般函数大不一样，所以需要一些不同的规则和限制。
2. 对于具有外部链接的内联函数来说，具有静态存储期限的变量是一个特别的问题。因此，C99 对具有外部链接的内联函数（未对具有内部链接的内联函数做约束）做了如下限制
    * 函数中不能定义可改变的 `static` 变量。
    * 函数中不能引用具有内部链接的变量。
3. 这样的函数可以定义同时为 `static` 和 `const` 的变量，但是每个内联定义都需要分别创建该变量的副本。

### 在 GCC 中使用内联函数
TODO


## 练习
* 练习题 11
    ```cpp
    #include <stdio.h>
    #include <stdlib.h>

    int *f(int); 

    float foo (float n);
    float bar (float n);

    float (*g(int))(float); 
    // g 是一个函数，函数的参数是 int，返回值是指针（*）。指针指向参数为 float 的函数，被指向的函数的返回值类型为 float
    // 下面是一个错误的
    // float *g(int)(float); 
    // g 是一个函数，函数的参数是 int，因为 (float) 优先级高于 *，而又没有向上面那样加了括号，所以函数返回一个函数，被返回函数的参数是 float，被返回函数的返回值的 float *

    float (*a[])(float) = { foo, bar };

    int main(void)
    {
        int *ptr = f(5);
        printf("%d %d %d\n", ptr[0], ptr[1], ptr[2]); // 4 5 6


        printf("%f\n", (*g(1))(5.0)); // 10.000000
        printf("%f\n", (*g(0))(5.0)); // 25.000000

        printf("%f\n", (*a[0])(5.0)); // 10.000000
        printf("%f\n", (*a[1])(5.0)); // 25.000000

        return 0;
    }

    int *f(int n) {
        int arr[] = {n-1, n, n+1};
        int *p = arr;
        return p;
    }

    float foo (float n) {
        return n + n;
    }
    float bar (float n) {
        return n * n;
    }
    float (*g(int num))(float) {
        if (num) {
            return foo;
        }
        else {
            return bar;
        }
    }
    ```

* 练习题 12
    1. `f` 是函数，有两个参数，返回类型是指针；
    2. 返回的指针指向函数，该函数有一个 `double` 类型的参数，返回值为 `int` 类型；
    3. `f` 的第一个参数类型是 `float (*)(long)`，因为有 `*` 的存在，所以它不是函数，而是指向函数的指针；
    4. 该指针指向的函数有一个 `long` 类型的参数，返回值类型为 `float`。
    5. 测试如下
        ```cpp
        #include <stdio.h>

        int (*f(float (*)(long), char *))(double);
        float inner(long l); // f 第一个指针参数指向的函数
        int outer(double lf); // f 返回的指针指向的函数


        int main(void)
        {
            // f(&inner, "hehe")，传参指向函数 inner 的指针调用 f， 返回指向函数 outer 的指针
            // * 取指针指向的 outer 函数，之后在调用 outer 函数
            (*(f(&inner, "hehe")))(2.71828);

            return 0;
        }


        float inner(long l) {
            return l + 3.1415926;
        }

        int outer(double lf){
            printf("%lf\n", lf+1); // 3.718280
            return 22;
        }

        int (*f(float (*f1)(long), char *str))(double) {
            float fn = (*(f1))(5);
            printf("%s\n", str); // hehe
            printf("%lf\n", fn); // 8.141593

            return &outer;
        }
        ```


## References
* [C语言程序设计](https://book.douban.com/subject/4279678/)