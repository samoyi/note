# Preprocessor


<!-- TOC -->

- [Preprocessor](#preprocessor)
    - [预处理器的工作原理](#预处理器的工作原理)
        - [基本原理](#基本原理)
        - [一例](#一例)
    - [预处理指令](#预处理指令)
        - [几条适用于所有指令的规则。](#几条适用于所有指令的规则)
    - [宏定义](#宏定义)
        - [简单的宏](#简单的宏)
            - [使用 `#define` 来为常量命名的优点](#使用-define-来为常量命名的优点)
            - [宏的其他应用](#宏的其他应用)
        - [带参数的宏](#带参数的宏)
            - [带参数的宏替代真正的函数有两个优点](#带参数的宏替代真正的函数有两个优点)
            - [带参数的宏的一些缺点](#带参数的宏的一些缺点)
                - [编译后的代码通常会变大](#编译后的代码通常会变大)
                - [宏参数没有类型检查](#宏参数没有类型检查)
                - [无法用一个指针来指向一个宏](#无法用一个指针来指向一个宏)
                - [宏可能会不止一次地计算它的参数](#宏可能会不止一次地计算它的参数)
        - [`#` 运算符](#-运算符)
        - [`##` 运算符](#-运算符)
        - [宏的通用属性](#宏的通用属性)
            - [宏的替换列表可以包含对其他宏的调用](#宏的替换列表可以包含对其他宏的调用)
            - [预处理器只会替换完整的记号，而不会替换记号的片断](#预处理器只会替换完整的记号而不会替换记号的片断)
            - [宏定义的作用范围通常到出现这个宏的文件末尾](#宏定义的作用范围通常到出现这个宏的文件末尾)
            - [宏不可以被定义两遍，除非新的定义与旧的定义是一样的](#宏不可以被定义两遍除非新的定义与旧的定义是一样的)
            - [宏可以使用 `#undef` 指令 “取消定义”](#宏可以使用-undef-指令-取消定义)
    - [References](#references)

<!-- /TOC -->


## 预处理器的工作原理
### 基本原理
1. 预处理器的行为是由 **预处理指令**（由 `#` 字符开头的一些命令）控制的。我们已经在前面的章节中遇见过其中两种指令，即 `#define` 和 `#include`。
2. `#define` 指令定义了一个 **宏**——用来代表其他东西的一个名字，例如常量或常用的表达式。预处理器会通过将宏的名字和它的定义存储在一起来响应 `#define` 指令。当这个宏在后面的程序中使用到时，预处理器 “扩展” 宏，将宏替换为其定义值。
3. `#include` 指令告诉预处理器打开一个特定的文件，将它的内容作为正在编译的文件的一部分 “包含” 进来。例如，代码行
    ```cpp
    #include <stdio.h>
    ```
    指示预处理器打开一个名字为 `stdio.h` 的文件，并将它的内容加到当前的程序中。
4. 下图说明了预处理器在编译过程中的作用
    <img src="./images/07.png" width="200" style="display: block; margin: 5px 0 10px;" />
5. 预处理器的输入是一个 C 语言程序，程序可能包含指令。预处理器会执行这些指令，并在处理过程中删除这些指令。
6. 预处理器的输出是另一个 C 程序：原程序编辑后的版本，不再包含指令。
7. 预处理器的输出被直接交给编译器，编译器检查程序是否有错误，并将程序翻译为目标代码（机器指令）。
8. 在 C 语言较早的时期，预处理器是一个单独的程序，它的输出提供给编译器。如今，预处理器通常和编译器集成在一起，而且其输出也不一定全是 C 代码（例如，包含 `<stdio.h>` 之类的标准头使得我们可以在程序中使用相应头中的函数，而不需要把头的内容复制到程序的源代码中）。
9. 然而，将预处理器和编译器认为是不同的程序仍然是有用的。实际上，大部分 C 编译器都提供了一种方法，使用户可以看到预处理器的输出。在指定某个特定的选项（GCC 编译器用的是 `-E`）时编译器会产生预处理器的输出。其他一些编译器会提供一个类似于集成的预处理器的独立程序。
10. 注意，预处理器仅知道少量 C 语言的规则。因此，它在执行指令时非常有可能产生非法的程序。经常是原始程序看起来没问题，使错误查找起来很难。对于较复杂的程序，检查预处理器的输出可能是找到这类错误的有效途径。

### 一例
1. 考虑一下原程序
    ```cpp
    /* Converts a Fahrenheit temperature to Celsius */

    #include <stdio.h>

    #define FREEZING_PT 32.0f
    #define SCALE_FACTOR (5.0f / 9.0f)

    int main(void)
    {
        float fahrenheit, celsius;

        printf("Enter Fahrenheit temperature: ");
        scanf("%f", &fahrenheit);

        celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;

        printf("Celsius equivalent is: %.1f\n", celsius);

        return 0;
    }
    ```
2. 预处理结束后，程序是下面的样子：
    ```cpp
    空行
    空行
    从stdio.h中引入的行
    空行
    空行
    空行
    空行
    int main(void)
    {
        float fahrenheit, celsius;

        printf("Enter Fahrenheit temperature:  ");
        scanf("%f", &fahrenheit);

        celsius = (fahrenheit - 32.0f) * (5.0f / 9.0f);

        printf("Celsius equivalent is: %.1f\n", celsius);

        return 0;
    }
    ```
3. 预处理器通过引入 `stdio.h` 的内容来响应 `#include` 指令。预处理器也删除了 `#define` 指令，并且替换了该文件中稍后出现在任何位置上的 `FREEZING_PT` 和 `SCALE_FACTOR`。
4. 请注意预处理器并没有删除包含指令的行，而是简单地将它们替换为空。
5. 正如这个例子所展示的那样，预处理器不仅仅是执行了指令，还做了一些其他的事情。特别值得注意的是，它将每一处注释都替换为一个空格字符。有一些预处理器还会进一步删除不必要的空白字符，包括每一行开始用于缩进的空格符和制表符。


## 预处理指令
1. 大多数预处理指令都属于下面 3 种类型之一
    * **宏定义**。`#define` 指令定义一个宏，`#undef` 指令删除一个宏定义。
    * **文件包含**。`#include` 指令导致一个指定文件的内容被包含到程序中。
    * **条件编译**。`#if`、`#ifdef`、`#ifndef`、`#elif`、`#else` 和 `#endif` 指令可以根据预处理器可以测试的条件来确定是将一段文本块包含到程序中还是将其排除在程序之外。
2. 剩下的 `#error`、`#line` 和 `#pragma` 指令是更特殊的指令，较少用到。

### 几条适用于所有指令的规则。
* **指令都以 `#` 开始**。`#` 不需要在一行的行首，只要它之前只有空白字符就行。在 `#` 后是指令名，接着是指令所需要的其他信息。
* **在指令的符号之间可以插入任意数量的空格或水平制表符**。例如，下面的指令是合法的：
    ```cpp
    #     define     N     100
    ```
* **指令总是在第一个换行符处结束，除非明确地指明要延续**。如果想在下一行延续指令，我们必须在当前行的末尾使用 `\` 字符。例如，下面的指令定义了一个宏来表示硬盘的容量，按字节计算：
    ```cpp
    #define DISK_CAPACITY (SIDES *              \
                        TRACKS_PER_SIDE *    \
                        SECTORS_PER_TRACK *  \
                        BYTES_PER_SECTOR)
    ```
* **指令可以出现在程序中的任何地方**。但我们通常将 `#define` 和 `#include` 指令放在文件的开始，其他指令则放在后面，甚至可以放在函数定义的中间。
* **注释可以与指令放在同一行**。实际上，在宏定义的后面加一个注释来解释宏的含义是一种比较好的习惯：
    ```cpp
    #define FREEZING_PT 32.0f     /* freezing point of water */
    ```


## 宏定义
### 简单的宏
1. **简单的宏**（C 标准中称为 **对象式宏**）的定义有如下格式：
    ```cpp
    #define 标识符 替换列表
    ```
    **替换列表** 是一系列的预处理记号。
2. 宏的替换列表可以包括标识符、关键字、数值常量、字符常量、字符串字面量、操作符和排列。
3. 当预处理器遇到一个宏定义时，会做一个 “标识符” 代表 “替换列表” 的记录。在文件后面的内容中，不管标识符在哪里出现，预处理器都会用替换列表代替它。
4. 不要在宏定义中放置任何额外的符号，否则它们会被作为替换列表的一部分。一种常见的错误是在宏定义中使用 `=` ：
    ```cpp
    #define N = 100   /*** WRONG ***/
    ...
    int a[N];         /* becomes int a[= 100]; */
    ```
    在宏定义的末尾使用分号结尾是另一个常见错误：
    ```cpp
    #define N 100;    /*** WRONG ***/
    ...
    int a[N];         /* becomes int a[100;]; */
    ```
5. 编译器可以检测到宏定义中绝大多数由多余符号所导致的错误。但是，编译器只会将每一个使用这个宏的地方标为错误，而不会直接找到错误的根源——宏定义本身，因为宏定义已经被预处理器删除了。
6. 简单的宏主要用来定义那些被 Kernighan 和 Ritchie 称为 “明示常量”（manifest constant）的东西。 我们可以使用宏给数值、字符值和字符串值命名
    ```cpp
    #define STE_LEN 80
    #define TRUE    1
    #define FALSE   0
    #define PI      3.14159
    #define CR      '\r'
    #define EOS     '\0'
    #define MEM_ERR "Error: not enough memory"
    ```

#### 使用 `#define` 来为常量命名的优点
* **程序会更易读**。一个认真选择的名字可以帮助读者理解常量的意义。否则，程序将包含大量的 “魔法数”，很容易迷惑读者。
* **程序会更易于修改**。我们仅需要改变一个宏定义，就可以改变整个程序中出现的所有该常量的值。
* **可以帮助避免前后不一致或键盘输入错误**。假如数值常量 `3.14159` 在程序中大量出现，它可能会被意外地写成 `3.1416` 或 `3.14195`。

#### 宏的其他应用
* **可以对 C 语法做小的修改**。我们可以通过定义宏的方式给 C 语言符号添加别名，从而改变 C 语言的语法。例如，对于习惯使用 Pascal 的 `begin` 和 `end`（而不是 C 语言的 `{` 和 `}`）的程序员，可以定义下面的宏：
    ```cpp
    #define BEGIN {
    #define END   }
    ```
    我们甚至可以发明自己的语言。例如，我们可以创建一个 `LOOP` “语句”，来实现一个无限循环：
    ```cpp
    #define LOOP for (;;)
    ```
    当然，改变 C 语言的语法通常不是个好主意，因为它会使程序很难被其他程序员理解。
* **对类型重命名**。我们可以通过重命名 `int` 创建一个布尔类型：
    ```cpp
    #define BOOL int
    ```
    虽然有些程序员会使用宏定义的方式来实现此目的，但类型定义仍然是定义新类型的最佳方法。
* **控制条件编译**。宏在控制条件编译中起重要的作用。例如，在程序中出现的下面这行宏定义可能表明需要将程序在 “调试模式” 下进行编译，并使用额外的语句输出调试信息：
    ```cpp
    #define DEBUG
    ```
    这里顺便提一下，如上面的例子所示，宏定义中的替换列表为空是合法的。

### 带参数的宏
1. **带参数的宏**（也称为 **函数式宏**）的定义有如下格式：
    ```cpp
    #define 标识符(x1, x2,..., xn)替换列表
    ```
2. 其中 $x_1,x_2,\cdots,x_n$ 是标识符（宏的 **参数**）。这些参数可以在替换列表中根据需要出现任意次。
3. 在宏的名字和左括号之间必须 **没有空格**。如果有空格，预处理器会认为是在定义一个简单的宏，其中 $(x_1,x_2,\cdots,x_n)$ 是替换列表的一部分。
4. 当预处理器遇到带参数的宏时，会将宏定义存储起来以便后面使用。在后面的程序中，如果任何地方出现了标识符 $(y_1,y_2,\cdots,y_n)$ 格式的宏调用（其中 $y_1,y_2,\cdots,y_n$ 是一系列记号），预处理器会使用替换列表替代——使用 $y_1$ 替换 $x_1$，$y_2$ 替换 $x_2$，依此类推。
5. 例如，假定我们定义了如下的宏：
    ```cpp
    #define MAX(x,y)    ((x)>(y)?(x):(y))
    #define IS_EVEN(n)  ((n)%2==0)
    ```
6. 现在如果后面的程序中有如下语句：
    ```cpp
    i = MAX(j+k, m-n);
    if (IS_EVEN(i)) i++;
    ```
    预处理器会将这些行替换为
    ```cpp
    i = ((j+k)>(m-n)?(j+k):(m-n));
    if (((i)%2==0)) i++;
    ```
7. 带参数的宏可以包含空的参数列表，如下例所示：
    ```cpp
    #define getchar()  getc(stdin)
    ```
    空的参数列表不是必需的，但这样可以使 `getchar` 更像一个函数。
8. 带参数的宏不仅适用于模拟函数调用，还经常用作需要重复书写的代码段模式。如果我们已经写烦了语句
    ```cpp
    printf("%d\n", i);
    ```
    因为每次要显示一个整数i都要使用它，我们可以定义下面的宏，使显示整数变得简单些：
    ```cpp
    #define PRINT_INT(n)    printf("%d\n", n)
    ```
    一旦定义了 `PRINT_INT`，预处理器会将这行
    ```cpp
    PRINT_INT(i/j);
    ```
    转换为
    ```cpp
    printf("%d\n", i/j);
    ```
    
#### 带参数的宏替代真正的函数有两个优点
* **程序可能会稍微快些**。程序执行时调用函数通常会有些额外开销——存储上下文信息、复制参数的值等，而调用宏则没有这些运行开销。C99 的内联函数为我们提供了一种不使用宏而避免这一开销的办法。
* **宏更 “通用”**。与函数的参数不同，宏的参数没有类型。因此，只要预处理后的程序依然是合法的，宏可以接受任何类型的参数。例如，我们可以使用 `MAX` 宏从两个数中选出较大的一个，数的类型可以是 `int`、`long`、`float`、`double` 等。

#### 带参数的宏的一些缺点
##### 编译后的代码通常会变大
1. 每一处宏调用都会导致插入宏的替换列表，由此导致程序的源代码增加（因此编译后的代码变大）。宏使用得越频繁，这种效果就越明显。
2. 当宏调用嵌套时，这个问题会相互叠加从而使程序更加复杂。思考一下，如果我们用 `MAX` 宏来找出 3 个数中最大的数会怎样：
    ```cpp
    n = MAX(i, MAX(j, k));
    ```
3. 下面是预处理后的语句：
    ```cpp
    n = ((i)>(((j)>(k)?(j):(k)))?(i):(((j)>(k)?(j):(k))));
    ```

##### 宏参数没有类型检查
1. 当一个函数被调用时，编译器会检查每一个参数来确认它们是否是正确的类型。如果不是，要么将参数转换成正确的类型，要么由编译器产生一条出错消息。
2. 预处理器不会检查宏参数的类型，也不会进行类型转换。

##### 无法用一个指针来指向一个宏
1. C 语言允许指针指向函数，这在特定的编程条件下非常有用。
2. 宏会在预处理过程中被删除，所以不存在类似的 “指向宏的指针”。

##### 宏可能会不止一次地计算它的参数
1. 函数对它的参数只会计算一次，而宏可能会计算两次甚至更多次。如果参数有副作用，多次计算参数的值可能会产生不可预知的结果。
2. 考虑下面的例子，其中 `MAX` 的一个参数有副作用：
    ```cpp
    n = MAX(i++, j);
    ```
3. 下面是这条语句在预处理之后的结果：
    ```cpp
    n = ((i++)>(j)?(i++):(j));
    ```
4. 如果 `i` 大于 `j`，那么 `i` 可能会被（错误地）增加两次，同时 `n` 可能被赋予错误的值。
5. 由于多次计算宏的参数而导致的错误可能非常难于发现，因为宏调用和函数调用看起来是一样的。更糟糕的是，这类宏可能在大多数情况下可以正常工作，仅在特定参数有副作用时失效。为了自我保护，最好避免使用带有副作用的参数。

### `#` 运算符
1. 宏定义可以包含两个专用的运算符：`#` 和 `##`。编译器不会识别这两种运算符，它们会在预处理时被执行。
2. `#` 运算符将宏的一个参数转换为字符串字面量。它仅允许出现在带参数的宏的替换列表中。
3. `#` 运算符有许多用途，这里只来讨论其中的一种。假设我们决定在调试过程中使用 `PRINT_INT` 宏作为一个便捷的方法来输出整型变量或表达式的值。`#` 运算符可以使 `PRINT_INT` 为每个输出的值添加标签。
4. 下面是改进后的 `PRINT_INT`：
    ```cpp
    #define PRINT_INT(n) printf(#n " = %d\n", n)
    ```
5. `n` 之前的 `#` 运算符通知预处理器根据 `PRINT_INT` 的参数创建一个字符串字面量。因此，调用
    ```cpp
    PRINT_INT(i/j);
    ```
    会变为
    ```cpp
    printf("i/j" " = %d\n", i/j);
    ```
6. C 语言中相邻的字符串字面量会被合并。因此上边的语句等价于：
    ```cpp
    printf("i/j = %d\n", i/j);
    ```
7. 当程序执行时，`printf` 函数会同时显示表达式 `i/j` 和它的值。例如，如果 `i` 是 11，`j` 是 2 的话，输出为
    ```sh
    i/j = 5
    ```

### `##` 运算符
1. `##` 运算符被称为 “记号粘合”，可以将两个记号（如标识符）“粘合” 在一起，成为一个记号。
2. 如果其中一个操作数是宏参数，“粘合”会在形式参数被相应的实际参数替换后发生。
3. 考虑下面的宏：
    ```cpp
    #define MK_ID(n) i##n
    ```
4. 当 `MK_ID` 被调用时（比如 `MK_ID(1)`），预处理器首先使用实际参数（这个例子中是 `1`）替换形式参数 `n`。接着，预处理器将 `i` 和 `1` 合并成为一个记号（`i1`）。下面的声明使用MK_ID创建了3个标识符：
    ```cpp
    int MK_ID(1), MK_ID(2), MK_ID(3);
    ```
    预处理后这一声明变为：
    ```cpp
    int i1, i2, i3;
    ```
5. 为了找到一个有实际意义的 `##` 的应用，我们来重新思考前面提到过的 `MAX` 宏。如我们所见，当 `MAX` 的参数有副作用时会无法正常工作。
6. 一种解决方法是用 `MAX` 宏来写一个 `max` 函数。遗憾的是，仅一个 `max` 函数是不够的，我们可能需要一个实际参数是 `int` 值的 `max` 函数、一个实际参数为 `float` 值的 `max` 函数，等等。
7. 除了实际参数的类型和返回值的类型之外，这些函数都一样。因此，这样定义每一个函数似乎是个很蠢的做法。
8. 解决的办法是定义一个宏，并使它展开后成为 `max` 函数的定义。宏只有一个参数 `type`，表示实际参数和返回值的类型。
9. 这里还有个问题，如果我们用宏来创建多个 `max` 函数，程序将无法编译，C 语言不允许在同一文件中出现两个同名的函数。
10. 为了解决这个问题，我们用 `##` 运算符为每个版本的 `max` 函数构造不同的名字。下面是宏的形式：
    ```cpp
    #define GENERIC_MAX(type)         \
    type type##_max(type x, type y)   \
    {                                 \
        return x > y ? x : y;           \
    }
    ```
11. 现在，假如我们需要一个针对 `float` 值的 `max` 函数。下面是使用 `GENERIC_MAX` 宏来定义这一函数的方法：
    ```cpp
    GENERIC_MAX(float)
    ```
12. 预处理器会将这行展开为下面的代码：
    ```cpp
    float float_max(float x, float y) { return x > y ? x : y; }
    ```

### 宏的通用属性
现在我们已经讨论过了简单的宏和带参数的宏，我们来看一下它们都需要遵守的规则。

#### 宏的替换列表可以包含对其他宏的调用
1. 例如，我们可以用宏 `PI` 来定义宏 `TWO_PI`：
    ```cpp
    #define PI      3.14159
    #define TWO_PI  (2*PI)
    ```
2. 当预处理器在后面的程序中遇到 `TWO_PI` 时，会将它替换成 `(2*PI)`。接着，预处理器会重新检查替换列表，看它是否包含其他宏的调用（在这个例子中，调用了宏 `PI`）。预处理器会不断重新检查替换列表，直到将所有的宏名字都替换掉为止。

#### 预处理器只会替换完整的记号，而不会替换记号的片断
因此，预处理器会忽略嵌在标识符、字符常量、字符串字面量之中的宏名。例如，假设程序含有如下代码行：
```cpp
#define SIZE 256

int BUFFER_SIZE;

if (BUFFER_SIZE > SIZE)
puts("Error ： SIZE exceeded");
```
预处理后这些代码行会变为
```cpp
int BUFFER_SIZE;

if (BUFFER_SIZE > 256)
  puts("Error: SIZE exceeded");
```

#### 宏定义的作用范围通常到出现这个宏的文件末尾
由于宏是由预处理器处理的，它们不遵从通常的作用域规则。定义在函数中的宏并不是仅在函数内起作用，而是作用到文件末尾。

#### 宏不可以被定义两遍，除非新的定义与旧的定义是一样的
小的间隔上的差异是允许的，但是宏的替换列表（和参数，如果有的话）中的记号都必须一致。

#### 宏可以使用 `#undef` 指令 “取消定义”
1. #undef指令有如下形式：
    ```cpp
    #undef  标识符
    ```
2. 其中标识符是一个宏名。例如，指令
    ```cpp
    #undef N
    ```
    会删除宏 `N` 当前的定义。
3. 如果 `N` 没有被定义成一个宏，`#undef` 指令没有任何作用。
4. `#undef` 指令的一个用途是取消宏的现有定义，以便于重新给出新的定义。





































## References
* [C语言程序设计](https://book.douban.com/subject/4279678/)