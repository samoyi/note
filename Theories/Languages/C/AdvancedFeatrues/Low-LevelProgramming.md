# Low-Level Programming



<!-- TOC -->

- [Low-Level Programming](#low-level-programming)
    - [Summary](#summary)
    - [位运算符](#位运算符)
        - [移位运算符](#移位运算符)
        - [按位求反运算符、按位与运算符、按位异或运算符和按位或运算符](#按位求反运算符按位与运算符按位异或运算符和按位或运算符)
        - [用位运算符访问位](#用位运算符访问位)
            - [位的设置](#位的设置)
            - [位的清除](#位的清除)
            - [位的测试](#位的测试)
            - [给被操作的位起名](#给被操作的位起名)
        - [用位运算符访问位域](#用位运算符访问位域)
            - [修改位域](#修改位域)
            - [获取位域](#获取位域)
        - [XOR 加密](#xor-加密)
    - [References](#references)

<!-- /TOC -->


## Summary
1. 位操作和其他一些底层运算在编写系统程序（包括编译器和操作系统）、加密程序、图形程序以及其他一些需要高执行速度或高效地利用空间的程序时非常有用。
2. 本章中描述的一些技术需要用到数据在内存中如何存储的知识，这对不同的机器和编译器可能会不同。依赖于这些技术很可能会使程序丧失可移植性，因此除非必要，否则最好尽量避免使用它们。如果确实需要，尽量将使用限制在程序的特定模块中，不要分散在各处。同时，最重要的是确保使用文档记录所做的事！


## 位运算符
C 语言提供了 6 个位运算符。这些运算符可以用于对整数数据进行位运算。

### 移位运算符
1. 移位运算符可以通过将位向左或向右移动来变换整数的二进制表示。C 语言提供了两个移位运算符：`<<`（左移位）和 `>>`（右移位）。
2. 运算符 `<<` 和运算符 `>>` 的操作数可以是任意整数类型（包括 `char` 型）。对两个操作数都会进行整数提升，返回值的类型是左操作数提升后的类型。
3. `i << j` 的值是将 `i` 中的位左移 `j` 位后的结果。每次从 `i` 的最左端溢出一位，在 `i` 的最右端补一个 `0` 位。
4. `i >> j` 的值是将 `i` 中的位右移 `j` 位后的结果。如果 `i` 是无符号数或非负值，则需要在 `i` 的左端补 `0`；如果 `i` 是负值，其结果是由实现定义的：一些实现会在左端补 `0`，其他一些实现会保留符号位而补 `1`。
5. 为了可移植性，最好仅对无符号数进行移位运算。
6. 下面的例子展示了对数 13 应用移位运算符的效果
    ```cpp
    unsigned short i, j;

    i = 13;       /* i is now 13 (binary 0000000000001101) */
    j = i << 2;   /* j is now 52 (binary 0000000000110100) */
    j = i >> 2;   /* j is now  3 (binary 0000000000000011) */
    printf("%u", i); // 13
    ```
    两个运算符都不会改变它的操作数
7. 如果要通过移位改变变量，需要使用复合赋值运算符 `<<=` 和 `>>=`
    ```cpp
    unsigned short i;

    i = 13;       /* i is now 13 (binary 0000000000001101) */
    i <<= 2;      /* i is now 52 (binary 0000000000110100) */
    i >>= 4;      /* i is now  3 (binary 0000000000000011) */
    ```
8. 移位运算符的优先级比算术运算符的优先级低，因此可能产生意料之外的结果。例如，`i << 2 + 1` 等同于 `i << (2 + 1)`，而不是 `(i << 2) + 1`
    ```cpp
    unsigned short i;

    i = 13;       /* i is now 13 (binary 0000000000001101) */

    13 << 2 + 1;    // 104     (binary 0000000001101000)
    13 << (2 + 1);  // 104
    (13 << 2) + 1;  // 53
    ```

### 按位求反运算符、按位与运算符、按位异或运算符和按位或运算符
1. 按位求反运算符 `~` 是一元运算符，对其操作数会进行整数提升。其他运算符都是二元运算符，对其操作数进行常用的算术转换。
2. 运算符 `~`、`&`、`^` 和 `|` 对操作数的每一位执行布尔运算。`~` 运算符会产生对操作数求反的结果，即将每一个 0 替换成 1，将每一个 1 替换成 0。运算符 `&` 对两个操作数相应的位执行逻辑与运算。运算符 `^` 和 `|` 相似（都是对两个操作数执行逻辑或运算），不同的是当两个操作数的位都是 1 时，`^` 产生 0 而 `|` 产生 1。
3. 不要将位运算符 `&` 和 `|` 与逻辑运算符 `&&` 和 `||` 相混淆。 有时候位运算会得到与逻辑运算相同的结果，但它们绝不等同。
4. 下面的例子演示了运算符 `~`、`&`、`^`、`|` 的作用：
    ```cpp
    unsigned short i, j, k;

    i = 21;       /* i is now     21 (binary 0000000000010101) */
    j = 56;       /* j is now     56 (binary 0000000000111000) */
    k = ~i;       /* k is now  65514 (binary 1111111111101010) */
    printf("%u\n", k);
    k = i & j;    /* k is now     16 (binary 0000000000010000) */
    printf("%u\n", k);
    k = i ^ j;    /* k is now     45 (binary 0000000000101101) */
    printf("%u\n", k);
    k = i | j;    /* k is now     61 (binary 0000000000111101) */
    printf("%u\n", k);
    ```
    其中对 `~i` 所显示的值是基于 `unsigned short` 类型的值占有 16 位的假设。
5. 对运算符 `~` 需要特别注意，因为它可以帮助我们使底层程序的可移植性更好。假设我们需要一个整数，它的所有位都为 1。最好的方法是使用 `~0`，因为它不会依赖于整数所包含的位的个数。类似地，如果我们需要一个整数，除了最后 5 位其他的位全都为 1，我们可以写成 `~0x1f`。
6. 四个运算符优先级不同：`~` > `&` > `^` > `|`。因此，可以在表达式中组合使用这些运算符，而不必加括号。例如，可以写 `i & ~j|k` 而不需要写成 `(i & (~j))|k`；同样，可以写 `i ^ j & ~k` 而不需要写成 `i ^ (j & (~k))`。
7. 运算符 `&`、`^` 和 `|` 的优先级比关系运算符和判等运算符低。因此，下面的语句
    ```cpp
    if (status & 0x4000 != 0) ...
    ```
    会先计算 `0x4000 != 0`（结果是 1），接着判断 `status & 1` 是否非 0，而不是判断 `status & 0x4000` 是否非 0。
8. 复合赋值运算符 `&=`、`^=` 和 `|=` 分别对应于位运算符 `&`、`^` 和 `|`。

### 用位运算符访问位
1. 在进行底层编程时，经常会需要将信息存储为单个位或一组位。例如，在编写图形程序时，我们可能会需要将两个或更多的像素挤在一个字节中。使用位运算符，我们可以提取或修改存储在少数几个位中的数据。
2. 假设 `i` 是一个 16 位的 `unsigned short` 变量，我们来看看如何对 `i` 进行最常用的单位运算。

#### 位的设置
1. 假设我们需要设置 `i` 的第 4 位（我们假定最高有效位为第 15 位，最低有效位为第 0 位）。设置第 4 位的最简单方法是将 `i` 的值与常量 `0x0010`（一个在第 4 位上为 1 的 “掩码”）进行或运算：
    ```cpp
    i = 0x0000;          /* i is now 0000000000000000 */
    i |= 0x0010;         /* i is now 0000000000010000 */
    ```
2. 更通用的做法是，如果需要设置的位的位置存储在变量 `j` 中，可以使用移位运算符来构造掩码：
    ```cpp
    i |= 1 << j;        /* sets bit j */
    ```
3. 例如，如果 `j` 的值为 3，`1 << j` 是 `0x0008`。

#### 位的清除
1. 要清除 `i` 的第 4 位，可以使用第 4 位为 0、其他位为 1 的掩码：
    ```cpp
    unsigned short i, mask;

    i = 0x00ff;             /* i is now 0000000011111111 */
    mask = ~0x0010;         /* mask is  1111111111101111 */
    printf("%u\n", mask);   
    i &= mask;              /* i is now 0000000011101111 */
    printf("%u\n", i);      // 239
    ```
2. 同样可以使用左移的方法来获得掩码，只不过要多一步取反
    ```cpp
    unsigned short i, mask;

    i = 0x00ff;             /* i is now 0000000011111111 */
    mask = ~(1 << 4) ;      /* mask is  1111111111101111 */
    printf("%u\n", mask);   
    i &= mask;              /* i is now 0000000011101111 */
    printf("%u\n", i);      // 239
    ```

#### 位的测试
1. 下面的 `if` 语句测试 `i` 的第 4 位是否被设置：
    ```cpp
    if (i & 0x0010) ...              /* tests bit 4 */
    ```
2. 如果要测试第 `j` 位是否被设置，可以使用下面的语句：
    ```cpp
    if (i & 1 << j)...  /* tests bit j */
    ```

#### 给被操作的位起名
1. 为了使对于位的操作更容易，经常会给它们起名字。例如，如果我们想要使一个数的第 0、1 和 2 位对应于相应的颜色蓝、绿和红。首先，定义分别代表这三个位的位置的名字：
    ```cpp
    #define BLUE   0b1
    #define GREEN  0b10
    #define RED    0b100
    ```
2. 设置、清除或测试 `BLUE` 位可以如下进行：
    ```cpp
    unsigned short i = 0;   

    i |= BLUE;                 // sets BLUE bit
    printf("%u\n", i);         // 1
    printf("%d\n", i & BLUE);  // 1 (tests GREEN bit)

    i &= ~BLUE;                // clears BLUE bit
    printf("%u\n", i);         // 0
    printf("%d\n", i & BLUE);  // 0 (tests GREEN bit)
    ```
3. 设置、清除或测试 `GREEN` 位可以如下进行：
    ```cpp
    unsigned short i = 0;   

    i |= GREEN;                 // sets GREEN bit
    printf("%u\n", i);          // 2
    printf("%d\n", i & GREEN);  // 2 (tests GREEN bit)

    i &= ~GREEN;                // clears GREEN bit
    printf("%u\n", i);          // 0
    printf("%d\n", i & GREEN);  // 0 (tests GREEN bit)
    ```
4. 同时设置、清除或测试几个位也一样
    ```cpp
    unsigned short i = 0;   


    i |= BLUE | GREEN;                   // sets BLUE and GREEN bits
    printf("%u\n", i);                   // 3
    printf("%u\n", i & (BLUE | GREEN));  // 3 (tests BLUE and GREEN bits)

    i &= ~(BLUE | GREEN);                // clears BLUE and GREEN bits
    printf("%u\n", i);                   // 0
    printf("%u\n", i & (BLUE | GREEN));  // 0 (tests BLUE and GREEN bits)
    ```

### 用位运算符访问位域
处理一组连续的位（**位域**）比处理单个位要复杂一点。下面是两种最常见的位域操作的例子。

#### 修改位域
1. 修改位域需要使用按位与（用来清除位域），接着使用按位或（用来将新的位存入位域）。
2. 下面的语句显示了如何将二进制的值 101 存入变量 `i` 的第 4 位至第 6 位：
    ```cpp
    unsigned short i = 0;   

    i = 0b1111111;
    printf("%d\n", i); // 127
    // 0x70 是 1110000
    // 0x50 是 1010000
    i = i & ~0x0070 | 0x0050;       /* stores 101 in bits 4-6 */
    printf("%d\n", i); // 95
    ```
    运算符 `&` 清除了 `i` 的第 4 位至第 6 位，接着运算符 `|` 设置了第 6 位和第 4 位。
3. 为了使上面的例子更通用，我们假设变量 `j` 包含了需要存储到 `i` 的第 4 位至第 6 位的值。我们需要在执行按位或操作之前将 `j` 移位至相应的位置
    ```cpp
    unsigned short i = 0, j = 0b101;   

    i = 0b1111111;
    i = (i & ~0x0070) | (j << 4);
    printf("%d\n", i); // 95
    ``` 
4. 运算符 `|` 的优先级比运算符 `&` 和 `<<` 的优先级低，所以可以去掉圆括号：
    ```cpp
    i = i & ~0x0070 | j << 4;
    ```

#### 获取位域
1. 当位域处在数的右端（最低有效位）时，获得它的值非常方便。例如，下面的语句获取了变量 `i` 的第 0 位至第 2 位：
    ```cpp
    unsigned short i = 0, j = 0;   

    i = 0b0101;
    j = i & 0x0007;
    printf("%u", j); // 5
    ```
2. 如果位域不在 `i` 的右端，那首先需要将位域移位至右端，再使用运算符 `&` 提取位域。例如，要获取 `i` 的第 4 位至第 6 位，可以使用下面的语句
    ```cpp
    unsigned short i = 0, j = 0;   

    i = 0b01100101;
    j = (i >> 4) & 0x0007;
    printf("%u", j); // 6
    ```

### XOR 加密
1. 对数据加密的一种最简单的方法就是，将每一个字符与一个密钥进行异或（XOR）运算。假设密钥是一个 `&` 字符。如果将它与字符 `z` 异或，我们会得到字符 `\`（假定使用 ASCII 字符集）。具体计算如下：
    <img src="./images/13.png" width="300" style="display: block; margin: 5px 0 10px;" />
2. 要将消息解密，只需采用相同的算法。换言之，只需将加密后的消息再次加密，即可得到原始的消息（TODO，为什么会是这样）。例如，如果将 `&` 字符与 `\` 字符异或，就可以得到原来的字符 `z`：
    <img src="./images/14.png" width="300" style="display: block; margin: 5px 0 10px;" />
3. 下面的程序 `xor.c` 通过将每个字符与 `&` 字符进行异或来加密消息。原始消息可以由用户输入，或者使用输入重定向从文件读入。加密后的消息可以在屏幕上显示，也可以通过输出重定向存入文件中。例如，假设文件 `msg` 包含下面的内容：
    ```
    Trust not him with your secrets, who, when left
    alone in your room, turns over your papers.
                --Johann Kaspar Lavater (1741-1801)
    ```
4. 为了对文件 `msg` 加密，并将加密后的消息存储在文件 `newmsg` 中，需要使用下面的命令：
    ```cpp
    xor <msg >newmsg
    ```
5. 文件 `newmsg` 将包含下面的内容：
    ```
    rTSUR HIR NOK QORN _IST UCETCRU, QNI, QNCH JC@R
    GJIHC OH _IST TIIK, RSTHU IPCT _IST VGVCTU.
                --lINGHH mGUVGT jGPGRCT (1741-1801)
    ```
6. 要恢复原始消息，需要使用命令
    ```cpp
    xor <newmsg
    ```
    将原始消息显示在屏幕上。
7. 正如在例子中看到的，程序不会改变一些字符，包括数字。将这些字符与 `&` 异或会产生不可见的控制字符，这在一些操作系统中会引发问题。而这里，为了安全我们将使用 `isprint` 函数来确保原始字符和新字符（加密后的字符）都是可打印字符（即不是控制字符）。如果不满足，让程序写原始字符，而不用新字符。
8. 下面是完成的程序
    ```cpp
    /* Performs XOR encryption */


    #include <ctype.h>
    #include <stdio.h>

    #define KEY '&'

    int main(void)
    {
        int orig_char, new_char;

        while ((orig_char = getchar()) != EOF) {
            new_char = orig_char ^ KEY;
            if (isprint(orig_char) && isprint(new_char))
                putchar(new_char);
            else
                putchar(orig_char);
        }

        return 0;
    }
    ```








































































## References
* [C语言程序设计](https://book.douban.com/subject/4279678/)