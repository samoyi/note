


## `numpy.argmax(a, axis=None, out=None, *, keepdims=<no value>)`
1. `axis`: By default, the index is into the flattened array, otherwise along the specified axis
2. `axis` 取合理的最大值时，是在最内层的一维数组 **之内** 比较，也就是比较的项是在同一个中括号里，不会和其他中括号里的值比较。可以理解为沿 x 轴方向比较。
3. `axis` 取合理的最大值减一时（此时至少要是二维数组），是在最内层的一维数组 **之间** 比较，也就是比较的项是跨越了一个中括号。可以理解为沿 y 轴方向比较。
4. `axis` 取合理的最大值减二时（此时至少要是三维数组），是在最内层的 **二维数组** 的对应位置之间比较，也就是比较的项位于不同的二维数组里，但它们在自己的二维数组里的坐标是想相同的。可以理解为沿 z 轴方向比较。三维数组这种情况就是 `axis` 取 0 时。
5. `axis` 取 0 时，是从最外层每个数组项里分别选出一个进行比较，选出的项在各自的 N 维数组里具有相同的坐标。

### 一维数组
```py
arr = np.array([1, 2, 5, 3, 4])

result = np.argmax(arr)
print(result) # 2
# 把数组摊平然后找最大的。但数组本来就是平的，所以和制定 axis 为 0 没区别

result = np.argmax(arr, 0)
print(result) # 2
# 此时合理的最大值就是 0，最内层的一维数组也就只有唯一的一个数组
# 也可以理解成从最外层的每个数组项里分别选出一个比较，但现在最外层的数组项也就是个那一个个数

result = np.argmax(arr, 1)
# numpy.exceptions.AxisError: axis 1 is out of bounds for array of dimension 1
# 合理的最大值就是 0
```

### 二维数组
```py
arr = np.array([
    [14, 11, 12],
    [13, 16, 15]
])

result = np.argmax(arr)
print(result) # 4
# 把数组摊平然后找最大的。也就是 16 所在的索引

result = np.argmax(arr, 1)
print(result) # [0 1] 
# 1 此时合理的最大值是，最内层的一维数组是 [14, 11, 12] 和 [13, 16, 15]，在它们之内分别寻找而不是之间。第一个一维数组之内的最大值是 14，索引 0；第二个一维数组之内的最大值是 16，索引 1。

result = np.argmax(arr, 0)
print(result) # [0 1 1]
# 此时合理的最大值减一就是 0，也就是要从最内层的一维数组 **之间** 比较，也就是在 [14, 11, 12] 和 [13, 16, 15] 之间比较对应的数组项
# 也可以理解为 axis 取 0 时从最外层每个数组项（两个数组项分别是 [14, 11, 12] 和 [13, 16, 15]）里分别选出一个进行比较
# 如果理解为沿 y 轴方向，则 [14, 11, 12] 的每一项在 y 轴的坐标都是 0，[13, 16, 15] 的每一项在 y 轴的坐标都是 1
# 14 > 13，所以这次比较结果是 14 的 y 轴索引，也就是 0；11 < 16，所以这次比较结果是 16 的 y 轴索引，也就是 1；12 < 15，所以这次比较结果是 15 的 y 轴索引，也就是 1。
```

### 三维数组
```py
arr = np.array(
    [
        [
            [1, 2], 
            [33, 6],
            [5, 4]
        ],
        [
            [10, 20], 
            [30, 60],
            [50, 40]
        ]
    ]
)

result = np.argmax(arr)
print(result) # 9
# 把数组摊平然后找最大的。也就是 60 所在的索引

result = np.argmax(arr, 2)
print(result)
# [
#     [1 0 0]
#     [1 1 0]
# ]
# 2 此时合理的最大值就，最内层的一维数组一共有六个，每个都是有两个整数项
# 前三个的最大值分别是 2 33 5，对应的索引分别是 1 0 0。它们三个所在的数组外层还有一个数组（中间那一层中括号），所以它们三个对应的索引值也要保持在这层数组里；
# 后三个的最大值分别是 20 60 50，对应的索引分别是 1 1 0。它们三个所在的数组外层同样还有一个数组（中间那一层中括号），所以它们三个对应的索引值也要保持在这层数组里；
# 最后，还有一个最外层的数组，也就是最外层的中括号，所以现在一共有两层数组。

result = np.argmax(arr, 1)
print(result)
# [
#     [1 1]
#     [2 1]
# ]
# 1 此时是合理的最大值减一时，也就是要在最内层的一维数组 **之间** 比较。
# 这里有两组最内层的一维数组：第一组是 [1, 2] [33, 6] [5, 4]，第二组是 [10, 20] [30, 60] [50, 40]
# 所以现在就要沿着 y 轴方向分别在这两组内进行比较。
# 第一组第一个 y 轴方向最大值是 33，y 轴坐标是 1；第二个 y 轴方向最大值是 6，y 轴坐标也是 1；
# 第二组第一个 y 轴方向最大值是 50，y 轴坐标是 2；第二个 y 轴方向最大值是 60，y 轴坐标也是 1。

result = np.argmax(arr, 0)
print(result)
# [
#     [1 1]
#     [0 1]
#     [1 1]
# ]
# 0 此时是合理的最大值减二时，要在最内层的 **二维数组** 的对应位置之间比较。最内层的一共有两个，都是 2x3 的二维数组；
# 或者也可以理解为 axis 取 0 时，是从最外层每个数组项里分别选出一个进行比较，最外层的数组项就是那两个 2x3 的二维数组
# 第一个二维数组的 z 轴坐标是 0，第二个二维数组的 z 轴坐标是 1；
# 现在就是要在这两个二维数组之间，挑选相同坐标的值进行比较：
#     挑选 [0, 0] 坐标的，分别是 1 和 10，10 更大，10 所在的二维数组的 z 轴坐标是 1；
#     挑选 [0, 1] 坐标的，分别是 2 和 20，20 更大，20 所在的二维数组的 z 轴坐标是 1；
#     挑选 [1, 0] 坐标的，分别是 33 和 30，33 更大，33 所在的二维数组的 z 轴坐标是 0；
#     挑选 [1, 1] 坐标的，分别是 6 和 60，60 更大，60 所在的二维数组的 z 轴坐标是 1；
#     挑选 [2, 0] 坐标的，分别是 5 和 50，150 更大，50 所在的二维数组的 z 轴坐标是 1；
#     挑选 [2, 1] 坐标的，分别是 4 和 40，40 更大，40 所在的二维数组的 z 轴坐标是 1；
# 这样比较完索引后，两个二维数组会合并为一个
# [
#     [1, 2], 
#     [33, 6],
#     [5, 4]
# ]
# 和 
# [
#     [10, 20], 
#     [30, 60],
#     [50, 40]
# ]
# 比较后会合并为 
# [
#     [1, 1], 
#     [0, 1],
#     [1, 1]
# ]
# 也可以说，本来最外层是一个两项数组，每项是一个二维数组。现在这两项比较后合并了，那最外层就是一个单项数组了。不过这里单项数组会直接成为单项，就像一维数组经过 np.argmax 后会直接变成一个数一样
```


## `numpy.max` 的 `axis` 参数在三维数组时的情况
```py
import numpy as np

arr = np.array(
    [
        [
            [1, 2], 
            [33, 6],
            [5, 4]
        ],
        [
            [10, 20], 
            [30, 60],
            [50, 40]
        ]
    ]
)

print( np.max(arr, axis=0) )
# [
#     [10 20]
#     [33 60]
#     [50 40]
# ]
# 这是一个 (2, 3, 2) 数组。想象一个底边是 3×2 高度是 2 的长方体。这个立方体一共有两层，每层都是三行两列。
# 我们把它想象成一栋楼，这个楼一共有两层，每层有六个单元，一共有十二户：
#   第一个单元是 1 和 10
#   第二个单元是 2 和 20
#   第三个单元是 33 和 30
#   第四个单元是 6 和 60
#   第五个单元是 5 和 50
#   第六个单元是 4 和 40
# axis=0 时，就是要挑选出每单元的最大值。也就是在一个单元中的不同楼层之间比较。那么这个挑选会让多层楼（这里是两层）合并为一层，最终会是一个 3×2 的数组

print( np.max(arr, axis=1) )
# [
#     [33 6]
#     [50 60]
# ]
# 挑选出每列的最大值
#   从第一个矩阵（第一层）挑选：第一列的最大值是 33，第二列的最大值是 6
#   从第二个矩阵（第二层）挑选：第一列的最大值是 50，第二列的最大值是 60
# 因为是比较每行中相同位置的元素，所以会让多个行合并为一个行

print( np.max(arr, axis=2) )
# [
#     [ 2 33  5]
#     [20 60 50]
# ]
# 挑选出每行的最大值
#   从第一个矩阵（第一层）挑选：第一行的最大值是 2，第二行的最大值是 33，第三行的最大值是 5
#   从第二个矩阵（第二层）挑选：第一行的最大值是 20，第二行的最大值是 60，第三行的最大值是 50
# 因为是比较每列中相同位置的元素，所以会让多个列合并为一个列
```