# Summary


<!-- TOC -->

- [Summary](#summary)
    - [用二进制数表示计算机信息的原因](#用二进制数表示计算机信息的原因)
    - [补数](#补数)
        - [减法计算](#减法计算)
        - [有符号整数和无符号整数](#有符号整数和无符号整数)
    - [逻辑右移和算术右移的区别](#逻辑右移和算术右移的区别)
        - [符号扩充](#符号扩充)
    - [References](#references)

<!-- /TOC -->


## 用二进制数表示计算机信息的原因
1. 计算机内部是由 IC 这种电子部件构成的，IC 的所有引脚，只有通电（电压为零）和不通电（电压非零）两个状态。也就是说，IC 的一个引脚，只能表示两个状态。（还存在不接收电流信号的高阻抗（high impedance）状态，但这里暂时不考虑）
2. 一个引脚对应一位（bit），所以比如 32 位微处理器，具有 32 个引脚以用于信息的输入和输出，一次可以处理 32 位（4 字节）的二进制数信息。


## 补数
1. 二进制数中表示负数值时，一般会把最高位作为符号来使用，因此我们把这个最高位称为 **符号位**。符号位是 0 时表示正数 ，符号位是 1 时表示负数。
2. 那么 -1 用 8 位二进制数来表示的话是什么样的呢？很可能会认为 “1 的二进制数是 00000001，因此 -1 就是 10000001”，但这个答案是错的，正确答案是 11111111。这是因为计算机使用 **补数** 来表述负数。
3. 计算机在做减法运算时，实际上内部是在做加法运算。为了用加法运算来实现减法运算，在表示负数时就需要使用二进制的补数。补数就是用正数来表示负数。
4. 为了获得补数，我们需要将二进制数的各数位的数值全部取反，然后再将结果加 1。
5. 例如，用 8 位二进制数表示 -1 时，只需求得 1——也就是 00000001 的补数即可。具体来说，就是将 00000001 各数位的 0 取反成 1，1 取反成 0，然后再将取反的结果加 1，最后就转化成了 11111111。

### 减法计算
1. 补数的思考方式，虽然直观上不易理解，但逻辑上却非常严谨。以 1-1 为例，也就是 1 + (-1) 这一运算。
2. 首先，让我们将 -1 表示成 10000001（错误的表示方法）来运算，00000001＋10000001 = 10000010，很明显结果不是 0。
3. 接下来，让我们把 -1 表示成 11111111（正确的表示方法）来进行运算。 00000001+11111111 确实为 0（00000000）。这个运算中出现了最高位溢出的情况，不过，正如之前所介绍的那样，对于溢出的位，计算机会直接忽略掉。
4. 当运算结果为负数时，计算结果的值也是以补数的形式来表示的。比如 3-5 这个运算，用 8 位二进制数表示，3 为 00000011，而 5 为 00000101 的补数，也就是 11111011。因此 3-5 其实就是 00000011 + 11111011 的运算，结果为 11111110，但这是个补数形式。
5. 最高位变成了 1，说明是一个负数。但它是补数形式，我们需要还原成基本的形式才能看出来它的值。该怎么求补数的原数呢？
6. 注意到，一个数的补数和原来的值相加，结果为 0。因为取反后相加所有的数位都会变成 1，再加一则会变为 0。也就是说，一个数的补数是它的相反数。
7. 那么对上面的负数的补数结果 11111110 再求补数，就会得到结果的绝对值，即 00000010。所以上面的结果就是 -2。

### 有符号整数和无符号整数
1. 编程语言包含的整数数据类型中，有的可以处理负数，有的则不能处理。例如，C 语言的数据类型中，既有不能处理负数的 unsigned short 类型，也有能处理负数的 short 类型。
2. 这两种类型，都是 2 字节（16 位）的变量，都能表示 2 的 16 次幂 = 65536 种值，这一点是相同的。不过，值的范围有所不同，short 类型是 -32768～32767，unsigned short 类型是 0～65535。
3. short 类型和 unsigned short 类型的另一个不同点在于，如果二进制数的最高位为 1：short 类型会被看作负数的补数形式，而 unsigned short 类型则会被看做 32768（1000000000000000）以上的值。
4. 注意到 short 类型的负数要比正数多一个，因为在最高位为 0 的所有可能中，有一个要用来表示 0。


## 逻辑右移和算术右移的区别
1. 右移有移位后在最高位补 0 和补 1 两种情况。
2. 当二进制数的值表示图形模式而非数值时，移位后需要在最高位补 0。类似于霓虹灯往右滚动的效果。这就称为 **逻辑右移**
    <img src="./images/01.png" width="600" style="display: block; margin: 5px 0 10px;" />
3. 将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值，这就称为 **算术右移**。如果数值是用补数表示的负数值，那么右移后在空出来的最高位补 1，就可以正确地实现 1/2、1/4、1/8 等的数值运算。如果是正数，只需在最高位补 0 即可。
4. 现在我们来看一个右移的例子。将 -4（11111100）右移两位。这时，逻辑右移的情况下结果就会变成 00111111，也就是十进制数 63，显然不对。而算术右移的情况下，结果就会变成 11111111，也就是用补数表示的 -1。    
5. 只有在右移时才必须区分逻辑位移和算术位移。左移时，无论是图形模式（逻辑左移）还是相乘运算（算术左移），都只需在空出来的低位补 0 即可。

### 符号扩充
1. 以 8 位二进制数为例，符号扩充就是指在保持值不变的前提下将其转换成 16 位和 32 位的二进制数。
2. 将 01111111 这个正的 8 位二进制数转换成 16 位二进制数时，很容易就能得出 0000000001111111 这个正确结果。
3. 补数 11111111 这样的数值，该如何处理比较好呢？
4. 因为扩充后要相同，那扩充前后的相反数也要相同。相反数是正数，如果要相同，那么往高位填充的就肯定要是 0。那负数的补数形式前面填充的就要是 1。
5. 所以 11111111 要填充为 1111111111111111。
6. 也就是说，不管是正数还是用补数表示的负数，为了实现符号扩充，都只需用符号位的值（0 或者 1）填充高位即可。


## References
* [程序是怎样跑起来的](https://book.douban.com/subject/26365491/)