# 添加左括号


<!-- TOC -->

- [添加左括号](#添加左括号)
    - [设计思想](#设计思想)
        - [栈式暂存](#栈式暂存)
        - [栈式递归](#栈式递归)
    - [要求](#要求)
    - [思路](#思路)
    - [算法](#算法)
    - [实现](#实现)

<!-- /TOC -->


## 设计思想
### 栈式暂存
读取数据暂时不用，但需要保存下来。之后要用的时候，需要用到最近保存的结果。

### 栈式递归
计算数作为待用的数据保存下来，计算之后的计算结果，还会作为下次的计算数。


## 要求
1. 编写一段程序，从标准输入得到一个缺少左括号的表达式并打印出补全括号之后的中序完全括号表达式。
2. 例如，给定输入：
    ```
    1 + 2 ) * 3 - 4 ) * 5 - 6 ) ) )
    ```
　　你的程序应该输出：
    ```
    ( ( 1 + 2 ) * ( ( 3 - 4 ) * ( 5 - 6 ) ) )
    ```


## 思路
1. 看到一个右括号，就找到它左边紧挨着的两个运算数和一个运算符组成的运算式，然后在这个运算式左边加上左括号。
2. 在发现 `2` 右边的的右括号时，它左边的运算式是 `1 + 2`，所以在这个运算左边加上左括号
    ```
    ( 1 + 2 ) * 3 - 4 ) * 5 - 6 ) ) )
    ```
3. 继续往右，发现 4 后面的右括号，它左边的运算式是 `3 - 4`，加上左括号
    ```
    ( 1 + 2 ) * ( 3 - 4 ) * 5 - 6 ) ) )
    ```
4. 继续往右，发现 6 后面的右括号，它左边的运算式是 `5 - 6`，加上左括号
    ```
    ( 1 + 2 ) * ( 3 - 4 ) * ( 5 - 6 ) ) )
    ```
5. 继续往右，发现倒数第二个右括号，它左边的运算式是 `( 3 - 4 ) * ( 5 - 6 )`，加上左括号
    ```
    ( 1 + 2 ) * ( ( 3 - 4 ) * ( 5 - 6 ) ) )
    ```
6. 继续往右，发现最后一个右括号，它左边的运算式是 `( 1 + 2 ) * ( ( 3 - 4 ) * ( 5 - 6 ) )`，加上左括号
    ```
    ( ( 1 + 2 ) * ( ( 3 - 4 ) * ( 5 - 6 ) ) )
    ```


## 算法
1. 在加前三个左括号的时候，思路比较简单，因为左边的运算式就是左边的三个字符，找到并加上就行了。
2. 从左往右遍历字符，如果不是右括号就先保存起来，发现以后右，就找到刚才保存的两个运算数和一个运算符，加上左括号。
3. 但是加后两个左括号的时候，左边的运算式是复合运算式了。这时的问题就要怎么确定这个运算式到底是什么。
4. 既然是复合的，也就说，之前计算结果，现在也变成了一个运算数。
5. 那么，在第 2 步补全一个括号之后，就应该把这个补全的部分整体作为一个运算数再记录下来。
6. 保存运算符和运算数的数据结构应该用栈，因为在遇到右括号时，是要取出最近发现的两个运算数和一个运算符。


## 实现
```js
function foo (str) {
    let tokens = str.split(' ');
    let stack = [];

    for ( let i=0; i<tokens.length; i++) {
        if  (tokens[i] !== ')' ) {
            stack.push(tokens[i]);
        }
        else {
            let right = stack.pop();
            let operator = stack.pop();
            let left = stack.pop();
            let str = '( ' + left + ' ' + operator + ' ' + right + ' )';
            stack.push(str)
        }
    }

    return stack.join(' ');
}
```