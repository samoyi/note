# 前序、中序和后序表达式中对栈数据结构的应用

## 从中序到后序的转换
### 算法
遍历中序表达式字符串，依次处理每个字符：

#### 如果字符是操作数
因为是后序，操作数在前，所以将该操作数其 push 到结果字符串

#### 如果字符是左括号
1. 左括号页算作运算符，并且它的优先级最低。
2. 将其 push 到运算符栈中。

#### 如果字符是右括号
1. 可以想到，此时运算符栈靠下的某个位置已经有了左括号，而栈顶也是一个非括号运算符。（右括号不会被推栈）
2. 反复从运算符栈中 pop 出运算符并 push 到结果字符串中，直到移除对应的左括号。
3. 之所以可以依次 pop 并 push 到结果字符串，就是因为下面对普通运算符的处理逻辑。

#### 如果字符是普通运算符（非左括号）
1. 将其 push 运算符栈中。但是，在这之前，需要先从栈中 pop 出优先级更高或相同的运算符，并将它们 push 到结果列表的末尾。
2. 观察上一步的逻辑，它会保证栈中上部的运算符优先级总是大于下部的。以及，两个同等优先级的运算符，先出现的会先加入到结果字符串中。

#### 当处理完输入表达式以后
1. 检查运算符栈，将其中所有的运算符依次 pop 并 push 到结果列表字符串。
2. 考虑`("A * B + C * D")`，遍历完所有字符后，栈中剩下的是`['+', '*']`。先 push 优先级高的乘号，再 push 优先级低的加号。

### 实现
```py
from pythonds.basic import Stack
import string

def infixToPostfix(infixexpr):
    prec = {}
    prec["*"] = 3
    prec["/"] = 3
    prec["+"] = 2
    prec["-"] = 2
    prec["("] = 1

    opStack = Stack()
    postfixList = []

    tokenList = infixexpr.split()
    for token in tokenList:
        if token in string.ascii_uppercase:
            postfixList.append(token)
        elif token == '(':
            opStack.push(token)
        elif token == ')':
            topToken = opStack.pop()
            while topToken != '(':
                postfixList.append(topToken)
                topToken = opStack.pop()
        else:
            while (not opStack.isEmpty()) and \
                (prec[opStack.peek()] >= prec[token]):
                    postfixList.append(opStack.pop())
            opStack.push(token)
           
    while not opStack.isEmpty():
        postfixList.append(opStack.pop())

    return " ".join(postfixList)


print(infixToPostfix('A * B + C * D'))              # A B * C D * +
print(infixToPostfix("( A + B ) * ( C + D )"))      # A B + C D + *
print(infixToPostfix("A * B + C * D"))              # A B * C D * +
print(infixToPostfix("( A + B ) * C"))              # A B + C *
print(infixToPostfix("A + B * C"))                  # A B C * +
print(infixToPostfix("( A + B * E ) * ( C + D )"))  # A B E * + C D + *
```


## 计算后序表达式
```py
from pythonds.basic import Stack


def doMath(op, op1, op2):
    if op  == "*":
        return op1 * op2
    elif op == "/":
        return op1 / op2
    elif op == "+":
        return op1 + op2
    else:
        return op1 - op2


def postfixEval (postfixExpr):
    stack = Stack()
    
    tokenList = postfixExpr.split()

    for token in tokenList:
        if token.isdigit():
            stack.push(int(token))
        else:
            right = stack.pop()
            left = stack.pop()
            stack.push(doMath(token, left, right))

    return stack.pop()


print(postfixEval('4 5 6 * +'))      # 34
print(postfixEval('7 8 + 3 2 + /'))  # 3.0
```



## References
* [《Python数据结构与算法分析（第2版）》第3章](https://book.douban.com/subject/34785178/)