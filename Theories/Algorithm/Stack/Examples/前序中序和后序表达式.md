# 前序、中序和后序表达式


<!-- TOC -->

- [前序、中序和后序表达式](#前序中序和后序表达式)
    - [设计思想](#设计思想)
        - [为什么乘除的优先级高于加减](#为什么乘除的优先级高于加减)
        - [为什么中序表达式需要优先级](#为什么中序表达式需要优先级)
        - [为什么中序表达式需要括号](#为什么中序表达式需要括号)
    - [本质](#本质)
        - [计算即合并](#计算即合并)
        - [使用栈来暂存运算符并等待和之后的运算符比较](#使用栈来暂存运算符并等待和之后的运算符比较)
        - [括号是一种强制的优先级提升](#括号是一种强制的优先级提升)
    - [中序表达式](#中序表达式)
    - [前序表达式和后序表达式](#前序表达式和后序表达式)
    - [计算后序表达式](#计算后序表达式)
        - [JavaScript](#javascript)
        - [C](#c)
        - [Python](#python)
    - [计算前序表达式](#计算前序表达式)
    - [从中序到后序的转换](#从中序到后序的转换)
        - [没有括号的情况](#没有括号的情况)
            - [如果第二个运算符优先级比 $+$ 高](#如果第二个运算符优先级比--高)
            - [如果第二个运算符优先级比 $+$ 低](#如果第二个运算符优先级比--低)
        - [加入括号的情况](#加入括号的情况)
        - [算法](#算法)
        - [实现](#实现)
            - [Python](#python-1)
            - [JavaScript](#javascript-1)
    - [References](#references)

<!-- /TOC -->


## 设计思想
### 为什么乘除的优先级高于加减
1. 在分析中序表达式的时候突然想到这个问题，只有中序表达式才需要优先级。
2. 比如如果我们用自然语言来表述：“$1$ 和 $2$ 的乘积加上 $3$ 和 $4$ 的乘积”，这句话是不涉及优先级概念的。所以我们用前序、中序或后序表达式都可以表示这句话的意义。
3. 中序表达式这样表示：$1 * 2 + 3 * 4$。你必须要规定优先级，否则就不知道怎么算；或者就按照从左到右的阅读习惯进行计算得出 20。
4. 但为什么规定乘法优先级高于加法呢？反过来规定，其实也是可以计算的。如果规定加法优先级更高，那中序表达是就要写成 $( 1 * 2 ) + ( 3 * 4 )$。
5. 随便百度了一下，虽然也可以反着规定，但还是这么规定在大多数时候都更方便一些。

### 为什么中序表达式需要优先级
1. 中序表达式中的一个运算数，可以参与它前面运算符的计算，也可以参与它后面运算符的计算。因为这种模糊性的存在，所以必须要规定优先级。
2. 而前序后序表达式就不用，因为，比如后续表达式，运算数只能参与它后面的运算符的运算，没有歧义。

### 为什么中序表达式需要括号
1. 用中序表达式怎么表示 “$A$ 和 $B$ 的和再乘以 $C$” ？
2. 正是因为有优先级，所以 $A + B * C$ 是不行的。那取消优先级呢？
3. 在这个例子中，取消了优先级，$A + B * C$ 就可以正确表示 “$A$ 和 $B$ 的和再乘以 $C$” 了。
4. 但要怎么表示 “$C$ 减去 $A$ 和 $B$ 的和” ？$C - A + B$ 显然不行，必须要用括号才行。
5. 也就是说，因为中序，所以要优先级，因为有优先级，所以要括号。而对于后序表达式来说，不需要优先级，也就不需要括号。
6. 数学中为什么使用了更麻烦的中序表达式呢？


## 本质
### 计算即合并
1. 一个数学表达式计算的过程，实际上就是不断合并的过程。或者说是若干个函数自变量和函数计算规则合起来映射到函数值的过程。
2. 可以是两个数和一个操作符的合并，也可以是一个数和一个操作符的合并，也可以是三个数和两个运算符的的合并（比如 `a ? b : c`）。既然函数就是一种计算，那么任意个运算所或者没有计算数也可以计算得到一个结果。
3. 所谓的前序、中序和后序，只不过是对同一个计算的三种表示方法。

### 使用栈来暂存运算符并等待和之后的运算符比较
1. 因为在中序表达式中，一个运算数既可能参与它前面的运算，也可能参与它后面的运算。所以在看到一个运算数时，不能立刻让它参与到前面的运算，还要等待后面的运算符。
2. 比如 $A + B * C + D$，遍历进行到了 $A + B$，依然不能让计算发生，因为 $B$ 有可能参加后面的运算。

### 括号是一种强制的优先级提升
1. 括号实际上并不是运算符，但在算法实现中，还是把它看做了运算符入栈。
2. 或者说，其实也没有把它看做运算符。而是因为括号会提升括号内部运算符的优先级，而将括号放进运算符栈里，就可以保证让括号内部的运算符即使优先级低于前面的运算符，也可以优先进行计算。
3. 括号实际上就是强制提升了若干个运算符的等级，让括号内的运算符优先级高于括号外的运算符。
4. 这类似于 css 中的 `!important` 的感觉。


## 中序表达式
1. 对于像 $B * C$ 这样的算术表达式，可以根据其形式来正确地运算。在 $B * C$ 的例子中，由于乘号 $*$ 出现在两个变量之间，因此我们知道应该用变量 $B$ 乘以变量 $C$。因为运算符出现在两个操作数的中间，所以这种表达式被称作 **中序表达式**。
2. 让我们从运算符优先级的角度来理解 $A + B * C$。首先计算 $B * C$，然后再将 $A$ 与该乘积相加；$(A + B) * C$ 则是先计算 $A$ 与 $B$ 之和，然后再进行乘法运算；在表达式 $A + B + C$中，根据优先级法则（或者结合性），最左边的 $+$ 会首先参与运算。
3. 尽管这些规律对于人来说显而易见，计算机却需要明确地知道以何种顺序进行何种运算。一种杜绝歧义的写法是 **完全括号表达式**。这种表达式对每一个运算符都添加一对括号。由括号决定运算顺序，没有任何歧义，并且不必记忆任何优先级规则。
4. 例如， $A + B * C + D$ 可以被重写成 $((A + (B * C)) + D)$，以表明乘法优先，然后计算左边的加法表达式。由于加法运算从左往右结合，因此 $A + B + C + D$ 可以被重写成 $(((A + B) + C) + D)$。


## 前序表达式和后序表达式
1. 通过改变运算符与操作数的相对位置，我们分别得到 **前序表达式** 和 **后序表达式**。前序表达式要求所有的运算符出现在它所作用的两个操作数之前，后序表达式则相反。
<table width="90%" border="1">
    <thead>
        <tr>
            <th><p>中序表达式</p></th>
            <th><p>前序表达式</p></th>
            <th><p>后序表达式</p></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><p><code>A + B</code></p></td>
            <td><p><code>+ A B</code></p></td>
            <td><p><code>A B +</code></p></td>
        </tr>
        <tr>
            <td><p><code>A + B * C</code></p></td>
            <td><p><code>+ A * B C</code></p></td>
            <td><p><code>A B C * +</code></p></td>
        </tr>
        <tr>
            <td><p><code>(A + B) * C</code></p></td>
            <td><p><code>* + A B C</code></p></td>
            <td><p><code>A B + C *</code></p></td>
        </tr>
    </tbody>
</table>


## 计算后序表达式
### JavaScript
```js
const calcFns = {
    '*': (a, b) => Number.parseFloat(a) * Number.parseFloat(b),
    '/': (a, b) => Number.parseFloat(a) / Number.parseFloat(b),
    '+': (a, b) => Number.parseFloat(a) + Number.parseFloat(b),
    '-': (a, b) => Number.parseFloat(a) - Number.parseFloat(b),
}


function postfixEval (str) {
    let arr = str.split(' ');
    let stack = [];
    let len = arr.length;

    for ( let i=0; i<len; i++) {
        if ( arr[i] in calcFns ) {
            let b = stack.pop();
            let a = stack.pop();
            let re = calcFns[arr[i]]( a, b );
            stack.push( re );
        }
        else {
            stack.push( arr[i] );
        }
    }
    
    return stack[0];
}

console.log(postfixEval('4 5 6 * +')); // 34
console.log(postfixEval('7 8 + 3 2 + /')); // 3
```

### C
TODO，比较麻烦，`tokenize` 和 `calcFn`s 实现起来都明显麻烦。

### Python
```py
from pythonds.basic import Stack


def doMath(op, op1, op2):
    if op  == "*":
        return op1 * op2
    elif op == "/":
        return op1 / op2
    elif op == "+":
        return op1 + op2
    else:
        return op1 - op2


def postfixEval (postfixExpr):
    stack = Stack()
    
    tokenList = postfixExpr.split()

    for token in tokenList:
        if token.isdigit():
            stack.push(int(token))
        else:
            right = stack.pop()
            left = stack.pop()
            stack.push(doMath(token, left, right))

    return stack.pop()


print(postfixEval('4 5 6 * +'))      # 34
print(postfixEval('7 8 + 3 2 + /'))  # 3.0
```


## 计算前序表达式
1. 前序表达式的结构是：一个运算符加两个运算数，运算数不一定是简单的数，也可能是其他前序表达式。
2. 当我们从左往右阅读表达式的时候，如果看到一个运算符，那肯定要暂时保存，然后等待后面的操作数；
3. 如果看到一个操作数，还要看看是第几个操作数：
    * 如果前面前一个是操作符，那这个就是第一个操作数，那么还要暂时保存，然后等待第二个操作数；
    * 如果前面一个也是操作数，那这个就是第二个操作数，现在就可以取出前面暂存的第一个操作数和操作符进行计算。
4. 那么就可以使用栈的暂存特性来实现。第一次这样实现，有问题
    ```js
    const calcFns = {
        '*': (a, b) => Number.parseFloat(a) * Number.parseFloat(b),
        '/': (a, b) => Number.parseFloat(a) / Number.parseFloat(b),
        '+': (a, b) => Number.parseFloat(a) + Number.parseFloat(b),
        '-': (a, b) => Number.parseFloat(a) - Number.parseFloat(b),
    }

    function isOperator (token) {
        return tokens[i] in calcFns;
    }

    function prefixEval (exp) {
        let stack = [];
        let tokens = exp.split(' ');
        for (let i=0; i<tokens.length; i++) {
            let isLastTokenNum = !isOperator(tokens[i-1]);
            if ( isOperator(tokens[i]) ) {
                stack.push(tokens[i]);
            }
            else if ( isOperator(tokens[i-1]) ) {
                stack.push(tokens[i]);
            }
            else {
                let firstNum = stack.pop();
                let operator = stack.pop();
                let num = calcFns[operator](firstNum, tokens[i]);
                stack.push(num);
            }
        }
        return stack.pop();
    }

    console.log(prefixEval("+ * 5 6 4")); // 34
    console.log(prefixEval("/ + 7 8 + 3 2")); // 应该是 3，但算出来是 5
    console.log(prefixEval("+ + 1 + 2 3 + 4 5")); // 应该是 15，但算出来是 9
    ```
5. 因为在一次计算出 `num` 之后直接 push 进栈里就不管了，但其实如果栈顶是一个计算数的话，那就还要继续进行计算。
6. 针对 `"/ + 7 8 + 3 2"` 的情况，可以在 `for` 循环后再让里面的两个操作数和一个操作符出栈计算；但是 `"+ + 1 + 2 3 + 4 5"` 则需要在 `+ 2 3` 计算之后就接着处理 `+ 1`。
7. 换成计算后序表达式的方法，先入栈两个操作数然后遇到操作符就出栈计算。在这里就是从右往左遍历
    ```js
    function prefixEval (exp) {
        let stack = [];
        let tokens = exp.split(' ');
        for (let i=tokens.length-1; i>=0; i--) {
            if ( isOperator(tokens[i]) ) {
                let secondNum = stack.pop();
                let firstNum = stack.pop();
                let num = calcFns[tokens[i]](secondNum, firstNum);
                stack.push(num);
            }
            else {
                stack.push(tokens[i]);
            }
        }
        return stack.pop();
    }
    ```
8. 两种顺序的本质区别是什么？
9. 以 `+ A * B C` 为例，错误的算法中，计算完 `* B C` 后结果放入栈里循环就结束了；但是正确的算法中，计算完 `* B C` 结果放入栈里，还会继续查看没有访问的 token。
10. 继续观察，发现正确的算法中运算符根本不会入栈，它出现的时候只会触发两个操作数出栈来进行计算。
11. 操作符不能入栈，操作符只是用来触发出栈操作的。


前 - + 1 * 2 3 4
后 1 2 3 * + 4 -
## 从中序到后序的转换
### 没有括号的情况
1. 考虑 $1 + 2 * 3 - 4$ 和 $1 + 2 - 3 - 4$ 情况。
2. 第一个运算数 $1$，放入结果字符串。保存运算符 $+$ 进运算符栈，等待计算；然后第二个运算数 $2$，放入结果字符串。
3. 这时，应不应该执行 $1 + 2$？即，应不应该让结果字符串变成 `12+`？
4. 显然，这时是无法确定的，必须要看下一个运算符和刚才保存的运算符 $+$ 的优先级比较。
5. 如果第二个运算符的优先级比 $+$ 高，那就不能计算 $1 + 2$；如果比 $+$ 低，那就应该优先计算 $1 + 2$；如果和 $+$ 相同，那根据左边优先的原则，也应该优先计算 $1 + 2$。
6. 所以，保存一个运算符栈的意义，除了要等待它后面第二个运算数，还要等待第二个运算符，来确定优先级。

#### 如果第二个运算符优先级比 $+$ 高
1. 比如这里 $1 + 2 * 3 - 4$ 中的 $*$。那就证明要先进行第二个运算的计算，所以还要再保存 $*$，然后继续读取后面的运算数，也就是这里的 $3$。
2. 结果字符串变为 `123`，运算符栈变为 `[+, *]`
3. 记录完 $3$ 之后，和上面的情况一样，还是不能确定后一个运算符的优先级。（虽然在这个例子里，$*$ 已经是最高优先级的了，但后续我们还会加上括号，所以不能确保 $*$ 就是最高优先级。）所以还要读取下一个运算符 $-$。
4. 在这里，$-$ 的优先级小于 $*$。所以此时应该计算 $*$ 运算了。
5. 结果字符串变为 `123*`，运算符栈变为 `[+]`。
6. 现在，$-$ 还不能入栈。因为入栈后变成了 `[+-]`，之后 $-$ 就会在 $+$ 之前执行了。所以在入栈前还要和栈里面剩余的比较一下，如果栈内还有更优先的，要先计算栈内的。
7. 所以 $+$ 出栈进行计算，结果字符串变为 `123*+`，运算符栈变为 `[]`。
8. 现在栈内没有比 $-$ 更优先的了，$-$ 入栈等待。
9. 记录下一个运算数，结果字符串变为 `123*+4`，运算符栈现在为 `[-]`。
10. 后面没有字符了，所以让剩余的运算符 $-$ 出栈，参与最后一步运算。结果为 `123*+4-`。

#### 如果第二个运算符优先级比 $+$ 低
1. 比如这里 $1 + 2 - 3 - 4$ 中的 $-$。那就证明要先进行 $+$ 计算，然后再保存 $-$。
2. 结果字符串变为 `12+`，运算符栈变为 `[-]`。
3. 接着记录 $3$ 之后，然后发现第三个运算符 $-$。
4. 这个 $-$ 想入栈，但是发现栈内存在一个和自己同级的运算符，所以应该先让栈内的 $-$ 出栈运算，然后自己再入栈等待后续操作数。
5. 结果字符串变为 `12+3-`，运算符栈变为 `[-]`
6. 记录运算数 $4$。
7. 后面没有字符了，所以让剩余的运算符 $-$ 出栈，参与最后一步运算。结果为 `12+3-4-`

### 加入括号的情况
1. 考虑 $( A + B ) * ( C + D )$。
2. 因为 $($ 要等待 $)$，所以它也要入栈。
3. 而且，除了 $)$，没有其他运算符可以让 $($ 出栈参与运算。所以，可以把 $($ 的优先级定为最低。但它又有特殊之处。
4. 前面说到，低优先级的运算符要入栈的时候，栈内的高优先级运算符要出栈。但是考虑这里的情况，当第二个 $($ 想要入栈时，栈内有优先级更高的 $*$。但这时，显然不能让 $*$ 出栈，而是要让 $($ 直接入栈。
5. 从这个角度看，$($ 又像是优先级最高的。
6. 其实，单就一个独立的括号结构来说，比如 $(x + y * z)$，$($ 的优先级最低的，只有当括号内部所有运算完成后，$($ 才能和 $)$ 把它们括起来包装输出一个最终结果。而在这个括号结构和外面的关系中，$($ 又比外部的任何运算符优先级都高，只有 $($ 和 $)$ 以及运算完之后，才能和外部的运算数进行运算。
7. 所以，上面说把 $($ 优先级定为最低，就是相对于括号内部的运算符；而 $($ 入栈时不会让里面的运算符出栈，因为里面已有的运算符是括号外面的，所以 $($ 相对于它们来说有着最高的优先级。
8. 当出现 $)$ 的时候，它本身并不需要入栈，它的出现，意味着栈内直到最近的 $($ 之间的运算符可以出栈进行运算了，来计算出整个括号的值。

### 算法
* 如果字符是操作数
    1. 因为是后序，操作数在前，所以将该操作数 push 到结果字符串
* 如果字符是左括号
    1. 左括号页算作运算符，并且它的优先级最低。
    2. 将其 push 到运算符栈中。
* 如果字符是右括号
    1. 可以想到，此时运算符栈靠下的某个位置已经有了左括号，而栈顶也是一个非括号运算符。（右括号不会被推栈）
    2. 反复从运算符栈中 pop 出运算符并 push 到结果字符串中，直到移除对应的左括号。
    3. 之所以可以依次 pop 并 push 到结果字符串，就是因为下面对普通运算符的处理逻辑。
* 如果字符是普通运算符（非左括号）
    1. 将其 push 运算符栈中。但是，在这之前，需要先从栈中 pop 出优先级更高或相同的运算符，并将它们 push 到结果列表的末尾。
    2. 观察上一步的逻辑，它会保证栈中上部的运算符优先级总是大于下部的。以及，两个同等优先级的运算符，先出现的会先加入到结果字符串中。
* 当处理完输入表达式以后
    1. 检查运算符栈，将其中所有的运算符依次 pop 并 push 到结果列表字符串。
    2. 考虑 `A * B + C * D `，遍历完所有字符后，栈中剩下的是 `['+', '*']` 。先 push 优先级高的乘号，再 push 优先级低的加号。

### 实现
#### Python
```py
from pythonds.basic import Stack
import string

def infixToPostfix(infixexpr):
    prec = {}
    prec["*"] = 3
    prec["/"] = 3
    prec["+"] = 2
    prec["-"] = 2
    prec["("] = 1

    opStack = Stack()
    postfixList = []

    tokenList = infixexpr.split()
    for token in tokenList:
        if token in string.ascii_uppercase:
            postfixList.append(token)
        elif token == '(':
            opStack.push(token)
        elif token == ')':
            topToken = opStack.pop()
            while topToken != '(':
                postfixList.append(topToken)
                topToken = opStack.pop()
        else:
            while (not opStack.isEmpty()) and \
                (prec[opStack.peek()] >= prec[token]):
                    postfixList.append(opStack.pop())
            opStack.push(token)
           
    while not opStack.isEmpty():
        postfixList.append(opStack.pop())

    return " ".join(postfixList)


print(infixToPostfix('A * B + C * D'))              # A B * C D * +
print(infixToPostfix("( A + B ) * ( C + D )"))      # A B + C D + *
print(infixToPostfix("A * B + C * D"))              # A B * C D * +
print(infixToPostfix("( A + B ) * C"))              # A B + C *
print(infixToPostfix("A + B * C"))                  # A B C * +
print(infixToPostfix("( A + B * E ) * ( C + D )"))  # A B E * + C D + *
```

#### JavaScript
```js
const operatorPriority = {
    '*': 3,
    '/': 3,
    '+': 2,
    '-': 2,
    '(': 1,
}


function foo (str) {
    let arr = str.split(' ');
    let stack = [];
    let len = arr.length;
    let result = [];

    for ( let i=0; i<len; i++) {
        if ( arr[i] === '(' ) {
            stack.push( arr[i] );
        }
        else if ( arr[i] === ')' ) {
            let popped = stack.pop();
            while ( popped !== '(' ) {
                result.push( popped );
                popped = stack.pop();
            }
        }
        else if ( arr[i] in operatorPriority ) {
            while ( stack.length > 0 
                    && operatorPriority[stack[stack.length - 1]] >= operatorPriority[arr[i]] 
            ) {
                result.push( stack.pop() );
            }
            stack.push( arr[i] );
        }
        else {
            result.push( arr[i] );
        }
       
    }
    
    while ( stack.length > 0 ) {
        result.push( stack.pop() );
    }
    return result.join(' ');
}

console.log(foo('A * B + C * D')); // A B * C D * +
console.log(foo('A + B * C + D')); // A B C * + D + 
console.log(foo('A + B + C + D')); // A B + C + D +
console.log(foo('( A + B ) * ( C + D )')); // A B + C D + *
console.log(foo('( A + B ) * C')); // A B + C *
```


## References
* [《Python数据结构与算法分析（第2版）》第3章](https://book.douban.com/subject/34785178/)