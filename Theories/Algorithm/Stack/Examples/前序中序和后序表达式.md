# 前序、中序和后序表达式


<!-- TOC -->

- [前序、中序和后序表达式](#前序中序和后序表达式)
    - [设计思想](#设计思想)
        - [为什么乘除的优先级高于加减](#为什么乘除的优先级高于加减)
        - [为什么中序表达式需要优先级](#为什么中序表达式需要优先级)
        - [为什么中序表达式需要括号](#为什么中序表达式需要括号)
        - [使用栈来实现临时存放](#使用栈来实现临时存放)
    - [本质](#本质)
        - [计算即合并](#计算即合并)
        - [括号是一种强制的优先级提升](#括号是一种强制的优先级提升)
    - [中序表达式](#中序表达式)
    - [前序表达式和后序表达式](#前序表达式和后序表达式)
    - [递归和栈结构](#递归和栈结构)
        - [优先级](#优先级)
        - [前序表达式和后序表达式不需要括号](#前序表达式和后序表达式不需要括号)
    - [计算后序表达式](#计算后序表达式)
        - [JavaScript](#javascript)
        - [C](#c)
        - [Python](#python)
    - [计算前序表达式](#计算前序表达式)
    - [从中序到后序的转换](#从中序到后序的转换)
        - [运算数顺序不会发生改变](#运算数顺序不会发生改变)
        - [【错误，反例 `1 + 2 * 3 - 4 / 5`】运算符根据优先级线性排列](#错误反例-1--2--3---4--5运算符根据优先级线性排列)
        - [没有括号的情况](#没有括号的情况)
            - [如果第二个运算符优先级比 $+$ 高](#如果第二个运算符优先级比--高)
            - [如果第二个运算符优先级比 $+$ 低](#如果第二个运算符优先级比--低)
        - [加入括号的情况](#加入括号的情况)
        - [算法](#算法)
        - [实现](#实现)
            - [JavaScript](#javascript-1)
            - [Python](#python-1)
    - [从中序到前序的转换](#从中序到前序的转换)
    - [References](#references)

<!-- /TOC -->


## 设计思想
### 为什么乘除的优先级高于加减
1. 在分析中序表达式的时候突然想到这个问题，只有中序表达式才需要优先级。
2. 比如如果我们用自然语言来表述：“$1$ 和 $2$ 的乘积加上 $3$ 和 $4$ 的乘积”，这句话是不涉及优先级概念的。所以我们用前序、中序或后序表达式都可以表示这句话的意义。
3. 中序表达式这样表示：$1 * 2 + 3 * 4$。你必须要规定优先级，否则就不知道怎么算；或者就按照从左到右的阅读习惯进行计算得出 20。
4. 但为什么规定乘法优先级高于加法呢？反过来规定，其实也是可以计算的。如果规定加法优先级更高，那中序表达是就要写成 $( 1 * 2 ) + ( 3 * 4 )$。
5. 随便百度了一下，虽然也可以反着规定，但还是这么规定在大多数时候都更方便一些。

### 为什么中序表达式需要优先级
1. 中序表达式中的一个运算数，可以参与它前面运算符的计算，也可以参与它后面运算符的计算。因为这种模糊性的存在，所以必须要规定优先级。
2. 而前序后序表达式就不用，因为，比如后续表达式，运算数只能参与它后面的运算符的运算，没有歧义。

### 为什么中序表达式需要括号
1. 用中序表达式怎么表示 “$A$ 和 $B$ 的和再乘以 $C$” ？
2. 正是因为有优先级，所以 $A + B * C$ 是不行的。那取消优先级呢？
3. 在这个例子中，取消了优先级，$A + B * C$ 就可以正确表示 “$A$ 和 $B$ 的和再乘以 $C$” 了。
4. 但要怎么表示 “$C$ 减去 $A$ 和 $B$ 的和” ？$C - A + B$ 显然不行，必须要用括号才行。
5. 也就是说，因为中序，所以要优先级，因为有优先级，所以要括号。而对于后序表达式来说，不需要优先级，也就不需要括号。
6. 数学中为什么使用了更麻烦的中序表达式呢？

### 使用栈来实现临时存放



## 本质
### 计算即合并
1. 一个数学表达式计算的过程，实际上就是不断合并的过程。或者说是若干个函数自变量和函数计算规则合起来映射到函数值的过程。
2. 可以是两个数和一个操作符的合并，也可以是一个数和一个操作符的合并，也可以是三个数和两个运算符的的合并（比如 `a ? b : c`）。既然函数就是一种计算，那么任意个运算所或者没有计算数也可以计算得到一个结果。
3. 所谓的前序、中序和后序，只不过是对同一个计算的三种表示方法。

### 括号是一种强制的优先级提升
1. 括号实际上并不是运算符，但在算法实现中，还是把它看做了运算符入栈。
2. 或者说，其实也没有把它看做运算符。而是因为括号会提升括号内部运算符的优先级，而将括号放进运算符栈里，就可以保证让括号内部的运算符即使优先级低于前面的运算符，也可以优先进行计算。
3. 括号实际上就是强制提升了若干个运算符的等级，让括号内的运算符优先级高于括号外的运算符。
4. 这类似于 css 中的 `!important` 的感觉。


## 中序表达式
1. 对于像 $B * C$ 这样的算术表达式，可以根据其形式来正确地运算。在 $B * C$ 的例子中，由于乘号 $*$ 出现在两个变量之间，因此我们知道应该用变量 $B$ 乘以变量 $C$。因为运算符出现在两个操作数的中间，所以这种表达式被称作 **中序表达式**。
2. 让我们从运算符优先级的角度来理解 $A + B * C$。首先计算 $B * C$，然后再将 $A$ 与该乘积相加；$(A + B) * C$ 则是先计算 $A$ 与 $B$ 之和，然后再进行乘法运算；在表达式 $A + B + C$中，根据优先级法则（或者结合性），最左边的 $+$ 会首先参与运算。
3. 尽管这些规律对于人来说显而易见，计算机却需要明确地知道以何种顺序进行何种运算。一种杜绝歧义的写法是 **完全括号表达式**。这种表达式对每一个运算符都添加一对括号。由括号决定运算顺序，没有任何歧义，并且不必记忆任何优先级规则。
4. 例如， $A + B * C + D$ 可以被重写成 $((A + (B * C)) + D)$，以表明乘法优先，然后计算左边的加法表达式。由于加法运算从左往右结合，因此 $A + B + C + D$ 可以被重写成 $(((A + B) + C) + D)$。


## 前序表达式和后序表达式
1. 通过改变运算符与操作数的相对位置，我们分别得到 **前序表达式** 和 **后序表达式**。前序表达式要求所有的运算符出现在它所作用的两个操作数之前，后序表达式则相反。
<table width="90%" border="1">
    <thead>
        <tr>
            <th><p>中序表达式</p></th>
            <th><p>前序表达式</p></th>
            <th><p>后序表达式</p></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><p><code>A + B</code></p></td>
            <td><p><code>+ A B</code></p></td>
            <td><p><code>A B +</code></p></td>
        </tr>
        <tr>
            <td><p><code>A + B * C</code></p></td>
            <td><p><code>+ A * B C</code></p></td>
            <td><p><code>A B C * +</code></p></td>
        </tr>
        <tr>
            <td><p><code>(A + B) * C</code></p></td>
            <td><p><code>* + A B C</code></p></td>
            <td><p><code>A B + C *</code></p></td>
        </tr>
    </tbody>
</table>


## 递归和栈结构
1. 前序表达式的逻辑是：先找到一个运算符，然后找到它后面的两个运算数；中序表达式的逻辑是：先找到一个运算符，然后找到它两边的两个运算数；后序表达式的逻辑是：先找到一个运算符，然后找到它前面的两个运算数。
2. 所以中序 `(A + B) * (C + D)`，先找到 `*`，然后找到它左右两边的运算数，只不过这里不是直接的运算数，而是子表达式，所以需要递归的求解两个子表达式。要求解整个的 `*` 表达式，就要先递归的求解里面的两个 `+` 子表达式；等子表达式都返回值之后，才能解出外层的表达式。
3. 再看一下前序表达式 `* + A B + C D`。按照从左到右的阅读顺序，看到 `*` 这个 “函数”（运算符）的时候，会接着看后面是不是有两个 “参数”（运算数）；发现不是，就会想着 `*` 这个 “函数” 暂时搁置，先执行后面的 `+` “函数”。
4. 可以看到这个思想的过程其实就是递归和调用栈的结构了：`*` “函数” 里面嵌套了两个同级的 `+` “函数”。

### 优先级
1. 而且有趣的是，在同一组嵌套的递归运算中，对于前序表达式来说：越靠左边的运算符，其实就是处于递归的外层、调用栈的底层，也就是有更低的优先级。
2. `* + A B + C D` 的例子中，`*` 和每个 `+` 都是在同一组嵌套运算中，所以要先计算 `+` 再计算 `*`；而两个 `+` 之间不在一组嵌套关系中，它们是平级的，所以可以按照从左到右或从右到左的顺序依次运算。
3. 所以整体的运算顺序是：内层左边的 `+`，内层右边平级的 `+`，外层 `*`；也可以是内层右边的 `+`，内层左边平级的 `+`，外层 `*`。考虑到整体由右向左的顺序，后者的运算顺序更合适。所以就是从右到左依次入栈。
4. 再看一个更复杂的情况，例如 `* + A B + C D` 中的 `B` 和 `D` 不是直接的运算数而是子表达式：`* + A + B1 B2 + C + D1 D2`。这里，`*`、第一个 `+` 和第二个 `+` 是在一组嵌套运算中，`*`、第三个 `+` 和第四个 `+` 是在另一组嵌套运算中，而第一个 `+` 和第三个 `+` 是平级的。
5. 所以整体的运算顺序是：第二个 `+`，第一个 `+`，第四个 `+`，第三个 `+`，`*`：
6. 再看一下后序表达式 `A B + C D + *`，和前序表达式相反：越靠右边的运算符，其实就是处于递归的外层、调用栈的底层，也就是有更低的优先级。所以整体的运算顺序是：内层左边的 `+`，内层右边平级的 `+`，外层 `*`；也可以是内层右边的 `+`，内层左边平级的 `+`，外层 `*`。考虑到整体由右向左的顺序，前者的运算顺序更合适。所以就是从左到右依次入栈。

### 前序表达式和后序表达式不需要括号
1. 当我们试图用顺序而非括号来表明中序表达是的优先级时，如果按照从左到右的顺序：
    1. `(A + B) * C` 可以写成 `A + B * C`；
    2. 如果想表达 `A + B * C`，那就要写成 `B * C + A`；
    3. 看起来没问题。但是 `A * B + C * D` 就不能用顺序来表达出优先级。
2. `A * B + C * D` 可以写成前序表达式 `+ * A B * C D`，或者写成后序表达式 `A B * C D * +`。为什么前序和后序都可以不用括号但是中序不行呢？
3. 在上面的中序表达式中，`+` 两边到底是实际的运算数还是子表达式，这是无法明确的。因为对于中序表达是来说，子表达式的两端还是运算数而不是运算符。
4. 而前序表达式中，子表达式的左端是运算符；后序表达式中，子表达式的右端也是运算符。所以可以明确的区分实际的运算数和子表达式。
5. 中序表达是中只能通过括号的方式来明确的划分出子表达式。


## 计算后序表达式
1. 后序表达式的结构是：两个运算数加一个运算符，运算数不一定是简单的数，也可能是其他后序表达式。
2. 当我们从左往右阅读表达式的时候，如果看到一个运算数，那肯定要暂时保存，然后等待后面的运算符；
3. 如果看到一个运算符，那就要取出前面暂存的两个运算数进行计算；
4. 计算的结果需要入栈以进行后续的计算；如果此时已经遍历了所有的 token，说明没有后续计算了，那就让这个计算结果出栈作为整个表达式的结果。
5. 这种暂存然后取出的需求，就可以使用栈的暂存特性来实现。

### JavaScript
```js
const calcFns = {
    '*': (a, b) => Number.parseFloat(a) * Number.parseFloat(b),
    '/': (a, b) => Number.parseFloat(a) / Number.parseFloat(b),
    '+': (a, b) => Number.parseFloat(a) + Number.parseFloat(b),
    '-': (a, b) => Number.parseFloat(a) - Number.parseFloat(b),
}


function postfixEval (str) {
    let arr = str.split(' ');
    let stack = [];
    let len = arr.length;

    for ( let i=0; i<len; i++) {
        if ( arr[i] in calcFns ) {
            let b = stack.pop();
            let a = stack.pop();
            let re = calcFns[arr[i]]( a, b );
            stack.push( re );
        }
        else {
            stack.push( arr[i] );
        }
    }
    
    return stack[0];
}

console.log(postfixEval('4 5 6 * +')); // 34
console.log(postfixEval('7 8 + 3 2 + /')); // 3
```

### C
TODO，比较麻烦，`tokenize` 和 `calcFns` 实现起来都明显麻烦。

### Python
```py
from pythonds.basic import Stack


def doMath(op, op1, op2):
    if op  == "*":
        return op1 * op2
    elif op == "/":
        return op1 / op2
    elif op == "+":
        return op1 + op2
    else:
        return op1 - op2


def postfixEval (postfixExpr):
    stack = Stack()
    
    tokenList = postfixExpr.split()

    for token in tokenList:
        if token.isdigit():
            stack.push(int(token))
        else:
            right = stack.pop()
            left = stack.pop()
            stack.push(doMath(token, left, right))

    return stack.pop()


print(postfixEval('4 5 6 * +'))      # 34
print(postfixEval('7 8 + 3 2 + /'))  # 3.0
```


## 计算前序表达式
1. 前序表达式的结构是：一个运算符加两个运算数，运算数不一定是简单的数，也可能是其他前序表达式。
2. 当我们从左往右阅读表达式的时候，如果看到一个运算符，那肯定要暂时保存，然后等待后面的运算数；
3. 如果看到一个运算数，还要看看是第几个运算数：
    * 如果前面一个是运算符，那这个就是第一个运算数，那么还要暂时保存，然后等待第二个运算数；
    * 如果前面一个也是运算数，那这个就是第二个运算数，现在就可以取出前面暂存的第运算符和运算数进行计算。
4. 第一次这样实现，有问题
    ```js
    const calcFns = {
        '*': (a, b) => Number.parseFloat(a) * Number.parseFloat(b),
        '/': (a, b) => Number.parseFloat(a) / Number.parseFloat(b),
        '+': (a, b) => Number.parseFloat(a) + Number.parseFloat(b),
        '-': (a, b) => Number.parseFloat(a) - Number.parseFloat(b),
    }

    function isOperator (token) {
        return tokens[i] in calcFns;
    }

    function prefixEval (exp) {
        let stack = [];
        let tokens = exp.split(' ');
        for (let i=0; i<tokens.length; i++) {
            let isLastTokenNum = !isOperator(tokens[i-1]);
            if ( isOperator(tokens[i]) ) {
                stack.push(tokens[i]);
            }
            else if ( isOperator(tokens[i-1]) ) {
                stack.push(tokens[i]);
            }
            else {
                let firstNum = stack.pop();
                let operator = stack.pop();
                let num = calcFns[operator](firstNum, tokens[i]);
                stack.push(num);
            }
        }
        return stack.pop();
    }

    console.log(prefixEval("+ * 5 6 4")); // 34
    console.log(prefixEval("/ + 7 8 + 3 2")); // 应该是 3，但算出来是 5
    console.log(prefixEval("+ + 1 + 2 3 + 4 5")); // 应该是 15，但算出来是 9
    ```
5. 因为在一次计算出 `num` 之后直接 push 进栈里就不管了，但其实如果栈顶是一个运算数的话，那这个 `num` 就是第二个运算数，就还要继续进行计算。
6. 针对 `"/ + 7 8 + 3 2"` 的情况，可以在 `for` 循环后再让里面的一个运算符和两个运算数出栈计算；但是 `"+ + 1 + 2 3 + 4 5"` 则需要在 `+ 2 3` 计算之后就接着处理 `+ 1`。
7. 换成计算后序表达式的方法，先入栈两个运算数然后遇到运算符就出栈计算。在这里就是从右往左遍历
    ```js
    function prefixEval (exp) {
        let stack = [];
        let tokens = exp.split(' ');
        for (let i=tokens.length-1; i>=0; i--) {
            if ( isOperator(tokens[i]) ) {
                let secondNum = stack.pop();
                let firstNum = stack.pop();
                let num = calcFns[tokens[i]](secondNum, firstNum);
                stack.push(num);
            }
            else {
                stack.push(tokens[i]);
            }
        }
        return stack.pop();
    }
    ```
8. 两种顺序的本质区别是什么？
9. 以 `+ A * B C` 为例，错误的算法中，计算完 `* B C` 后结果放入栈里循环就结束了；但是正确的算法中，计算完 `* B C` 结果放入栈里，还会继续查看没有访问的 token。
10. 继续观察，发现正确的算法中运算符根本不会入栈，它出现的时候只会触发两个运算数出栈来进行计算。
11. 运算符不能入栈，运算符只是用来触发出栈操作的。
12. 上面错误的算法中，出栈（计算）是由第二个运算数来触发的，而正确的算法中，出栈是由运算符来触发的。
13. 更本质的说，触发出栈操作的 token 不能入栈，否则就可能漏掉了一次出栈机会。不管这个 token 是运算符还是第二个运算数。
14. 计算的结果是运算数，在正确的算法中肯定应该入栈，但错误的算法中有可能是触发出栈的第二个运算数，所以不一定能入栈。
15. 也许仍然可以用第二个运算数来出栈，但肯定要进行复杂的判断和处理。而且，从语义上来说，触发运算行为的还是应该由运算符来进行。因为运算数只是运算的数据，而运算符才是运算的行为定义。


## 从中序到后序的转换
### 运算数顺序不会发生改变
1. 先看个没有括号的例子：中序表达式 `1 + 2 * 3 - 4` 转换为后序表达式 `1 2 3 * + 4 -`。
2. 最高优先级的 `2 * 3` 中运算数不发生改变；前面的 `1` 相对于 `2 * 3` 来说是左运算数，所以也是放在左边；后面的 `4` 相对于 `1 + 2 * 3` 来说是右运算数，所以放在右边。
3. 再看有括号的情况：中序表达式 `1 + 2 * (3 - 4)` 转换为后序表达式 `1 2 3 4 - * +`。
4. 同样，最高优先级的 `(3 - 4)` 中运算数不发生改变；前面的 `2` 相对于 `(3 - 4)` 来说是左运算数，所以也是放在左边；最前面的 `1` 相对于 `2 * (3 - 4)` 来说是左运算数，所以放在左边。
5. 即使一个表达式很长，但从最高优先级开始，每个运算数或子表达式都只是和它两侧有关系。除非运用交换律，否则和两侧的做有关系就是保持不变的。既然在一个局部是不变的，那么随着不断的计算合并，在更大的局部上这个关系也就是不变的。而前序和后序同样要遵守这个顺序，即使加法和乘法可以颠倒，但减法和除法以及其他一些都是不能颠倒的。所以在中序中运算数是怎样的顺序，到了前序和后序还是一样的顺序。

### 【错误，反例 `1 + 2 * 3 - 4 / 5`】运算符根据优先级线性排列
1. 因为前序和后序表达式的计算过程是线性的，所以运算符就是按照优先级线性排列。
2. 所以中序转换为后序，就是在原来运算数的顺序上，按照优先级在合适的地方插入运算符。
3. 如果两个运算数是直接进行计算的，那么就应该在它们后面插入运算符。例如 `1 2 3 * + 4 -` 中的 `*`。
4. 如果前者的运算数是和后者所在的子表达式进行计算的，那么这两个运算数之间就不应该插入运算符，运算符应该插在后者所在的子表达式的后面。例如 `1 2 3 * + 4 -` 中的 `+`。

### 没有括号的情况
1. 考虑 $1 + 2 * 3 - 4$ 和 $1 + 2 - 3 - 4$ 情况。
2. 读取到第一个运算数 $1$，放入结果字符串。
3. 读取到之后的运算符 $+$，要先暂存，等待后续的运算数。这种暂存后续使用的场景，适合使用栈来实现。因此 $+$ 进运算符栈，等待计算。
4. 然后读取到第二个运算数 $2$，放入结果字符串。
5. 这时，应不应该执行 $1 + 2$ 呢？即应不应该让结果字符串变成 `12+`？
6. 仅从目前读取到的三个字符判断，无法知道 $2$ 应该是说 $+$ 的第二个运算数，还是某个子表达式的第一个运算数。
7. 必须要看下一个运算符和刚才保存的运算符 $+$ 的优先级比较。如果下一个运算符的优先级比 $+$ 高，比如 $*$ ,那就不能计算 $1 + 2$，因为 $2$ 实际上是属于子表达式 $2 * 3$ 的；如果下一个运算符的优先级比 $+$ 低，那就应该优先计算 $1 + 2$；如果和 $+$ 相同，那根据左边优先的原则，也应该优先计算 $1 + 2$。
8. 如果下一个运算符比 $+$ 高，比如 $*$，那么就要让 $*$ 入栈等待后面的操作数。同样，等到后面一个操作数之后仍然不能直接计算 $*$，因为同样还要看看之后有没有运算符，如果有的话还需要比较和 $*$ 的优先级，和上一步的规则一样。
9. 所以，保存一个运算符栈的意义，除了要等待它后面第二个运算数，还要等待第二个运算符，来确定优先级。

#### 如果第二个运算符优先级比 $+$ 高
1. 比如这里 $1 + 2 * 3 - 4$ 中的 $*$。那就证明要先进行第二个运算的计算，所以还要再保存 $*$，然后继续读取后面的运算数，也就是这里的 $3$。
2. 结果字符串变为 `123`，运算符栈变为 `[+, *]`
3. 记录完 $3$ 之后，和上面的情况一样，还是不能确定后一个运算符的优先级。（虽然在这个例子里，$*$ 已经是最高优先级的了，但后续我们还会加上括号，所以不能确保 $*$ 就是最高优先级。）所以还要读取下一个运算符 $-$。
4. 在这里，$-$ 的优先级小于 $*$。所以此时应该计算 $*$ 运算了。
5. 结果字符串变为 `123*`，运算符栈变为 `[+]`。
6. 现在，$-$ 还不能入栈。因为入栈后变成了 `[+-]`，之后 $-$ 就会在 $+$ 之前执行了。所以在入栈前还要和栈里面剩余的比较一下，如果栈内还有更优先的，要先计算栈内的。
7. 所以 $+$ 出栈进行计算，结果字符串变为 `123*+`，运算符栈变为 `[]`。
8. 现在栈内没有比 $-$ 更优先的了，$-$ 入栈等待。
9. 记录下一个运算数，结果字符串变为 `123*+4`，运算符栈现在为 `[-]`。
10. 后面没有字符了，所以让剩余的运算符 $-$ 出栈，参与最后一步运算。结果为 `123*+4-`。

#### 如果第二个运算符优先级比 $+$ 低
1. 比如这里 $1 + 2 - 3 - 4$ 中的 $-$。那就证明要先进行 $+$ 计算，然后再保存 $-$。
2. 结果字符串变为 `12+`，运算符栈变为 `[-]`。
3. 接着记录 $3$ 之后，然后发现第三个运算符 $-$。
4. 这个 $-$ 想入栈，但是发现栈内存在一个和自己同级的运算符，所以应该先让栈内的 $-$ 出栈运算，然后自己再入栈等待后续操作数。
5. 结果字符串变为 `12+3-`，运算符栈变为 `[-]`
6. 记录运算数 $4$。
7. 后面没有字符了，所以让剩余的运算符 $-$ 出栈，参与最后一步运算。结果为 `12+3-4-`

### 加入括号的情况
1. 考虑 $( A + B ) * ( C + D )$。
2. 因为 $($ 要等待 $)$，所以它也要入栈等待。
3. 而且，除了 $)$，没有其他运算符可以让 $($ 出栈参与运算。所以，可以把 $($ 的优先级定为最低。但它又有特殊之处。
4. 前面说到，低优先级的运算符要入栈的时候，栈内的高优先级运算符要出栈。但是考虑这里的情况，当第二个 $($ 想要入栈时，栈内有优先级更高的 $*$。但这时，显然不能让 $*$ 出栈，而是要让 $($ 直接入栈。
5. 从这个角度看，$($ 又像是优先级最高的。
6. 其实，单就一个独立的括号结构来说，比如 $(x + y * z)$，$($ 的优先级最低的，只有当括号内部所有运算完成后，$($ 才能和 $)$ 把它们括起来包装输出一个最终结果。而在这个括号结构和外面的关系中，$($ 又比外部的任何运算符优先级都高，只有 $($ 和 $)$ 以及运算完之后，才能和外部的运算数进行运算。
7. 所以，上面说把 $($ 优先级定为最低，就是相对于括号内部的运算符；而 $($ 入栈时不会让里面的运算符出栈，因为里面已有的运算符是括号外面的，所以 $($ 相对于它们来说有着最高的优先级。
8. 当出现 $)$ 的时候，它本身并不需要入栈，它的出现，意味着栈内直到最近的 $($ 之间的运算符可以出栈进行运算了，来计算出整个括号的值。

### 算法
* 如果字符是操作数
    1. 因为是后序，操作数在前，所以将该操作数 push 到结果字符串
* 如果字符是左括号
    1. 左括号也算作运算符，相对于它左边的运算符，它的优先级最高。
    2. 将其 push 到运算符栈中。
* 如果字符是右括号
    1. 可以想到，此时运算符栈靠下的某个位置已经有了左括号，而栈顶也是一个非括号运算符。（右括号不会被推栈）
    2. 依次从运算符栈中 pop 出运算符并 push 到结果字符串中，直到移除对应的左括号。
    3. 之所以可以依次 pop 并 push 到结果字符串，就是因为下面对普通运算符的处理逻辑。
* 如果字符是普通运算符（非左括号）
    1. 将其 push 运算符栈中。但是，在这之前，需要先从栈中 pop 出优先级更高或相同的运算符，并将它们 push 到结果列表的末尾。
    2. 观察上一步的逻辑，它会保证栈中上部的运算符优先级总是大于下部的。以及，两个同等优先级的运算符，先出现的会先加入到结果字符串中。
    3. 这样也就保证了优先级更高的运算符会优先计算。
* 当处理完输入表达式以后
    1. 检查运算符栈，将其中所有的运算符依次 pop 并 push 到结果列表字符串。
    2. 考虑 `A * B + C * D `，遍历完所有字符后，栈中剩下的是 `['+', '*']` 。先 pop 优先级高的乘号，再 pop 优先级低的加号。

### 实现
#### JavaScript
```js
const operatorPriority = {
    '*': 3,
    '/': 3,
    '+': 2,
    '-': 2,
    '(': 1,
}


function infixToPostfix (infixExp) {
    let stack = [];
    let result = [];
    let tokens = infixExp.split(' ');

    for (let i=0; i<tokens.length; i++) {
        let token = tokens[i];
        if (token === '(') {
            stack.push(token);
        }
        else if (token === ')') {
            let popped = stack.pop();
            if (popped !== '(') {
                result.push(popped);
                stack.pop();
            }
        }
        else if (token in operatorPriority) {
            while (stack.length > 0 
                    && operatorPriority[stack[stack.length-1]] >= operatorPriority[token]
            ) {
                result.push(stack.pop());
            }
            stack.push(token);
        }
        else {
            result.push(token);
        }
    }

    while (stack.length) {
        result.push(stack.pop());
    }

    return result.join(' ');
}

console.log(infixToPostfix('A * B + C * D')); // A B * C D * +
console.log(infixToPostfix('A + B * C + D')); // A B C * + D + 
console.log(infixToPostfix('A + B + C + D')); // A B + C + D +
console.log(infixToPostfix('( A + B ) * ( C + D )')); // A B + C D + *
console.log(infixToPostfix('( A + B ) * C')); // A B + C *

console.log(infixToPostfix('1 + 2 * 3 - 4')); // 1 2 3 * + 4 -
console.log(infixToPostfix('1 + 2 * ( 3 - 4 )')); // 1 2 3 4 - * +
console.log(infixToPostfix('1 + 2 * 3 - 4 / 5')); // 1 2 3 * + 4 5 / -
console.log(infixToPostfix('1 + 2 * 3 - ( 4 / 5 )')); // 1 2 3 * + 4 5 / -
console.log(infixToPostfix('( 1 + 2 ) * ( 3 - 4 )')); // 1 2 + 3 4 - *
```

#### Python
```py
from pythonds.basic import Stack
import string

def infixToPostfix(infixexpr):
    prec = {}
    prec["*"] = 3
    prec["/"] = 3
    prec["+"] = 2
    prec["-"] = 2
    prec["("] = 1

    opStack = Stack()
    postfixList = []

    tokenList = infixexpr.split()
    for token in tokenList:
        if token in string.ascii_uppercase:
            postfixList.append(token)
        elif token == '(':
            opStack.push(token)
        elif token == ')':
            topToken = opStack.pop()
            while topToken != '(':
                postfixList.append(topToken)
                topToken = opStack.pop()
        else:
            while (not opStack.isEmpty()) and \
                (prec[opStack.peek()] >= prec[token]):
                    postfixList.append(opStack.pop())
            opStack.push(token)
           
    while not opStack.isEmpty():
        postfixList.append(opStack.pop())

    return " ".join(postfixList)


print(infixToPostfix('A * B + C * D'))              # A B * C D * +
print(infixToPostfix("( A + B ) * ( C + D )"))      # A B + C D + *
print(infixToPostfix("A * B + C * D"))              # A B * C D * +
print(infixToPostfix("( A + B ) * C"))              # A B + C *
print(infixToPostfix("A + B * C"))                  # A B C * +
print(infixToPostfix("( A + B * E ) * ( C + D )"))  # A B E * + C D + *
```


## 从中序到前序的转换
1. 如果还是按照转换为后序的方式遍历中序表达式，就会出现先把运算数放进结果字符串、之后再把运算符越过运算数插入到前面的情况，而且不同的情况下越过的运算数的数量还不同。即使可以实现也会很麻烦。
2. 那么这里就和前面的计算前序表达式的情况一样，可以从后往前遍历中序表达式。
3. 不过有两点与转换为后序表达式不同：
    * 因为是从右往左，所以现在括号就是从右括号开始从左括号结束；
    * 之前如果栈里的运算符和当前遍历到的运算符优先级相同，则根据从左到右计算的原则，应该认为栈里的优先级更高；而现在因为是从右往左，所以栈里更早的相同优先级的运算符是更靠右的，所以就应该认为是优先级更低。
4. 其他部分原理相同
    ```js
    const operatorPriority = {
        '*': 3,
        '/': 3,
        '+': 2,
        '-': 2,
        ')': 1, // 右括号作为括号的起始
    }

    function infixToPrefix (infixExp) {
        let stack = [];
        let result = [];
        let tokens = infixExp.split(' ');

        for (let i=tokens.length; i>=0; i--) { // 从右往左遍历
            let token = tokens[i];
            if (token === ')') { // 右括号作为括号的起始
                stack.push(token);
            }
            else if (token === '(') {
                let popped = stack.pop();
                if (popped !== ')') {
                    result.push(popped);
                    stack.pop();
                }
            }
            else if (token in operatorPriority) {
                // 这里从大于等于变成了大于，优先级相同的情况下栈里更早的认为优先级更低
                while (stack.length > 0 
                        && operatorPriority[stack[stack.length-1]] > operatorPriority[token]
                ) {
                    result.push(stack.pop());
                }
                stack.push(token);
            }
            else {
                result.push(token);
            }
        }

        while (stack.length) {
            result.push(stack.pop());
        }

        // 反转
        return result.reverse().join(' ');
    }


    console.log(infixToPrefix('A * B + C * D')); // + * A B * C D
    console.log(infixToPrefix('A + B * C + D')); // + + A * B C D
    console.log(infixToPrefix('A + B + C + D')); // + + + A B C D
    console.log(infixToPrefix('( A + B ) * ( C + D )')); // * + A B + C D
    console.log(infixToPrefix('( A + B ) * C')); // * + A B C

    console.log(infixToPrefix('1 + 2 * 3 - 4')); // - + 1 * 2 3 4
    console.log(infixToPrefix('1 + 2 * ( 3 - 4 )')); // + 1 * 2 - 3 4
    console.log(infixToPrefix('1 + 2 * 3 - 4 / 5')); // - + 1 * 2 3 / 4 5
    console.log(infixToPrefix('1 + 2 * 3 - ( 4 / 5 )')); // - + 1 * 2 3 / 4 5
    console.log(infixToPrefix('( 1 + 2 ) * ( 3 - 4 )')); // * + 1 2 - 3 4
    ```


## References
* [《Python数据结构与算法分析（第2版）》第3章](https://book.douban.com/subject/34785178/)