# 栈


<!-- TOC -->

- [栈](#栈)
    - [本质](#本质)
        - [后入先出和先入后出](#后入先出和先入后出)
        - [时间或空间的对称性](#时间或空间的对称性)
        - [无交叉嵌套式的对称结构](#无交叉嵌套式的对称结构)
        - [无交叉嵌套式的对称行为](#无交叉嵌套式的对称行为)
        - [栈式暂存](#栈式暂存)
    - [用途](#用途)
        - [模拟无交叉嵌套式的对称结构](#模拟无交叉嵌套式的对称结构)
        - [模拟无交叉嵌套式的对称行为](#模拟无交叉嵌套式的对称行为)
    - [用两个栈实现一个队列](#用两个栈实现一个队列)

<!-- /TOC -->


## 本质
### 后入先出和先入后出
1. 本来以为，入栈和出栈作为一组对称的操作，对于同一个元素来说，入栈越早，出栈就越晚。
2. 但是比如说这个括号匹配的例子 `{[()()]()}`，中括号是第二个入栈的，但却不是倒数第二个出栈的。因为中括号出栈之后，还有其他新的元素入栈并出栈。
3. 不过，中括号要出栈的话，必须要等到它之后所有入栈的元素都出栈才行。
4. 所以准确的应该是说，对于当前都在栈里的元素来说，入栈越早的，出栈就越晚。
5. 同样，说后入先出，也是对于当前都在栈里的元素来说，比如 `()()`，第二个括号从时间上来说就是后入后出，但它并不是和第一个括号同时在栈里。
6. 但是对于队列来说，先入先出和后入后出却是绝对的。
7. 因为栈的入口和出口是同一个，之前入栈的元素想要出栈，那就必须要让它后面直到出口的所有更新的元素先出栈；而队列的入口和出口却是不同的，越早入列的就越接近出口，要出列时需要让更早入列的元素先出去。
8. 如果只考虑出口的话，入栈越早的元素越远离出口，而入列越早的元素越接近出口。

### 时间或空间的对称性
1. 在用两个栈实现一个队列时，体会出了这种空间上的对称性。
2. 至于时间上的对称性，可以想象，越早入栈的元素，会匹配越晚的时间来出栈。
3. 现在还不知道怎么用语言来准确的描述这种对称性，先体会这种感觉。

### 无交叉嵌套式的对称结构
1. 入栈和出栈是对称的结构，而且这个对称结构内部还可以嵌套其他若干个、若干层的对称结构，比如说：A入-B入-B出-A出。
2. 但是两个对称结构不能交叉，也就是说不能发生：A入-B入-A出-B出。
3. 例如括号匹配中，可以是 `[()]`，但不能是 `[(])`。
4. 这里强调结构上的无交叉嵌套对称（例如括号匹配算法），而不是行为上出栈入栈关系（例如嵌套函数的调用和返回）。

### 无交叉嵌套式的对称行为
嵌套式的入栈和出栈——栈和函数嵌套调用
1. 入栈和出栈是对称的行为，并且在一组入栈和出栈之间还可以嵌套其他组的入栈和出栈，比如说：A入-B入-B出-A出。
2. 但是两组对称行为不能交叉，也就是说不能发生：A入-B入-A出-B出。
3. 例如在嵌套函数调用中，可以是：调用A-调用B-B返回-A返回，但不能是：调用A-调用B-A返回-B返回。
4. 这里强调行为上的无交叉嵌套对称（例如嵌套函数的调用和返回），而不是结构上的（例如括号匹配算法）。

### 栈式暂存
1. 计算后序表达式，暂时不用的运算数和运算符会存放到栈里，等会取出来使用。
2. 队列也可以存放暂时不用的数据，但是栈取出时是取出更晚存放的，而队列是取出更早存放的。


## 用途
### 模拟无交叉嵌套式的对称结构
例如括号匹配算法。

### 模拟无交叉嵌套式的对称行为
1. 一个函数调用的开始相当于入栈，这个函数调用的结束相当于出栈；
2. 这个函数内部还嵌套调用了其他函数，那就是在当前栈的基础上继续有入栈；
3. 其他函数调用完成出栈后，这个函数才能结束调用出栈。


## 用两个栈实现一个队列
1. 这里的一个前提是，我们的栈已经实现好了，也就是说不能为了实现队列而修改当前栈的实现。
2. 栈和队列添加元素的方式是一样的，而取出元素的方式是相反的。
3. 为了取出最早 push 的元素，需要把后来加入的所有元素先 pop 出来并保存到其他地方。
4. 假设现在栈 A 里面是 `[1, 2, 3, 4, 5]`，要 dequeue 的对象是 `1`。那就先依次把 `5`、`4`、`3`、`2` pop 出来并 push 到栈 B 里面。
5. 栈 B 变成 `[5, 4, 3, 2]`。现在，不仅能成功的 dequeue `1`，而且 B 里面的顺序也成了队列的顺序了。
6. 正是由于栈的对称性，所以在轻松实现了反转。
7. 现在 dequeue 就从 B 里面 pop，enqueue 就往 A 里面 push；如果 B 空了就再把 A 里面的转移进来
    ```cpp
    #include <stdio.h>
    #include "Stack.h"


    Stack s1;
    Stack s2;

    void enqueue (int n);
    int dequeue ();
    void remove_to_s2();
    void printQueue();


    int main(void) {
        
        initStack(&s1, 10);
        initStack(&s2, 10);
        
        enqueue(15);
        enqueue(6);
        enqueue(9);
        enqueue(8);
        enqueue(4);
        printQueue();

        enqueue(17);
        enqueue(3);
        enqueue(5);
        printQueue();

        printf("Dequeue %d\n", dequeue());
        printQueue();

        freeStack(&s1);
        freeStack(&s2);
        
        return 0;
    }


    void enqueue (int n) {
        push(&s1, n);
    }
    int dequeue () {
        if (isEmpty(&s2)) {
            remove_to_s2();
        }
        return pop(&s2);
    }
    void remove_to_s2 () {
        int top1 = s1.top;
        while (top1-- >= 0) {
            push(&s2, pop(&s1));
        }
    }
    void printQueue() {
        int top2 = s2.top;
        while (top2 >= 0) {
            printf("%d ", s2.list[top2--]);
        }
        printStack(&s1);
        printf("\n");
    }
    ```