# LinkedList


<!-- TOC -->

- [LinkedList](#linkedlist)
    - [链表和数组的区别](#链表和数组的区别)
        - [内存连续型不同](#内存连续型不同)
            - [查询元素的区别](#查询元素的区别)
            - [插入和移除元素的区别](#插入和移除元素的区别)
        - [设计思想区别](#设计思想区别)

<!-- /TOC -->


## 链表和数组的区别
### 内存连续型不同 
1. 从内存使用上来说，传统数组中的元素在内存上是连续的，而链表的元素因为是通过指针联系，所以不需要是连续的。
2. 由于这个特性，所以链表查询元素比较耗时，而数组插入和删除元素比较耗时。

#### 查询元素的区别
1. 因为这种连续性，只要确保所有数组项都保存同样类型的数据，也就是每个数组项都占用同样长度的内存，那么想要根据 index 读取某一项时，可以很方便的计算出来它所在的位置，然后立刻找到。
2. 而链表的每一个节点都是通过指针连接的，所以想要读取元素只能从第一个节点开始，依次按照每个节点的指针找到目标。

#### 插入和移除元素的区别
1. 因为这种连续型，所以从数组的起点或中间插入或移除项的成本很高，因为后面所有的数组项都要依次往后移动一位。
2. 而链表因为没有这种连续型，所以添加或移除元素的时候不需要移动其他元素，只需要在要插入的地方连接上新的节点即可。
3. 如果是 append 到最后一项，则数组会比较快，因为它拥有较快的查询，且 append 不涉及移动数组项；而链表还是需要从头部一路根据指针找到尾部。（如果是双向列表，则可以从尾部开始，所以也不会慢）

### 设计思想区别
1. 传统数组的方式是全盘统一管理，链表的方式是自治管理。
2. 统一管理会有一套统一的编制体系，所以查找起来更方便。但因为是一套编制，所以其中一个节点的变动都是对整个编制的变动。
3. 自治管理中，虽然每个节点有同一个的规则，但是所有节点并没有规划进统一的编制。因此两个节点或多个节点直接发生的变动，并不会影响全局，更准确的说就是根本没有一个全局编制。而没有全局编制的缺点也就是不方便在全局层面上进行管理。
4. 倒是有些像集权和封建的感觉。