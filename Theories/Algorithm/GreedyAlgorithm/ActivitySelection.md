# 活动选择问题


<!-- TOC -->

- [活动选择问题](#活动选择问题)
    - [调度竞争共享资源的多个活动](#调度竞争共享资源的多个活动)
    - [如果使用动态规划](#如果使用动态规划)
    - [活动选择问题的最优子结构](#活动选择问题的最优子结构)
    - [贪心选择](#贪心选择)
    - [递归贪心算法](#递归贪心算法)

<!-- /TOC -->


## 调度竞争共享资源的多个活动
1. 若干个活动使用同一个资源，而这个资源在某个时刻只能供一个活动使用。
2. 每个活动都有一个开始时间和结束时间，任务发生在半开半闭的时间区间内。
3. 如果两个任务的时间区间不重叠，则称它们是 **兼容的**。
4. 在 **活动选择问题** 中，我们希望选出一个最大兼容活动集。也就是安排尽可能多的活动，而不是总活动时长更多。
5. 假定活动已经按照结束时间的单调递增顺序排序。


## 如果使用动态规划
1. 我们可以通过动态规划方法将这个问题分为两个子问题，然后将两个子问题的最优解整合为原问题的最优解。
2. 在确定该将哪些子问题用于最优解时，需要考虑几种选择。
3. 但之后会发现，如果使用贪心算法则只需要考虑一种选择，即贪心的选择。
4. 在做贪心选择时，子问题之一必是空的。因此，只留下一个非空子问题。
5. 基于这些观察，我们将找到一种递归贪心算法来解决活动调度问题，并将递归算法转化为迭代算法，以完成贪心算法的过程。


## 活动选择问题的最优子结构
1. 如果使用动态，我们就要分析出子结构，找到子问题。
2. 在面对 n 个活动时，我们需要先选定一个活动，假定它就是兼容活动集中的一个。然后，在对它之前的活动（结束时间小于等于它的开始时间）和它之后的活动（开始时间大于等于它的结束时间）递归求解。
3. 我们选定的这个活动，再加上两个递归求解得出的两组活动，加在一起就是一组兼容的活动集合。
4. 当然这一组兼容的活动集合不一定是最优的。所以我们在从 n 个活动里面选定一个活动时，就要遍历 n 个活动，对每种情况都按照上面的方法求解，得出 n 个兼容的活动集合，然后就可以从里面选出一个最优的。
5. 按照这个算法，我们会求解所有可能的子问题。

## 贪心选择
1. 假如我们不需要求解所有的子问题会怎样？如果每次选择一个活动不需要遍历当前的所有活动而是确定的选择一个。
2. 对于活动选择问题，我们其实每次不需要遍历当前的所有活动，而只需要考虑一个选择，就是贪心选择。
3. 我想到的贪心选择是时长最短的活动。但实际上正确的贪心选择时结束时间最早的活动。不懂，为什么不能是时长最短的。一个不算是理由的原因是，如果选择了时长最短的，那么它之前和之后都可能要安排其他活动；而如果选择结束时间最早的，那它之前就没时间安排其他活动了，只要考虑往后面安排活动就行了。
4. TODO，不懂。《算法导论》证明选择最早结束的活动是正确的。
5. 既然现在可以贪心的选择最早结束的活动，那就先从排好序的所有活动里选择第一个，也就是最早结束的；然后再从剩下的活动里面，选择呢第一个活动兼容的且最早结束的；然后一次类推直到没有活动可选。
6. 求解活动选择问题的算法不必像基于表格的动态规划算法那样自底向上进行计算，而是可以自顶向下的计算：选择一个活动方法最优解的活动列表中，然后对剩下的活动再递归选择。
7. 贪心算法通常都是这种自顶向下的设计：做出一个选择，然后求解剩下的子问题。而不是自底向上的求解出很多子问题，然后在通过比较做出选择。


## 递归贪心算法
1. 假定 `N` 个活动已经按照结束时间递增的顺序排好。
3. 实现
    ```cpp
    #include <stdio.h>


    #define N 11

    int start_time[N] = {1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12};
    int finish_time[N] = {4, 5, 6, 7, 9, 9, 10, 11, 12, 14, 16};
    int activity[N];


    void recursive_activity_selector (int finishTime, int startIdx) {
        // 找到最早结束的、开始时间大于等于上次活动结束时间的活动
        while ( start_time[startIdx] < finishTime && startIdx < N ) {   
            startIdx++;
        }
        if (startIdx == N) {
            return;
        }
        activity[startIdx] = 1; // 标记选中上面找到的活动
        recursive_activity_selector(finish_time[startIdx], startIdx+1);
    }

    void printSelectedIndexes(int activity[]) {
        for (int i=0; i<N; i++) {
            if (activity[i] == 1) {
                printf("%d ", i);
            }
        }
        printf("\n");
    }


    int main(void) {
        recursive_activity_selector(0, 0);
        printSelectedIndexes(activity); // 0 3 7 10
    }
    ```