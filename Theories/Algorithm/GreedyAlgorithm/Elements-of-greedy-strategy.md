# 贪心算法原理

贪心算法通过做出一系列选择来求出问题的最优解。在每个决策点，它做出在当时看来最佳的选择。这种启发式策略并不保证总能找到最优解，但对有些问题确实有效。


<!-- TOC -->

- [贪心算法原理](#贪心算法原理)
    - [算法设计步骤](#算法设计步骤)
    - [证明贪心算法能否求得最优解](#证明贪心算法能否求得最优解)
        - [贪心选择性质](#贪心选择性质)
        - [最优子结构](#最优子结构)
    - [和动态规划的比较](#和动态规划的比较)
    - [递归背包 TODO，有问题](#递归背包-todo有问题)
    - [Referecens](#referecens)

<!-- /TOC -->


## 算法设计步骤
1. 将最优化问题转化为这样的形式：对其作出一次选择后，只剩下一个子问题需要求解。
2. 证明做出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的。
3. 证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解。这样就得到了最优子结构。


## 证明贪心算法能否求得最优解
如果证明一个贪心算法能够求解一个最优化问题，并没有适合所有情况的方法。但贪心选择性质和最优子结构是两个关键要素。

### 贪心选择性质
1. 第一个关键要素是 **贪心选择性质**（greedy-choice property）：我们可以通过做出局部最优（贪心）选择来构造全局最优解。
2. 也就是说，在进行选择时，我们直接做出在当前问题中看来最优的选择，而不必考虑子问题的解。
3. 这也是贪心算法与动态规划的不同之处。在动态规划方法中，每次进行的选择通常要依赖子问题的解，因此通常是自底向上的方式来求解动态规划。
4. 而一个贪心算法通常是自顶向下的，进行一次又一次选择，将给定问题实例变得更小。
5. 当然，我们必须证明每个步骤做出贪心选择能生成全局最优解。
6. 如果进行贪心选择时我们不得不考虑多个选择，通常意味着可以改进贪心选择，使其更为高效。就像活动选择问题中对数据先进行排序一样，通过对输入进行预处理或者使用适合的数据结构（通常是优先队列），我们通常可以使贪心选择更高效。

### 最优子结构
1. 如果一个问题的最优解包含其子问题的最优解，则称此问题具有 **最优子结构** 性质。此性质是应用动态规划和贪心算法的关键要素。
2. 当用于贪心算法时，我们通常使用更为直接的最优子结构。我们可以假定，通过对原问题应用贪心选择即可得到子问题。
3. 我们真正要做的工作就是论证：将子问题的最优解和贪心选择组合在一起能够生成原问题的最优解。
4. 这种方法隐含地对子问题使用了数学归纳法，证明了在每个步骤进行贪心选择会生成原问题的最优解。


## 和动态规划的比较
1. 以背包问题为例，**0-1 背包问题**（0-1 knapsack problem）和 **分数背包问题**（fractional knapsack problem）都具有最优子结构性质。
2. 虽然两个问题相似，但贪心算法只能求解分数背包问题，而不能求解 0-1 背包问题。
3. 0-1 背包问题的物品就是那几个，而且重量是不相同的；但分数背包问题的物品不能说是只有那几个，而应该说是只有那几种。分数背包问题的物品数是远大于物品种类的，例如物品是以克为单位计算重量的话，那分数背包问题的的物品数就是所有物品的总克数。
4. 在这种情况下，可以说每个物品的重量都是相同的。重量相同而价值不同，那就可以运用贪心算法了。也就是说，每个物品需要的资源是相同的，那当然要贪心的选择最优价值的物品。
5. 而 0-1 背包问题中，每个物品价值不同并且需要的资源也不同，那么进行选择的时候就要权衡，不能只考察价值而不考察资源占用。而且，不仅要考虑一个物品本身的资源占用，还要考虑该物品占用资源之后剩下的资源的最优分配问题。考虑到这里，就明显有动态规划的感觉了，因为在你选择若干个物品中的一个时，需要比较每种选择后剩下的资源的最优解，也就是子问题的最优解。
6. 贪心算法在选择时不需要考虑子问题，而动态规划在选择时需要考虑哪种子问题方案是最优解。


## 递归背包 TODO，有问题
```cpp
#include <stdio.h>

#define N 4
#define V 4
int weights[N] = {1, 4, 3, 1};
int values[N] = {1500, 3000, 2000, 2000};
// #define N 3
// #define V 4
// int weights[N] = {1, 4, 3};
// int values[N] = {1500, 3000, 2000};

// 因为每次递归的时候从最方便的情况来说应该传递一个去掉了某个物品的物品数组，但是这样会重复的创建数组
// 所以使用 weightIndexes 用来记录哪些物品已经被使用了，被使用的物品序号标为 1

int allUsed (int* weightIndexes) {
    for (int i=0; i<N; i++) {
        if (weightIndexes[i] == 0) {
            return 0;
        }
    }
    return 1;
}

int knapsack_01 (int* weightIndexes, int volumn) {
    if (allUsed(weightIndexes) || volumn <= 0) {
        return 0;
    }

    int maxVal = 0;
    int currVal = 0;

    for (int i=0; i<N; i++) {
        // 跳过已经被使用的
        if (weightIndexes[i] == 1) {
            break;
        }
        if (weights[i] > volumn) {
            break;
        }

        weightIndexes[i] = 1; // 标记被使用的
        currVal = values[i] + knapsack_01(weightIndexes, volumn-weights[i]);
        weightIndexes[i] = 0;
        if (currVal > maxVal) {
            maxVal = currVal;
        }
    }

    return currVal;
}


int main(void) {
    int weightIndexes[N] = {0};
    int result = knapsack_01 (weightIndexes , V);
    printf("%d\n", result);
}
```

## Referecens
* [算法导论](https://book.douban.com/subject/20432061/)