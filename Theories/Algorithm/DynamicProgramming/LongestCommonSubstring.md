# Longest Common Substring


<!-- TOC -->

- [Longest Common Substring](#longest-common-substring)
    - [设计思想](#设计思想)
        - [因果递推关系](#因果递推关系)
    - [本质](#本质)
    - [思路](#思路)
        - [1. 找到问题的变量](#1-找到问题的变量)
        - [2. 寻找初始状态](#2-寻找初始状态)
        - [3. 遍历从初始状态到求解状态的所有状态的最优解](#3-遍历从初始状态到求解状态的所有状态的最优解)
    - [最长公共子串](#最长公共子串)
        - [思路](#思路-1)
        - [实现](#实现)
    - [公共子序列](#公共子序列)
        - [思路](#思路-2)
        - [长度值的单调性](#长度值的单调性)
        - [长度值的计算](#长度值的计算)
        - [实现](#实现-1)

<!-- /TOC -->


## 设计思想
### 因果递推关系
1. 我们想知道两个字符串最长的公共子串的长度，假设这个长度为 $x$。怎么才能知道这个 $x$ 是多少？
2. 如果我们知道了 $x-1$ 是多少，就会知道 $x$ 是多少；同理，如果我们知道了 $x-2$ 是多少，就会知道 $x-1$ 是多少。
3. 以此类推，我们遍历比较每个字符的时候，遇到一个相同的字符时，它可能是公共子串的任意位置的字符。要确定它是第几个，就要看它之前的那个位置：如果之前的位置不相同，那当前的就是公共子串的第一个；如果之前的位置是公共子串的第 $n$ 个字符，那此时这个就是第 $n+1$ 个。


## 本质



## 思路
### 1. 找到问题的变量
* 物品种类
* 背包容量

### 2. 寻找初始状态
只有一种物品并且背包容量为 1。

### 3. 遍历从初始状态到求解状态的所有状态的最优解
1. 两个变量所有可能的状态会组成一个二维数组，即 `[[物品种类][背包容量]]`。
2. 求解二维数组每一项对应的状态 `dp[物品种类][背包容量]`。
3. 寻找最优解的情况，在硬币找零问题中比较明显，也就是每种金额有不同的找零方案，然后比较每种方案即可。
4. 但在背包问题中，有哪些方案不是很直观。在指定的物品种类和背包容量下，最优解是什么概念？有哪些可选方案可供比较？
5. 最优解的概念是当前物品当前容量下可装的最大价值。可选方案有哪些？
6. 比如说 3 个物品 4 磅容量，容量是固定的，那可变的就是不同物品的组合。可以 3 个都放，可以放其中 2 个，可以放其中 1 个，一共有 6 中方案。排除掉其中放不下的方案后，剩下方案的比较就能得出最优解。
7. 但这是单独思考某一种状态时的方案选择，实际上不需要遍历所有可能的方案。因为当前的计算可以依赖之前计算的结果。
8. 在 4 磅的情况下，是存在一个曾经的最优解的，就是只有前两个物品的情况下得出的最优解。而这个最优解，在有了第三个物品时，也是作为当前一种可选方案，即：不放第三个物品的方案。
9. 那么，于此对应的就还有另一种方案：放第三个物品的方案。
10. 从放不放第三个物品的维度，可以获得两个方案，这两个方案就是该维度下所有的方案。我们只需要选出这两种方案里面的最优解即可。
11. 不放第三个物品方案的最大价值之前已经算出来，现在就需要算放第三个物品的最大价值。
12. 放第三个物品的最大价值就是，第三个物品的价值加上剩余容量的最大价值。而剩余容量的最大价值也是之前算出来的。


## 最长公共子串
### 思路
1. 因为最长公共子串可能出现在两个字符串的不同的任意位置，所以需要对两个字符串的每个字符都一一比较。
2. 当两个字符比较结果为相同时，它们就是处于长度至少为 1 的公共子串里。
3. 这个相同的字符可能是公共子串的第一个字符，也可能是之后的某个字符。要确定它到底是公共子串的第几个字符，就要看它 “前面” 还有没匹配结果相同的字符。这个 “前面” 是哪儿？
4. 如果当前相同的这个字符的坐标位置是 $(3, 4)$，即第一个字符串的第 3 个字符和第二个字符串的第 4 个字符，那 “前面” 比较的字符就应该是第一个字符串的第 2 个字符和第二个字符串的第 3 个字符，即 $(2, 3)$。
5. 所以，如果 $(2, 3)$ 是公共子串的第一个字符，那 $(3, 4)$ 就是公共子串的第二个字符。也即是说，当前的公共子串长度为 2。
6. 所以，如果一个字符 $(x, y)$ 是匹配结果相同的，那它的长度值就应该是它前面字符 $(x-1, y-1)$ 的长度值加一。当然 $x-1$ 和 $y-1$ 都要大于零，否则 $(x, y)$ 的长度值就只能是 1。

### 实现
```js
function mls (str1, str2) {
    let len1 = str1.length;
    let len2 = str2.length;

    let arr= [];

    for ( let i=0; i<len1; i++ ) {
        arr[i] = [];

        for ( let j=0; j<len2; j++ ) {
            if ( str1[i] === str2[j] ) {
                if ( i>0 && j>0 ) {
                    arr[i][j] = arr[i-1][j-1] + 1;
                }
                else {
                    arr[i][j] = 1;
                }
            }
            else {
                arr[i][j] = 0;
            }
        }   
    }

    return arr;
}


let str0 = 'fish';
let str1 = 'hish';
let str2 = 'vista';

console.log( mls(str0, str1) );
// [0, 0, 0, 0]
// [0, 1, 0, 0]
// [0, 0, 2, 0]
// [1, 0, 0, 3]

console.log( mls(str0, str2) );
// [0, 0, 0, 0, 0]
// [0, 1, 0, 0, 0]
// [0, 0, 2, 0, 0]
// [0, 0, 0, 0, 0]

console.log( mls(str0, str0) );
// [1, 0, 0, 0]
// [0, 2, 0, 0]
// [0, 0, 3, 0]
// [0, 0, 0, 4]
```


## 公共子序列
### 思路
### 长度值的单调性
1. 公共子串的情况中，因为要求必须是连续的，所以一个字符串中可能会出现多个不连续的公共子串。
2. 所以，随着矩阵坐标的增加，每个位置的长度值不一定是单调的。比如前面有一个长度为 3 的公共子串，所以最大的长度值为 3。但到 3 就中断，之后可能又会有新的子串，这时就又出现了长度值 1。
3. 而公共子序列则不需要连续，所以长度值就会随着坐标值单调递增的。也就是说，在矩阵中，一个节点的长度值肯定是小于等于它下方和右方的节点长度值。
4. 也就是说，在一个区域内，最大的值一定是右下角的那一个。

### 长度值的计算
1. 一个节点可能有两种比较结果：字符不同和字符相同。
2. 字符不同时，公共子序列长度不变，还是之前子序列最大的长度值。这个最大的长度值，要么是当前位置的左边，要么是当前位置的上面。所以当前位置的长度值应该是取这两个位置中较大的那一个。
3. 如果字符相同，这时我的第一反应是：因为又出现了一个相同的，所以公共子序列的长度又要加一了，大概就是从那两个位置中较大的值再加一。
4. 但是下面的情况显然不符合预期的
    <table>
        <tr>
            <td></td>
            <th>A</th>
            <th>B</th>
            <th>B</th>
        </tr>
        <tr>
            <th>A</th>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
        <tr>
            <th>B</th>
            <td>1</td>
            <td>2</td>
            <td>?</td>
        </tr>
    </table>
5. $(2, 3)$ 这个位置的值应该是 2 而不是 3。$(2, 3)$ 的比较结果是相同，它要基于本次比较之前的结果加一，而本次比较之前的结果肯定是不能包括本次的第二行和第三列这两个 B 的，因为如果要计算这两个 B 相同时的长度值，那么这两个就不能同时再和其他的 B 相同了。
6. 也就是说，第二行的那个 B，它可以和第二列的 B 相同从而组成一个公共子序列，也可以和第三列的 B 相同从而组成另一个公共子序列，但它不能同时和这两个 B 相同。你计算第二个公共子序列的长度时，不能基于第一个公共子序列。
7. 所以 $(2, 3)$ 只能基于下面情况的最大值，也就是 $(1, 2)$
    <table>
        <tr>
            <td></td>
            <th>A</th>
            <th>B</th>
        </tr>
        <tr>
            <th>A</th>
            <td>1</td>
            <td>1</td>
        </tr>
    </table>
8. 也就是说，如果 $(x, y)$ 比较结果相同，那它的长度值应该是它的左上角 $(x-1, y-1)$ 的长度值加一。
9. 但比较结果为不同的时候并不需要考虑这个情况，并不需要使用左上角的值
    <table>
        <tr>
            <td></td>
            <th>A</th>
            <th>B</th>
            <th>C</th>
        </tr>
        <tr>
            <th>A</th>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
        <tr>
            <th>B</th>
            <td>1</td>
            <td>2</td>
            <td>?</td>
        </tr>
    </table>
10. 因为不同时，当前长度值的意义是：之前所有公共子序列的最大值；而相同时长度值的意义是：当前公共子序列的最大值。

### 实现
```js
function lcs (str1, str2) {
    let len1 = str1.length;
    let len2 = str2.length;

    let arr= [];

    for ( let i=0; i<len1; i++ ) {
        arr[i] = [];

        for ( let j=0; j<len2; j++ ) {
            if ( str1[i] === str2[j] ) {
                if ( i>0 && j>0 ) {
                    arr[i][j] = arr[i-1][j-1] + 1;
                }
                else {
                    arr[i][j] = 1;
                }
            }
            else {
                if ( i>0 && j>0 ) {
                    arr[i][j] = Math.max(arr[i-1][j], arr[i][j-1]);    
                }
                else if ( i>0 ) {
                    arr[i][j] = arr[i-1][j];
                }
                else if ( j>0 ){
                    arr[i][j] = arr[i][j-1];
                }
                else {
                    arr[i][j] = 0;
                }
            }
        }   
    }

    return arr;
}


let str0 = 'fish';
let str1 = 'hish';
let str2 = 'vista';

console.log( lcs(str0, str1) );
// [0, 0, 0, 0]
// [0, 1, 1, 1]
// [0, 1, 2, 2]
// [1, 1, 2, 3]

console.log( lcs(str0, str2) );
// [0, 0, 0, 0, 0]
// [0, 1, 1, 1, 1]
// [0, 1, 2, 2, 2]
// [0, 1, 2, 2, 2]

console.log( lcs(str0, str0) );
// [1, 1, 1, 1]
// [1, 2, 2, 2]
// [1, 2, 3, 3]
// [1, 2, 3, 4]

console.log( lcs('fort', 'fosh') );
// [1, 1, 1, 1]
// [1, 2, 2, 2]
// [1, 2, 2, 2]
// [1, 2, 2, 2]

console.log( lcs('fish', 'fosh') );
// [1, 1, 1, 1]
// [1, 1, 1, 1]
// [1, 1, 2, 2]
// [1, 1, 2, 3]
```