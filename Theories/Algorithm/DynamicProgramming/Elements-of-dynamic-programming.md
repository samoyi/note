# 动态规划设计的要素

适合应用动态规划方法求解的最优化问题应该具备的两个要素：**最优子结构**（optimal substructure）和 **重叠子问题**（overlapping subproblems）。


<!-- TOC -->

- [动态规划设计的要素](#动态规划设计的要素)
    - [设计目的](#设计目的)
        - [关键细节](#关键细节)
            - [怎么拆分问题](#怎么拆分问题)
            - [拆分维度](#拆分维度)
            - [第一次拆分要怎么拆](#第一次拆分要怎么拆)
            - [自底向上的底是什么](#自底向上的底是什么)
            - [子问题要怎么解决](#子问题要怎么解决)
            - [怎么获得最优解的方案](#怎么获得最优解的方案)
    - [实现原理](#实现原理)
        - [拆分复杂问题](#拆分复杂问题)
        - [拆分维度](#拆分维度-1)
        - [第一次拆分要怎么拆](#第一次拆分要怎么拆-1)
        - [拆分出的子问题尽可能少——子问题空间尽量简单](#拆分出的子问题尽可能少子问题空间尽量简单)
        - [选择最优拆分方法](#选择最优拆分方法)
            - [背包问题的情况](#背包问题的情况)
        - [确定底部子问题](#确定底部子问题)
        - [子问题的解决方法和原问题的解决方法相同](#子问题的解决方法和原问题的解决方法相同)
        - [记录最优解的方案](#记录最优解的方案)
    - [抽象本质](#抽象本质)
        - [拆分复杂问题——子结构](#拆分复杂问题子结构)
        - [不同的拆分方法对应不同的解——最优子结构](#不同的拆分方法对应不同的解最优子结构)
        - [自顶向下和自底向上的区别](#自顶向下和自底向上的区别)
        - [有很多子问题是相同的——重叠子问题](#有很多子问题是相同的重叠子问题)
        - [记录最优解](#记录最优解)
    - [设计思想](#设计思想)
    - [解题步骤](#解题步骤)
    - [最优子结构](#最优子结构)
        - [对于不同问题领域](#对于不同问题领域)
        - [粗略分析最优解](#粗略分析最优解)
        - [一些微妙之处](#一些微妙之处)
    - [重叠子问题](#重叠子问题)
        - [备忘](#备忘)
        - [重构最优解](#重构最优解)
    - [递归式](#递归式)
    - [Referecens](#referecens)

<!-- /TOC -->


## 设计目的
* 问题过于复杂，无法直接解决。
* 问题有若干种解决方法，但只有其中的一个或几个是最优解，我们需要选出最优解。

### 关键细节
#### 怎么拆分问题
1. 对于斐波那契数列问题，它的拆分规则很明显，就是拆分为前两个数对应的子问题。
2. 但是对于比如钢条切割问题，原问题是怎样切割一个十英寸的钢条。能拆分成几个怎样的什么子问题呢？
3. 是拆分成两个子问题，比如怎样切割两个五英寸的钢条？怎样切割一个三英寸的钢条和一个七英寸的钢条？
4. 还是拆分成五个子问题，比如说怎样切割五个两英寸的钢条？怎样切割四个一英寸的钢条和一个六英寸的钢条？
5. 可以看到，对于原问题有很多种不同的拆分方法。到底怎么选？

#### 拆分维度
有些问题只涉及一个数据维度，例如矩阵链只涉及矩阵链的长度。而有些问题则涉及更多的数据维度，例如背包问题涉及到物品数和背包容量两个维度。

#### 第一次拆分要怎么拆
1. 对于斐波那契数列问题，它的拆分方法就在它的定义之中。多数问题要拆分的数据也是比较直观的，比如钢条切割问题就是把长钢条拆分为更短的钢条，矩阵链问题就是把长的矩阵链拆分为短的矩阵链。
2. 但是对于比如说背包问题，它的背包容量拆分方法也很简单，但是物品数的拆分就比较特殊，如果只是简单的按照物品数拆分，那就无法顺利求解。

#### 自底向上的底是什么
1. 对于斐波那契数列问题，它的底很明显，就是数列最开始的元素。
2. 但是对于比如钢条切割问题，怎么知道底是什么？

#### 子问题要怎么解决
1. 对于像斐波那契数列，它的定义就明确了每个子问题要怎么利用更下层的子问题。但其他一些不明确的问题呢？
2. 例如钢条切割问题，最底部的子问题是 1 英寸钢条，可以直接查已知数据获得。那么此时要怎么求解 2 英寸钢条的最优解？或者更有意义的说，知道了 1 英寸、2 英寸和 3 英寸钢条的最优解，怎么求解 4 英寸钢条的最优解？

#### 怎么获得最优解的方案
最优解的值可以计算出来，但具体是哪种方案得出的？比如钢条切割具体要求从哪里切。


## 实现原理
### 拆分复杂问题
1. 问题过于复杂，无法直接解决，所以考虑将它拆分为子问题。
2. 如果拆分的方式像归并排序那样，拆出来的各级子问题都是不重叠的，那就可能是通过分治算法来解决。
3. 但如果拆分出的各级子问题会有重叠的部分，那就可能是通过动态规划来解决。

### 拆分维度
1. 像矩阵链问题只需要对矩阵链这一个数据进行拆分，而背包问题需要对物品数和背包容量这两个问题进行拆分。
2. 当然拆分维度并不对应于表格维度，比如上述两个问题的表格都是二维的。

### 第一次拆分要怎么拆
对于斐波那契数列问题，它的拆分方法就在它的定义之中。多数问题要拆分的数据也是比较直观的，比如钢条切割问题就是把长钢条拆分为更短的钢条，矩阵链问题就是把长的矩阵链拆分为短的矩阵链，背包问题是拆分出更少的物品。

### 拆分出的子问题尽可能少——子问题空间尽量简单
1. 上面说到钢条切割问题，对于原问题可以拆分出不同个数的子问题。
2. 其实不管拆分出几个子问题，都可以在当前个树下求解。
3. 但显然，拆分出的子问题越少，求解起来就越简单。
4. 最简单的当然就是只拆分出一个子问题。比如求解阶乘时，就是只使用一个子问题。
5. 还有些问题看起来好像不能拆分成一个子问题，但其实可以，方法是拆分出一个子问题加一个常量。

### 选择最优拆分方法
1. 我们知道这个问题有若干个解，但只有一个或几个解是最优解，需要找出一个最优解。
2. 那么基于上面拆分原问题的情况，就是说，原问题可以有多种拆分出子问题的方法，我们需要从中选择出最优拆分方法。
3. 例如钢条切割问题拆分出不同长度的子钢条，矩阵链问题拆分出不同长度的子矩阵链，硬币找零方法根据最有一枚硬币的面额拆分出不同的剩余金额。
4. 因此我们就遍历各种拆分方法，来比较哪种是最优的。
5. 具体到每种拆分方法，我们计算出拆分出的子问题的解，然后再通过子问题的解计算原问题的解。
6. 最后，比较每种拆分方法得出的原问题的解，得到一个最优解，以及该最优解的拆分方法。

背包问题也是不同的拆法，但因为它是两个维度，所以拆分出的两个子问题虽然在物品维度上是一样的，但重量维度上不一样。

#### 背包问题的情况
1. 背包问题的情况特殊一些，比如 4 个物品时，它确实拆分出的是 3 个物品的子问题。
2. 但它的选择方法并不是选择不同的 3 个物品，而是选择是否放第 4 个物品来实现两种方案。
3. 这种方案看起来很奇怪，因为其他动态规划问题都是根据一个拆分子问题的规则，选择不同的子问题。也就是说不同的选择是针对子问题的。
4. 比如钢条切割的拆分规则是拆分更短的子钢条作为子问题，那这个子问题的不同选择就是不同长度的子钢条。
5. 背包问题的拆分规则看起来也是拆分出更少的物品，比如从 4 个物品到 3 个物品。但是背包问题的两种选择看起来却不是针对子问题，因为子问题的物品都是一样的，都是前 3 个。并没有说有的子问题选两个物品有的子问题选一个物品，或者有的子问题选前三个物品有的子问题选后三个物品。
6. 但其实这里还是针对子问题进行的不同选择。
7. 因为背包问题有两个维度的数据，物品和容量。两个子问题虽然在物品维度上是一样，但是在容量维度上是不一样的：一个子问题是减去第 4 个物品的容量，一个子问题是原容量。
8. 也就是说，背包问题的拆分规则并不是 “把 N 个物品拆分为更少的物品”。不过这里也很难描述对包问题的拆分规则是什么。
9. 但总之，它的拆分使得原问题可以依赖于更小的子问题，而且这种拆分是容易实现的。

### 确定底部子问题
1. 要确定底部子问题通常不会像菲波那切数列那样直观。但确定的方法也不难，只需要思考第一次划分出的子问题和原问题相比，发生了什么变化。
2. 例如钢条切割问题中，第一次划分除了一个子钢条。例如本来是十英寸的钢条，划分除了以七英寸的钢条子问题和一个三英寸钢条的常量价格。
3. 那变化就是从求解十英寸钢条的最优解变成了七英寸钢条的最优解。
4. 那按照这个变化划分下去，最底部就是求解一英寸钢条的最优解，往上一层就是求解两英寸钢条的最优解，以此类推直到原问题的十英寸。

### 子问题的解决方法和原问题的解决方法相同
1. 对于钢条切割问题，我知道最底部的子问题是长度为 1 的钢条。它再往上一层时长度为 2 的钢条切割方法，但此时我怎么利用之前的结果呢？
2. 再进一步，我算出了了长度为 2 和 3 的钢条切割方法，怎么计算长度为 4 的钢条切割方法呢？
3. 其实，在递归求解长度为 10 的问题时，就一节解决了这个问题。就是遍历从 1 到 10 的切割方法。
4. 所以，其实每一级的子问题都是和原问题同样的解决方法。例如要解决长度为 4 的钢条，就是遍历从 1 到 4 的切割方法。1 和 4 可以直接插原数据，2 和 3 可以直接使用之前的计算结果。

### 记录最优解的方案
1. 考虑钢条切割问题，每个子问题都有一个最优切割点。我们关于整个问题切割方案的信息就是这每一个子问题的最优切割点。
2. 怎么根据这些切割点推算出原问题的最优方案的若干个切割点？
3. 原问题的最优切割点把原问题分为了一个常量和一个一级子问题，一级子问题的最优切割点把一级子问题分为了一个常量和一个二级子问题，以此类推。
4. 所以，为了得到最终的方案，就根据上层问题的最优决策得到下层子问题，然后再根据下层子问题的最优决策得到再下层的子问题，以此类推。
5. 原问题——原问题最优决策——子问题——子问题最优决策——子子问题——子子问题最优决策……


## 抽象本质
### 拆分复杂问题——子结构
1. 复杂的大问题拆分为简单的小问题。也就是原问题的结构可以拆分为子结构。
2. 这是动态规划最核心的要素。所有动态规划都符合这个特征。

### 不同的拆分方法对应不同的解——最优子结构
1. 如果原问题有不同的拆分方法，并且会产生不同的子结构，我们可能会需要找到其中最优的结果。
2. 这是动态规划很常见的要素，动态规划经常就是用来解决最优化问题的。
3. 但并不是必须的，例如是用动态规划解决求解斐波那契数列就只有一个子结构。

### 自顶向下和自底向上的区别
1. 其实两种方法在真正解决的时候，都是要先解决底部的子问题，再逐渐解决往上的子问题，直到顶部的原问题。
2. 区别是对于这一过程，自顶向下是隐式进行的，你只需要建立好递归式，函数调用会自己叠加调用栈，一直叠加到栈顶的底部子问题。然后从栈顶的底部子问题逐渐函数返回出栈，逐渐向下解决网上的子问题，一直到栈底的原问题。
3. 而自底向上的过程是显式的先解决底部子问题，明确的通过循环，从最底层一层一层的往上解决每一层的子问题，直到最上层的原问题。
4. 但其实两种方法在解决每一层子问题时的思路都是一样的：都是利用更底层的子问题。

### 有很多子问题是相同的——重叠子问题
1. 同一种拆分方法或者多种拆分方法中，因为涉及递归的拆分，所以可能会存在很多完全相同的子问题。
2. 这些子问题没有必要重复求解，最直观的方法就是通过缓存。即使是自底向上，因为使用了表，所以其实也是缓存。
3. 不过重叠子问题并不是动态规划的必要要素，比如斐波那契数列求解就不涉及重叠子问题。只不过动态规划的缓存性质适合解决重叠子问题。

### 记录最优解


## 设计思想


## 解题步骤
1. **发现原问题太复杂，考虑拆分**：考虑拆分出一个或多个子问题。也就是动态规划里的子结构。
2. **拆分维度**：看看有几个数据需要拆分。
3. **拆出的子问题要尽可能的少**：最好的情况就是像钢条切割那样只拆出一个子问题。
4. **考虑怎样通过子问题解决原问题**：建立递归式。
5. **如果原问题是最优化问题**：在现有的子问题数量方案下，考虑所有的拆分方法。每种方法的递归方案对应一个解，从中选出最优解。
6. **如果使用自顶向下则加上缓存**。考虑通过什么来唯一区分一个子问题。钢条切割只需要通过长度就行了；而矩阵链乘并不能通过长度，因为长度相同的子矩阵链有着不同的矩阵，所以必须通过子矩阵链的首尾索引两个值来区分唯一子问题。
7. **如果要使用自底向上，考虑底部子问题**：思考对拆分的子问题按照同样的逻辑进行递归式的拆分，最后的问题会是什么，那就是自底向上最底部的子问题。
8. **自底向上解决每一个子问题**：最底层的一个或几个子问题的结果可以直接得出的，而再更高一层的子问题就要通过底层子问题的结果。方法其实就是和第 4 步一样的逻辑，只不过这里不再是使用递归式了，因为要递归的函数其实之前已经有结果了。
9. **记录最优解的方案**：根据【原问题最优决策——子问题——子问题最优决策……】的递进方法求得原问题最优解的方案。


## 最优子结构
1. 用动态规划方法求解最优化问题的第一步就是描绘最优解的结构。如果问题的最优解包含其子问题的最优解，我们就称此问题具有 **最优子结构** 性质。
2. 之所以要描绘最优子结构，就是因为原问题太复杂无从下手，所有要化解为若干子问题，再递归的化解为子子问题。
3. 一个问题是否适合应用动态规划算法，是否具有最优子结构就是一个好的线索。（最优子结构也是适用贪心策略的特点之一）
4. 使用动态规划时，我们用子问题的最优解来构造原问题的最优解。因此我们必须小心确保考察了最优解中用到的所有子问题。（例如钢条切割就只有一个子问题，而矩阵链乘就有两个子问题）
5. 在发掘最优子结构性质的过程中，遵循了如下的通用模式：
    1. 原问题的解决包含做出某种选择或者处于某种不同状态，这种选择或不同状态会将原问题划分为一个或多个子问题。例如在钢条切割问题中选择切割的位置，会将原问题划分为一个子问题；在矩阵链乘法问题中选择划分两个子矩阵链的位置，将求解原矩阵链最优解的问题划分为求解两个子链的最优解；而在 LCS 问题中，LCS 的最后一个元素的不同状态会划分出不同的子问题。
    2. 为了得出最优解而要做出的选择，肯定是所有选择的可能性中的一种，因此需要遍历所有选择的情况。
    3. 对于每一种选择，确定这个选择会产生哪些子问题，以及如何更好的描绘继而产生的子问题空间（space of subproblems）。
6. 一个描绘子问题空间的好的经验是，保持子问题空间尽可能的简单，只在必要时才扩展它。TODO，不懂

### 对于不同问题领域
1. 对于不同问题领域，最优子结构的不同体现在两个方面：
    * 原问题的最优解中涉及多少个子问题；
    * 在确定最优解使用哪些子问题时，我们需要考察多少种选择。
2. 在钢条切割问题中，最优切割方案仅仅使用一个子问题，也就是左边切下来之后右边剩余部分的最优解；而矩阵链乘法问题中，划分出来的两个子链都要计算各自的最优解。

### 粗略分析最优解
1. 子问题的总数和每个子问题要考察多少种选择，根据这两个因素的乘积可以来粗略分析动态规划算法的运行时间。
2. 对于钢条切割问题，我们需要计算从 1 到 n 种长度钢条的最优解，因此子问题的总数是 $Θ(n)$；而在解决每个子问题时，第一刀最多有 n 种切法，也就是最多有 n 种选择，因此运行时间是 $O(n^2)$。
3. 矩阵链乘法问题中，我们需要计算长度为从 1 到 n 的不同的子链的最优解，而对于给定的子链长度 l，具体从原矩阵链选取哪一段子链又有 n-l+1 中选择，所以子问题的数量是 $Θ(n^2)$；针对一个给定的子链，从哪里进行划分最多有 n-1 中选择，因此运行时间是 $O(n^3)$。
4. 子问题图也可用来做同样的分析。每个节点对应一个子问题，每条边对应一种选择。
5. 原问题最优解的代价通常就是子问题最优解的代价再加上由此次选择产生的代价。例如矩阵链问题中，依次选择中的原问题的代价，就是划分出的两个子矩阵链最优解的代价，再加上两个子矩阵链相乘的代价。

### 一些微妙之处
TODO


## 重叠子问题
1. 适合用动态规划方法求解的最优化问题应该具备的第二个性质是子问题空间必须足够小，即问题的递归算法会反复的求解相同的子问题。一般来讲，不同子问题的总数数输入规模的多项式函数为好。
2. 如果递归算法反复求解相同的子问题，我们就说最优化问题具有 **重叠子问题** 性质。与之相对，适合用分治方法求解的问题通常在递归的每一步都生成全新的子问题。
3. 动态规划算法通常对每个子问题求解一次，将解存入一个表中，当再次需要这个子问题时直接查表，每次查表的代价为常量时间。如果不使用备忘查表，钢条切割问题的时间复杂度将会是指数级别。

### 备忘
1. 通常情况下，如果每个子问题都必须至少求解一次，自底向上动态规划算法会比自顶向下备忘算法快，因为自底向上算法没有递归调用的开销，表的维护开销也更少。TODO，表维护开销怎么少
2. 而且，对于某些问题，我们可以利用表的访问模式来进一步降低失控代价。TODO，不懂。
3. 不过，如果子问题空间中的某些子问题完全不必求解，备忘方法就体现出优势了，因为它只会求解哪些必要的子问题。


### 重构最优解


## 递归式
1. 确定了最优子结构和重叠子问题性质后，就可以描绘出问题的递归式。
2. 递归式一般包含两部分，一个是边界条件，另一个就是递归求解的部分。
3. 递归求解部分涉及到做出的若干种选择，计算每种选择的收益和成本，比较哪种选择是最优解。
4. 具体计算每种选择的收益和成本时，包括选择一个部分得到的收益，剩下的子问题递归计算的收益，成本的话不一定总是有，如果有的话一般就是做出选择时要付出的代价。


## Referecens
* [算法导论](https://book.douban.com/subject/20432061/)