# Priority Queues


<!-- TOC -->

- [Priority Queues](#priority-queues)
    - [设计思想](#设计思想)
    - [本质](#本质)
    - [优先队列的概念](#优先队列的概念)
    - [堆的定义](#堆的定义)
        - [堆有序](#堆有序)
    - [二叉堆的实现](#二叉堆的实现)
        - [构造数组](#构造数组)
    - [堆的算法](#堆的算法)
        - [插入元素和删除最大元素](#插入元素和删除最大元素)
        - [完整实现](#完整实现)
        - [分析](#分析)
        - [多叉堆](#多叉堆)
    - [索引优先队列](#索引优先队列)
    - [堆排序](#堆排序)
    - [Summary](#summary)
    - [API](#api)
    - [初级实现](#初级实现)
        - [无序数组](#无序数组)
        - [有序数组](#有序数组)
        - [链表表示法](#链表表示法)
        - [分析](#分析-1)
    - [References](#references)

<!-- /TOC -->


## 设计思想


## 本质


## 优先队列的概念
1. 队列有一个重要的变体，叫作 **优先级队列**。
2. 和队列一样，优先级队列从头部移除元素，不过元素的逻辑顺序是由优先级决定的。优先级最高的元素在最前，优先级最低的元素在最后。
3. 因此，当一个元素入队时，它可能直接被移到优先级队列的头部。对于一些图算法来说，优先级队列是一个有用的数据结构。
4. 你或许可以想到一些使用排序函数和列表实现优先级队列的简单方法。但是，就时间复杂度而言，列表的插入操作是 $O(n)$，排序操作是 $O(n\log n)$。
5. 其实，效率可以更高。实现优先级队列的经典方法是使用叫作 **二叉堆** 的数据结构。二叉堆的入队操作和出队操作均可达到 $O(\log n)$。
6. 二叉堆画出来很像一棵树，但实现时只用一个列表作为内部表示。
7. 二叉堆有两个常见的变体：最小堆（最小的元素一直在队首）与最大堆（最大的元素一直在队首）。


## 堆的定义
1. **二叉堆** 画出来很像一棵树，但实现时可以只用一个数组作为内部表示。
2. 在实现二叉堆时，我们通过创建一棵 **完全二叉树** 来维持树的平衡。在完全二叉树中，除了最底层，其他每一层的节点都是满的。

### 堆有序
1. 我们用来存储堆元素的方法依赖于堆的有序性。
2. 当一棵二叉树的每个节点都大于等于它的两个子节点时，它被称为 **堆有序**
    <img src="./images/06.png" width="400" style="display: block; margin: 5px 0 10px;" />


## 二叉堆的实现
### 构造数组











在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。如果我们将所有元素画成一棵二叉树，将每个较大元素和两个较小的元素用边连接就可以很容易看出这种结构。
2. 当一棵二叉树的每个节点都大于等于它的两个子节点时，它被称为 **堆有序**。
3. 如果我们用指针来表示堆有序的二叉树，那么每个元素都需要三个指针来找到它的上下节点（父节点和两个子节点各需要一个）。但如下图所示，如果我们使用完全二叉树（在完全二叉树中，除了最底层，其他每一层的节点都是满的。在最底层，我们从左往右填充节点），表达就会变得特别方便
    <img src="./images/11.png" width="400" style="display: block; margin: 5px 0 10px;" />
4. 要画出这样一棵完全二叉树，可以先定下根节点，然后一层一层地由上向下、从左至右，在每个节点的下方连接两个更小的节点，直至将 N 个节点全部连接完毕。
5. 完全二叉树只用数组而不需要指针就可以表示。具体方法就是将二叉树的节点按照层级顺序放入数组中，根节点在位置 1，它的子节点在位置 2 和 3，而子节点的子节点则分别在位置 4、5、6 和 7，以此类推
    <img src="./images/12.png" width="400" style="display: block; margin: 5px 0 10px;" />
6. 在一个堆中，位置 $k$ 的节点的父节点的位置为 $\lfloor k/2\rfloor$，而它的两个子节点的位置则分别为 $2k$ 和 $2k+1$。这样在不使用指针的情况下我们也可以通过计算数组的索引在树中上下移动。
7. 用数组（堆）实现的完全二叉树的结构是很严格的，但它的灵活性已经足以让我们高效地实现优先队列。用它们我们将能实现对数级别的插入元素和删除最大元素的操作。利用在数组中无需指针即可沿树上下移动的便利和以下性质，算法保证了对数复杂度的性能。
8. 一棵大小为 $N$ 的完全二叉树的高度为 $\left\lfloor\lg N\right\rfloor$。通过归纳很容易可以证明这一点，且当 $N$ 达到 2 的幂时树的高度会加 1。


## 堆的算法


### 插入元素和删除最大元素
<img src="./images/15.png" width="600" style="display: block; margin: 5px 0 10px;" />

1. 插入元素时，我们将新元素加到数组末尾，并让这个新元素上浮到合适的位置
    ```js
    insert ( v ) {
        this.arr.push( v );
        this.swim( this.size() );
    }
    ```
2. 删除最大元素，我们从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置
    ```js
    delMax () {
        let maxNode = this.arr[1];
        let size = this.size();
        this.swap( 1, size ); 
        this.arr.length = size; // 删除交换下来的最大节点
        this.sink(1);
        return maxNode;
    }
    ```

### 完整实现
```js
class PriorityQueues {
    constructor () {
        this.arr = [null];
    }

    swap( index1, index2 ) {
        let aux = this.arr[index1];
        this.arr[index1] = this.arr[index2];
        this.arr[index2] = aux;
    }

    less ( index1, index2 ) {
        return this.arr[index1] < this.arr[index2];
    }

    size () {
        return this.arr.length - 1; 
    }

    swim ( k ) {
        while ( k > 1 && this.less(Math.floor(k/2), k) ) {
            let parentIndex = Math.floor(k/2);
            this.swap( parentIndex , k );
            k = parentIndex;
        }
    }

    sink ( k ) {
        let size = this.size();
        while ( 2*k <= size ) {
            let left = 2*k; 
            let right = 2*k + 1; 
            let bigger = left; 

            if ( right <= size && this.less( left, right) ) {
                bigger = right;
            }

            if ( !this.less(k, bigger) ) {
                break;
            }

            this.swap( k, bigger );

            k = bigger;
        }
    }

    insert ( v ) {
        this.arr.push( v );
        this.swim( this.size() );
    }

    delMax () {
        let maxNode = this.arr[1];
        let size = this.size();
        this.swap( 1, size ); 
        this.arr.length = size; // 删除交换下来的最大节点
        this.sink(1);
        return maxNode;
    }
}
```

### 分析
1. 于一个含有 $N$ 个元素的基于堆的优先队列，插入元素操作只需不超过 $1 + logN$ 次比较，删除最大元素的操作需要不超过 $2logN$ 次比较。
2. 插入时，如果 $log N$ 行没有插满，那么就插入这一行，然后如果一路比较交换到顶节点，需要 $log N$；如果插入时 $log N$ 行是满的，那就插入到新的一行，比较交换到顶点就要再多一次。
3. 删除最大元素时，移上去的元素如果再次一路交换到底部，需要往下移动 $log N$ 行，而每次移动都要比较两次：第一次是比较出两个子节点中更大的那个，第二次是用这个较大的子节点和要下移的父节点比较。
4. 对于需要大量混杂的插入和删除最大元素操作的典型应用来说，这意味着一个重要的性能突破。使用有序或是无序数组的优先队列的初级实现总是需要线性时间来完成其中一种操作，但基于堆的实现则能够保证在对数时间内完成它们。这种差别使得我们能够解决以前无法解决的问题。
5. 不懂，整个数组并不是有序的，只是保证了父子之间的有序而已。


### 多叉堆
1. 基于用数组表示的完全三叉树构造堆并修改相应的代码并不困难。对于一个完全三叉树，第 $n$ 行的节点数量最多是 $3^n$。
2. 对于数组中 1 至 N 的 N 个元素，位置 $k$ 的节点大于等于位于 $3k-1$、$3k$ 和 $3k+1$ 的节点，小于等于位于 $\lfloor (k+1)/3\rfloor$ 的节点。
3. $3k$ 节点一定是 $k$ 的子节点。因为如果不是的话，那它可能就是比如说是 $k+1$ 的子节点。如果这样的话，那 $3(k+1)$ 也就不是 $k+$ 的子节点，而是 $k+2$ 的子节点。以次类推的话，$k$ 这一行最后一个节点的子节点就会被之前节点的子节点占用，也就是说 $k$ 这一行最后一个节点的子节点要在下下一行。
4. 同理，$k$ 的子节点也只能是 $3k-1$、$3k$ 和 $3k+1$ 这三个节点，因为如果不是的话，那就会和 $k+1$ 及 $k-1$ 的子节点冲突了，最终还会导致尾部节点的子节点要在下下一行。
5. 多叉堆的情况，对于给定的 $d$，将其修改为任意的 $d$ 叉树也并不困难。我们需要在树高 $log_dN$ 和在每个节点的 $d$ 个子节点找到最大者的代价之间找到折中，这取决于实现的细节以及不同操作的预期相对频繁程度。


## 索引优先队列
TODO


## 堆排序
1. 堆排序可以分为两个阶段：**堆的构造阶段** 和 **下沉排序阶段**。
2. 在堆的构造阶段中，我们将原始数组重新组织安排进一个堆中。
3. 然后在下沉排序阶段，我们从堆中按递减顺序取出所有元素（不断删除最大元素）并得到排序结果。
























## Summary
1. 许多应用程序都需要处理有序的元素，但不一定要求它们全部有序，或是不一定要一次就将它们排序。很多情况下我们会收集一些元素，处理当前键值最大的元素，然后再收集更多的元素，再处理当前键值最大的元素，如此这般。
2. 在这种情况下，一个合适的数据结构应该支持两种操作：**删除最大元素**（或最小元素） 和 **插入元素**。这种数据类型叫做 **优先队列**。
3. 优先队列的一些重要的应用场景包括模拟系统，其中事件的键即为发生的时间，而系统需要按照时间顺序处理所有事件；任务调度，其中键值对应的优先级决定了应该首先执行哪些任务；数值计算，键值代表计算错误，而我们需要按照键值指定的顺序来修正它们。
4. 通过插入一列元素然后一个个地删掉其中最小的元素，我们可以用优先队列实现排序算法。一种名为 **堆排序** 的重要排序算法也来自于基于堆的优先队列的实现。


## API
1. 优先队列最重要的操作就是 **删除最大元素** 和 **插入元素**，删除最大元素的方法名为 `delMax`，插入元素的方法名为 `insert`。
2. 完整的 API：
    方法 | 描述
    --|--
    MaxPQ()	            | 创建一个优先队列
    MaxPQ(int max)	    | 创建一个初始容量为 max 的优先队列
    MaxPQ(Key[] a)	    | 用 a[] 中的元素创建一个优先队列
    void Insert(Key v)	| 向优先队列中插入一个元素
    Key max()	        | 返回最大元素
    Key delMax()	    | 删除并返回最大元素
    boolean isEmpty()	| 返回队列是否为空
    int size()	        | 返回优先队列中的元素个数


## 初级实现
1. 初级实现指的是使用有序或无序的数组，或者链表来实现优先序列。
2. 如果队列较小时，或者大部分时间都只是使用删除最大元素或者插入元素这两种主要操作中的一种时，或是所操作元素的顺序已知时，很适合使用这三种简单的数据结构来实现。

### 无序数组
1. 因为是无序数组，所以 `insert` 方法很简单，只需要直接 push 元素进去就行了。
2. 但是要要实现 `delMax`，就要在无序的数组里找到最大元素。我们可以添加一段类似于选择排序的内循环的代码，将最大元素和边界元素交换然后删除它。

### 有序数组
1. 因为要保证数组有序，所以 `insert` 方法就会麻烦一些，需要将所有较大的元素向右边移动一格以使数组保持有序（和插入排序一样）。这样，最大的元素总会在数组的一边。
2. 不过 `delMax` 就很简单了。

### 链表表示法

### 分析
1. 使用无序序列是解决这个问题的惰性方法，我们仅在必要的时候才会采取行动找出最大元素；使用有序序列则是解决问题的积极方法，因为我们会尽可能未雨绸缪，在插入元素时就保持列表有序，使后续操作更高效。
2. 实现栈或是队列与实现优先队列的最大不同在于对性能的要求。对于栈和队列，我们的实现能够在常数时间内完成所有操作；而对于优先队列，我们刚刚讨论过的所有初级实现中，插入元素和删除最大元素这两个操作之一在最坏情况下需要线性时间来完成。我们接下来要讨论的基于数据结构 **堆** 的实现能够保证这两种操作都能更快地执行。
3. 时间复杂度如下
    数据结构 | 插入元素 | 删除最大元素
    --|--|--
    有序数组 | N | 1
    无序数组 | 1 | N
    堆 | $log N$ | $log N$
    理想情况 | 1 | 1


## References
* [算法（第4版）](https://book.douban.com/subject/19952400/)
* [《Python数据结构与算法分析（第2版）》](https://book.douban.com/subject/34785178/)


