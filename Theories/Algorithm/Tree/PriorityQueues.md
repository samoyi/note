# Priority Queues


<!-- TOC -->

- [Priority Queues](#priority-queues)
    - [设计思想](#设计思想)
    - [本质](#本质)
    - [Summary](#summary)
    - [API](#api)
    - [初级实现](#初级实现)
        - [无序数组](#无序数组)
        - [有序数组](#有序数组)
        - [链表表示法](#链表表示法)
        - [分析](#分析)
    - [References](#references)

<!-- /TOC -->


## 设计思想


## 本质










## Summary



## API
1. 优先队列最重要的操作就是 **删除最大元素** 和 **插入元素**，删除最大元素的方法名为 `delMax`，插入元素的方法名为 `insert`。
2. 完整的 API：
    方法 | 描述
    --|--
    MaxPQ()	            | 创建一个优先队列
    MaxPQ(int max)	    | 创建一个初始容量为 max 的优先队列
    MaxPQ(Key[] a)	    | 用 a[] 中的元素创建一个优先队列
    void Insert(Key v)	| 向优先队列中插入一个元素
    Key max()	        | 返回最大元素
    Key delMax()	    | 删除并返回最大元素
    boolean isEmpty()	| 返回队列是否为空
    int size()	        | 返回优先队列中的元素个数


## 初级实现
1. 初级实现指的是使用有序或无序的数组，或者链表来实现优先序列。
2. 如果队列较小时，或者大部分时间都只是使用删除最大元素或者插入元素这两种主要操作中的一种时，或是所操作元素的顺序已知时，很适合使用这三种简单的数据结构来实现。

### 无序数组
1. 因为是无序数组，所以 `insert` 方法很简单，只需要直接 push 元素进去就行了。
2. 但是要要实现 `delMax`，就要在无序的数组里找到最大元素。我们可以添加一段类似于选择排序的内循环的代码，将最大元素和边界元素交换然后删除它。

### 有序数组
1. 因为要保证数组有序，所以 `insert` 方法就会麻烦一些，需要将所有较大的元素向右边移动一格以使数组保持有序（和插入排序一样）。这样，最大的元素总会在数组的一边。
2. 不过 `delMax` 就很简单了。

### 链表表示法

### 分析
1. 使用无序序列是解决这个问题的惰性方法，我们仅在必要的时候才会采取行动找出最大元素；使用有序序列则是解决问题的积极方法，因为我们会尽可能未雨绸缪，在插入元素时就保持列表有序，使后续操作更高效。
2. 实现栈或是队列与实现优先队列的最大不同在于对性能的要求。对于栈和队列，我们的实现能够在常数时间内完成所有操作；而对于优先队列，我们刚刚讨论过的所有初级实现中，插入元素和删除最大元素这两个操作之一在最坏情况下需要线性时间来完成。我们接下来要讨论的基于数据结构 **堆** 的实现能够保证这两种操作都能更快地执行。
3. 时间复杂度如下
    数据结构 | 插入元素 | 删除最大元素
    --|--|--
    有序数组 | N | 1
    无序数组 | 1 | N
    堆 | $log N$ | $log N$
    理想情况 | 1 | 1


## References
* [算法（第4版）](https://book.douban.com/subject/19952400/)
* [《Python数据结构与算法分析（第2版）》](https://book.douban.com/subject/34785178/)


