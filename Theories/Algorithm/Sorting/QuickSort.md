# QuickSort


<!-- TOC -->

- [QuickSort](#quicksort)
    - [设计思想](#设计思想)
    - [基本算法](#基本算法)
        - [实现](#实现)
    - [注意点](#注意点)
        - [对输入数组乱序](#对输入数组乱序)
        - [`i` `j` 相遇和交错的情况](#i-j-相遇和交错的情况)
            - [`i` 向 `j` 移动时：](#i-向-j-移动时)
                - [如果 `j` 还在 `rightIndex` 的位置](#如果-j-还在-rightindex-的位置)
                - [如果 `j` 发生过移动](#如果-j-发生过移动)
            - [`j` 向 `i` 移动时：](#j-向-i-移动时)
                - [如果 `i` 还在 `leftIndex+1` 的位置](#如果-i-还在-leftindex1-的位置)
                - [如果 `i` 移动过](#如果-i-移动过)
        - [比较交换的停止条件](#比较交换的停止条件)
        - [为什么 `pivot` 是和 `j` 所在的元素交换而不是和 `i` 所在的元素](#为什么-pivot-是和-j-所在的元素交换而不是和-i-所在的元素)
        - [为什么内层循环不包括等于](#为什么内层循环不包括等于)
        - [`i` 和 `j` 所在元素的交换条件要包括等于，即 `i <= j`](#i-和-j-所在元素的交换条件要包括等于即-i--j)
        - [`partition` 对两项数组的处理](#partition-对两项数组的处理)
        - [原地切分](#原地切分)
    - [性能分析](#性能分析)
        - [命题：将长度为 $N$ 的无重复数组排序，快速排序平均需要 $\sim2N\ln N$ 次比较（以及 1/6 的交换）。](#命题将长度为-n-的无重复数组排序快速排序平均需要-\sim2n\ln-n-次比较以及-16-的交换)
        - [命题：快速排序最多需要约 $N^2/2$ 次比较，但随机打乱数组能够预防这种情况](#命题快速排序最多需要约-n^22-次比较但随机打乱数组能够预防这种情况)
    - [算法改进](#算法改进)
        - [切换到插入排序](#切换到插入排序)
        - [三取样切分](#三取样切分)
        - [熵最优的排序](#熵最优的排序)
            - [实现](#实现-1)
            - [分析](#分析)
    - [References](#references)

<!-- /TOC -->

## 设计思想


## 基本算法
1. 快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。
2. 快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。
3. 在第一种情况中，递归调用发生在处理整个数组之前；在第二种情况中，递归调用发生在处理整个数组之后。
4. 在归并排序中，一个数组被等分为两半；在快速排序中，切分（partition）的位置取决于数组的内容。
5. 主要缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。已经有无数例子显示许多种错误都能致使它在实际中的性能只有平方级别。幸好我们将会看到，由这些错误中学到的教训也大大改进了快速排序算法，使它的应用更加广泛。

### 实现
```js
function partition ( arr, leftIndex, rightIndex ) {
    let pivot = arr[leftIndex];
    let i = leftIndex + 1;
    let j = rightIndex;

    // 注意不能是 <，必须是 <=。也就是说，不仅要相遇，还要错过。
    while ( i <= j ) { 
        // 左边的指针右移直到找到一个比 pivot 大的元素
        while ( arr[i] < pivot ) {
            i++;
            // 防止数组越界
            // 如果不跳出的话，下一轮 arr[i] 可能小于 pivot，i 再自增就会超出当前子数组的范围，
            // 进而进入其他子数组或者超出完整的数组。
            // 进入其他子数组其实并不会出错，如果能及时停下来还是能正常的实现分组；
            // 但有可能超出完整的数组，虽然这在 JS 里 arr[i] 会变成 undefined 从而判断变为 false 
            // 退出循环，但在其他语言里可能就会出错。
            if ( i === rightIndex ) {
                break;
            }
        }

        // 右边的指针左移直到找到一个比 pivot 小的元素
        while ( arr[j] > pivot ) {
            j--;
            // 没必要，因为此时 arr[j] 就是 pivot，不会再进入循环
            // if ( j === leftIndex ) { 
            //     break;
            // }
        }
        // 两边暂停移动后，如果没有相遇，则交换。
        // 通过该次交换，保证了从起始位置到当前位置，
        // 左边所有的项都是小于 pivot 的值，右边所有的项都是大于 pivot 的值
        if (i <= j) { 
            // 交换后两个指针移到下一个没有探索的位置，继续探索
            swap(arr, i++, j--);
        }
    }
    swap(arr, leftIndex, j);
    return j;
}

function quickSort ( arr, leftIndex, rightIndex ) {
    if ( leftIndex >= rightIndex ) {
        return;
    }
    let index = partition( arr, leftIndex, rightIndex );
    quickSort( arr, leftIndex, index-1);
    quickSort( arr, index+1, rightIndex);
}


// 实际使用时，先对数组进行乱序操作，消除初始状态小可能的有序
// ...
shuffle(arr);
quickSort(arr, 0, SIZE-1);
```


## 注意点
### 对输入数组乱序
1. 这能够防止出现最坏情况并使运行时间可以预计。Hoare 在 1960 年提出这个算法的时候就推荐了这种方法——它是一种（也是第一批）偏爱随机性的算法。
2. 假设你总是将第一个元素用作基准值，且要处理的数组是有序的。由于快速排序算法不检查输入数组是否有序，因此它依然尝试对其进行排序
    <img src="./images/11.png" width="600" style="display: block; margin: 5px 0 10px;" />
3. 注意，数组并没有被分成两半，相反，其中一个子数组始终为空，这导致调用栈非常长。
4. 现在假设你总是将中间的元素用作基准值，在这种情况下，调用栈如下
    <img src="./images/12.png" width="600" style="display: block; margin: 5px 0 10px;" />
5. 调用栈短得多！因为你每次都将数组分成两半，所以不需要那么多递归调用。
6. 第一个示例展示的是最糟情况，而第二个示例展示的是最佳情况。在最糟情况下，栈长为 $O(N)$，而在最佳情况下，栈长为 $O(log N)$。
7. 而不管是最糟情况还是最佳情况，在调用栈的每层都涉及 $N$ 个元素。
8. 所以，最糟情况下快速排序的时间复杂度为 $O(N^2)$，而最佳情况的时间复杂度是 $O(N log N)$。
9. 而且要注意的是，这里的最佳情况其实也就是数组乱序的情况，所以其实它也就是平均情况。只要你每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间就将为 $O(N log N)$。

### `i` `j` 相遇和交错的情况
#### `i` 向 `j` 移动时：
##### 如果 `j` 还在 `rightIndex` 的位置
1. `i` 移动到到 `j` 的位置后 `break` 退出内层循环。
    * 此时如果 `arr[j]` 大于 `pivot` 则 `j` 会移动一步停止，`i>j`，退出外层循环。
    * 此时如果 `arr[j]` 不大于 `pivot` 则 `j` 留在原地，`i==j`，发生一次原地交换后 `i>j`，退出外层循环。
2. 现在 `j` 在倒数第二的位置，和 `pivot` 交换，结束 `partition`。

##### 如果 `j` 发生过移动
1. 说明之前交换过，并且交换后 `j--`，现在所处的位置不确定和 `pivot` 什么关系。
    * 如果当前位置小于 `pivot`，`i` 走到这里后还会再走一步，退出它的内层 `while`。`j` 不会移动，退出外层循环，`pivot` 和 `j` 交换。
    * 如果当前位置等于 `pivot`，`i` 走到这里后停止，退出它的内层 `while`。`j` 不会移动，此时 `i==j`，发生一次原地交换后 `j` 前进一步，退出外层循环，`pivot` 和 `j` 交换。
    * 如果当前位置大于 `pivot`，`i` 走到这里后停止，退出它的内层 `while`。`j` 向前走一步，`i>j`，退出外层循环，`pivot` 和 `j` 交换。

#### `j` 向 `i` 移动时：
##### 如果 `i` 还在 `leftIndex+1` 的位置
说明当前元素大于等于 `pivot`
    * 如果等于 `pivot`，`j` 移动到这里后停止，发生一次原地交换，`j` 移动到 `pivot` 的位置，结束外层 `while` 循环，`pivot` 的位置再发生一次原地交换。也就是说这次 `parition` 中 `pivot` 就是最小的元素，这就是最坏情况。
    * 如果大于 `pivot`，`j` 移动到这里后会再移动一步到 `pivot` 的位置，直接退出外层 `while` 循环。`pivot` 的位置还是发生一次原地交换。依然是最坏的情况。

##### 如果 `i` 移动过
那么此时就是停在了一个大于等于 `pivot` 的位置等待交换
    * 如果等于 `pivot`，`j` 移动到这里后停止，发生一次原地交换，`j` 再前进一步到一个小于 `pivot` 的元素上。退出外层 `while` 循环，`j` 所在的元素和 `pivot` 交换。
    * 如果大于 `pivot`，`j` 移动到这里后会再移动一步到一个小于 `pivot` 的元素上。退出外层 `while` 循环，`j` 所在的元素和 `pivot` 交换。
    
### 比较交换的停止条件
1. 也就是外层 `while` 的停止条件。该循环继续的条件是 `i <= j`，而不能是 `i < j`。也就是说，当两个指针相遇时，依然不能停止循环。
2. 因为循环停止后，就要交换 `arr[leftIndex]` 和 `arr[j]`，而交换的前提就是 `arr[j] <= arr[leftIndex]`。
3. 问题是，两个指针相遇时所在的元素，不能保证小于等于 `arr[leftIndex]`。
4. 考虑 `[44, 157, 138, 16, 229]`。在进行一次对调后，变为 `[44, 16, 138, 157, 229]`，`i` 和 `j` 在 `138` 处相遇。这时如果退出外层循环并交换 `arr[leftIndex]` 和 `arr[j]` 的话就会错误。
5. `i` 和 `j` 相遇，意味着它们的左边都是小于等于 `pivot` 的，而右边都是大于等于 `pivot` 的。当前的 `i` 和 `j`，最多只能有其中一个移动一步，也可能都不会移动。
6. 如果当前位置小于 `pivot`，那 `i` 会移动一步然后停止，`j` 不会移动，退出外层循环；如果当前位置大于 `pivot`，那 `j` 会移动一步然后停止，`i` 不会移动，退出外层循环；如果当前位置等于 `pivot`，那 `i` 和 `j` 都不会移动，直接退出外层循环。
7. 无论以上三种情况中的哪一种退出循环后，`j` 所在的位置都是小于等于 `pivot` 的，所以可以正确交换。
8. 因为 `j` 一定会止步在小于等于 `pivot` 的元素上，而 `i` 一定会止步在大于等于 `pivot` 的元素上。它俩要么擦肩而过落在各自的终点，要么恰好一起落在等于 `pivot` 的元素上。

### 为什么 `pivot` 是和 `j` 所在的元素交换而不是和 `i` 所在的元素
1. 因为数组要保持左小右大，而上面说到最终 `j` 会落在小于等于 `pivot` 的元素上。
2. 如果 `pivot` 选在最右边，那就要和 `i` 所在的元素交换。

### 为什么内层循环不包括等于
1. 也就是说，指针所在的元素等于 `pivot` 的时候，也会停下来等待互换。
2. 仅从互换本身的效果来看，把一个等于 `pivot` 的元素换到另一边并没有什么意义，只是增加了工作量。
3. 但在某些典型应用中，它能够避免算法的运行时间变为平方级别。

### `i` 和 `j` 所在元素的交换条件要包括等于，即 `i <= j`
1. 如果不包括等于，而恰好它俩共同落在的这个元素和 `pivot` 相等，那么此时可以进入下一轮外层的 `while` 循环，但是两个内层的 `while` 都不会进入，所以 `i` 和 `j` 的值不会发生改变，就会导致外层 `while` 进入死循环。
2. 包括等于的条件下交换之后，`j` 会往前移动一步，它的背后全都是大于等于 `pivot` 的元素，而它当前位置和面前都是小于 `pivot` 的元素，所以可以和 `pivot` 交换。

### `partition` 对两项数组的处理
1. `leftIndex` 是 0，`rightIndex` 是 1；`i` 是 1，`j` 也是 1。
2. 如果本来就是升序，则 `i` 不动，`j` 变成 0，结束外层 `while`。`leftIndex` 和 `j` 都是 0，交换后数组维持不变。函数返回 0。
3. 如果本来是降序，则 `i` 变成 2 结束内层 `while`，`j` 保持 1。`j` 和 `leftIndex` 交换后数组颠倒。函数返回 1。

### 原地切分
如果使用一个辅助数组，我们可以很容易实现切分，但将切分后的数组复制回去的开销也许会使我们得不偿失。一个初级程序员甚至可能会将空数组创建在递归的切分方法中，这会大大降低排序的速度。


## 性能分析
1. 快速排序切分方法的内循环会用一个递增的索引将数组元素和一个定值比较。这种简洁性也是快速排序的一个优点，很难想象排序算法中还能有比这更短小的内循环了。例如，归并排序和希尔排序一般都比快速排序慢，其原因就是它们还在内循环中移动数据。
2. 总的来说，可以肯定的是对于大小为 $N$ 的数组，快速排序的运行时间在 $1.39N\lg N$ 的某个常数因子的范围之内。归并排序也能做到这一点，但是快速排序一般会更快（尽管它的比较次数多 39%），因为它移动数据的次数更少。这些保证都来自于数学概率，你完全可以相信它。

### 命题：将长度为 $N$ 的无重复数组排序，快速排序平均需要 $\sim2N\ln N$ 次比较（以及 1/6 的交换）。
1. 令 $C_N$ 为将 $N$ 个不同元素排序平均所需的比较次数。显然 $C_0=C_1=0$，对于 $N>1$，由递归程序可以得到以下归纳关系：

    $$
    C_N = (N+1) + (C_0+C_1+\cdots+C_{N-2}+C_{N-1})/N + (C_{N-1}+C_{N-2}+\cdots+C_0)/N
    $$

2. $N+1$ 第一次对整个数组调用 `partition` 时，`partition` 函数内部的比较次数，也就是两个指针所在的元素和 `pivot` 比较的次数，就是两个内循环 `while` 条件的比较次数。
3. $(C_0+C_1+\cdots+C_{N-2}+C_{N-1})/N$ 是第一次 `partition` 后得到的左子数组（长度可能是 0 到 N-1）排序的平均比较次数。
4. $(C_{N-1}+C_{N-2}+\cdots+C_0)/N$ 是相应的右子数组（长度和左子数组相同）排序的平均比较次数。
5. 将等式左右两边乘以 $N$ 并整理各项得到：
    
    $$
    NC_N=N(N+1)+2(C_0+C_1+\cdots+C_{N-2}+C_{N-1})
    $$

6. 将该等式减去 $N-1$ 时的相同等式可得：
   
    $$
    NC_N-(N-1)C_{N-1}=2N+2C_{N-1}
    $$

7. 整理等式并将两边除以 N(N+1) 可得：

    $$
    \frac{C_N}{N+1}=\frac{C_{N-1}}{N} + \frac{2}{N+1} 
    $$

8. 后面的不懂 TODO

### 命题：快速排序最多需要约 $N^2/2$ 次比较，但随机打乱数组能够预防这种情况
1. 尽管快速排序有很多优点，它的基本实现仍有一个潜在的缺点：在切分不平衡时这个程序可能会极为低效。例如，如果第一次从最小的元素切分，第二次从第二小的元素切分，如此这般，每次调用只会移除一个元素。这会导致一个大子数组需要切分很多次。我们要在快速排序前将数组随机排序的主要原因就是要避免这种情况。它能够使产生糟糕的切分的可能性降到极低，我们就无需为此担心了。
2. 根据刚才的证明，在每次切分后两个子数组之一总是空的情况下，比较次数为：

    $$
    N+(N-1)+(N-2)+\cdots+2+1=(N+1)N/2
    $$

3. 这不仅说明算法所需的时间是平方级别的，也显示了算法所需的空间是线性的，而这对于大数组来说是不可接受的。
4. 但是（经过一些复杂的工作）通过扩展对一般情况的分析我们可以得到比较次数的标准差约为 $0.65N$。因此，随着 $N$ 的增大，运行时间会趋近于平均数，且不可能与平均数偏差太大。
5. 例如，对于一个有 100 万个元素的数组，由 Chebyshev 不等式可以粗略地估计出运行时间是平均所需时间的 10 倍的概率小于 0.000 01（且真实的概率还要小得多）。对于大数组，运行时间是平方级别的概率小到可以忽略不计


## 算法改进
1. 几乎从 Hoare 第一次发表这个算法开始，人们就不断地提出各种改进方法。并不是所有的想法都可行，因为快速排序的平衡性已经非常好，改进所带来的提高可能会被意外的副作用所抵消。但其中一些，也是我们现在要介绍的，非常有效。
2. 如果你的排序代码会被执行很多次或者会被用在大型数组上（特别是如果它会被发布成一个库函数，排序的对象数组的特性是未知的），那么下面所讨论的这些改进意见值得你参考。
3. 需要注意的是，你需要通过实验来确定改进的效果并为实现选择最佳的参数。一般来说它们能将性能提升 20% ～ 30%。


### 切换到插入排序
1. 和大多数递归排序算法一样，改进快速排序性能的一个简单办法基于以下两点：
    * 对于小数组，快速排序比插入排序慢；
    * 因为递归，快速排序的 $sort()$ 方法在小数组中也会调用自己。
2. 因此，在排序小数组时应该切换到插入排序。小数组边界大小的最佳值是和系统相关的，但是 5 ～ 15 之间的任意值在大多数情况下都能令人满意
    ```js
    function quickSort ( arr, leftIndex, rightIndex ) {
        if ( leftIndex + 10 >= rightIndex ) {
            insertionSortForMergeSort( arr, leftIndex, rightIndex );
            return;
        }
        let index = partition( arr, leftIndex, rightIndex );
        quickSort( arr, leftIndex, index-1);
        quickSort( arr, index+1, rightIndex);
    }
    ```

### 三取样切分

### 熵最优的排序
1. 实际应用中经常会出现含有大量重复元素的数组，在这些情况下，我们实现的快速排序的性能尚可，但还有巨大的改进空间。例如，一个元素全部重复的子数组就不需要继续排序了，但我们的算法还会继续将它切分为更小的数组。
2. 在有大量重复元素的情况下，快速排序的递归性会使元素全部重复的子数组经常出现，这就有很大的改进潜力，将当前实现的线性对数级的性能提高到线性级别。
3. 一个简单的想法是将数组切分为三部分，分别对应小于、等于和大于切分元素的数组元素。
4. 从左到右遍历数组一次，维护一个指针 `lt` 使得 `arr[lo..lt-1]` 中的元素都小于 `pivot`，一个指针 `gt` 使得 `arr[gt+1..hi]` 中的元素都大于 `pivot`，一个指针 `i` 使得 `arr[lt..i-1]` 中的元素都等于` pivot`，`arr[i..gt]` 中的元素都还未确定
    <img src="./images/10.png" width="400" style="display: block; margin: 5px 0 10px; border: 10px solid #fff" />
5. 注意三个指针所在的边界：`lt` 所在的元素是等于 `pivot`，`i` 指针和 `gt` 指针所在的元素都是未确定的。
6. 一开始 `i` 和 `lo` 相等，对 `arr[i]` 进行三向比较来直接处理以下情况：
    * `arr[i]` 小于 `pivot`，将 `arr[lt]` 和 `arr[i]` 交换；将 `lt` 和 `i` 加一，`lt` 重新指向第一个和 `pivot` 相等的元素，`i` 指向新的待比较的元素。
    * `arr[i]` 大于 `pivot`，将 `arr[gt]` 和 `arr[i]` 交换；将 `gt` 减一，`gt` 重新指向最后一个未确定的元素，`i` 不用动因为换到它这里的是之前 `gt` 所在的最后一个未确定元素。
    * `arr[i]` 等于 `pivot`，将 `i` 加一。
7. 这些操作都会保证数组元素不变且缩小 `gt-i` 的值（这样循环才会结束）。另外，除非和切分元素相等，其他元素都会被交换。

#### 实现
```js
function quickSort ( arr, leftIndex, rightIndex ) {
    if ( leftIndex >= rightIndex ) {
        return;
    }

    let lt = leftIndex;
    let i = leftIndex + 1;
    let gt = rightIndex;
    let pivot = arr[leftIndex];

    while ( i<= gt ) {
        if ( arr[i] < pivot ) {
            swap(arr, lt++, i++);
        }
        else if ( arr[i] > pivot ) {
            swap(arr, gt--, i);
        }
        else {
            i++;
        }
    }
    quickSort( arr, leftIndex, lt-1);
    quickSort( arr, gt+1, rightIndex);
}
```

#### 分析
TODO


## References
* [算法（第4版）](https://book.douban.com/subject/19952400/)
* [学习JavaScript数据结构与算法](https://book.douban.com/subject/26639401/)
* [图解排序算法(二)之希尔排序](https://www.cnblogs.com/chengxiao/p/6104371.html)
* [《算法图解》](https://book.douban.com/subject/26979890/)