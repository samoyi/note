# ElementarySorts


<!-- TOC -->

- [ElementarySorts](#elementarysorts)
    - [Bubble sort](#bubble-sort)
    - [Selection Sort](#selection-sort)
        - [原理](#原理)
        - [实现](#实现)
        - [分析](#分析)
            - [时间复杂度](#时间复杂度)
            - [复杂度和输入无关](#复杂度和输入无关)
            - [数据移动是最少的](#数据移动是最少的)
    - [Insertion Sort](#insertion-sort)
        - [原理](#原理-1)
        - [实现](#实现-1)
        - [分析](#分析-1)

<!-- /TOC -->


## Bubble sort
1. [动画](https://www.programming-algorithms.net/article/39344/Bubble-sort)
2. 想象很多种不同密度的液体分层在一起，密度小的肯定要往上升，相对的密度大的就会下沉。最终，这些液体就会按照密度大小排好顺序。
3. 当然，在现实中上面的例子肯定是很多层液体一起运动的。但冒泡排序的算法是简化且变形的，体现在以下两点：
    * 即每次只有最底层的液体上升，而不是所有液体一起运动排序
    * 当该上升的液体遇到比它密度大的液体时，自然会发生位置交换，然后继续上升；但如果遇到一个比它密度还小的液体时，本轮运动并不会停下来，而是改为由那个密度更小的液体继续上升。这样就保证了，第一轮的运动会把密度最小的送到最顶层；第二轮运动会把剩下的密度最小的送到最顶层；以此类推，最终排好顺序。
4. 时间复杂度是`O(n^2)`级别的，具体为
    ```js
    function cost(len) {
        len--;
        return (1 + len) * len三+ len;
六 }
    ```
5. 看起来相比于真实的液体排序，这种简化版本的要慢。但是慢多少呢？以及，真实液体的排序要如何实现？


## Selection Sort
### 原理
1. [动画](https://www.programming-algorithms.net/article/39430/Selection-sort)
2. 比冒泡排序还要直观，每次从未排序的项里面选出最小的排到已排序队列里就行了。
3. 已排序队列可以是一个单独的数组，也可以使用原数组，即把每次找到的最小的值和未排序数组项的最左边一项交换位置。
4. 在现实中排一队人可能会使用一个新的队伍用来排已经排好的，也占不了多少地方。不过在程序中就没必要再占用内存开辟一个新数组，毕竟程序中可能会处理很大的数组。
5. 每次选择最小的过程，从思维映射到算法的建模过程比较有趣。如果直接让一个人从一堆数字里面选一个最小的，当数字的数量很少是，我觉得对普通人来说极限就是 5 个了，这时只要看一眼就能得出结果，快到都没法分析整个的思维过程。但如果数字的数量更大时，就可以看到明显的思维过程了：先看几个，找出一个最小的记住；然后再看其他的几个，找出最小的，和前一批中最小的相比，确定这两批里面最小的；记住这个最小的，然后再看下一批。全部看完后，把最小的排到第一个。

### 实现
```js
function selectionSort( arr ) {
    let len = arr.length;

    for ( let i=0; i<len-1; i++ ) {
        let minIndex = i;
        for ( let j=i+1; j<len; j++ ) {
            if ( arr[j] < arr[minIndex] ) {
                minIndex = j; 
            }
        }

        if ( minIndex !== i ) {
            swap(arr, i, minIndex);
        }
    }
    return arr;
}
```

### 分析
#### 时间复杂度
比较的次数是 $\frac{n(n-1)}{2}$，交换的次数最坏的情况下是 $n-1$。时间复杂度是 $O(n^2)$
```js
function cost(len) {
    len--;
    return (1 + len) * len / 2 + len;
}
```

#### 复杂度和输入无关
1. 为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。
2. 这种性质在某些情况下是缺点，一个已经有序的数组或是主键全部相等的数组，和一个元素随机排列的数组所用的比较次数是一样的，而比较次数是该算法复杂度的决定因素。
3. 我们将会看到，其他算法会更善于利用输入的初始状态。

#### 数据移动是最少的
1. 每次交换都会改变两个数组元素的值，因此选择排序用了 $n-1$ 次交换——交换次数和数组的大小是线性关系。
2. 我们将研究的其他任何算法都不具备这个特征（大部分的增长数量级都是线性对数或是平方级别）。


## Insertion Sort
### 原理
1. [动画](https://www.programming-algorithms.net/article/39459/Insertion-sort)
2. 从左到右，依次把每个元素向左比较，排到比它小的第一个元素的右边。这样，在当前操作的元素左边的所有元素就是升序排列的了。

### 实现
1. 上面的动画里是先找到合适的位置，然后让中间的所有元素依次向右移动一个位置。按照这个思路，实现如下
    ```js
    function insertionSort( arr ) {
        let len = arr.length;

        for ( let i=1; i<len; i++ ) {
            let currItem = arr[i]; // 本轮比较要插入到合适位置的项
            let j = i;
            let prev = i-1; // 记录中间要移动的元素

            // 通过不断地向左比较，找到 currItem 合适的位置
            count_compare++; // 记录比较次数
            while ( j > 0 && currItem < arr[j-1] ) {
                count_compare++;  // 记录比较次数
                j--;
            }

            // 所有比 currItem 大的，依次右移一个位置
            while ( prev >= j ) {
                count_swap++;  // 记录交换次数
                arr[prev+1] = arr[prev];
                prev--;
            }

            // 这里本来是想通过判断，在值相同的情况下不用进行赋值操作
            // 但判断本身就是依次访问操作，里面还要再进行一次赋值操作，不如直接只进行一次赋值操作
            // if ( arr[j] !== currItem ) {
                count_swap++;  // 记录交换次数
                arr[j] = currItem;
            // }
        }
        
        return arr;
    }
    ```
2. 这个实现本身已经没什么问题了，不过如果愿意的话可以把两个 `while` 合并为一个，一边比较一边移动，而不是比较完之后再统一移动。两个方法在性能上是一样的，只是减少一点代码量然后省掉了变量 `prev` 而已
    ```js
    function insertionSort( arr ) {
        let len = arr.length;

        for ( let i=1; i<len; i++ ) {
            let currItem = arr[i];
            let j = i;

            // 依次和前面已排序的项比较
            // 如果比前一项小，则把前一项向后移动一位，前一项会空出来（为一个重复值）
            count_compare++;
            while ( j > 0 && currItem < arr[j-1] ) {
                count_compare++;
                count_swap++;
                arr[j] = arr[j-1];
                j--;
            }
            
            count_swap++;
            arr[j] = currItem;
        }

        return arr;
    }
    ```

### 分析
1. 相比于选择排序每次都要遍历剩下的所有项来选择最小的方式，插入排序在每次和左边已经排好的项比较时，并不需要和每一项比较，只需要找到一个比自己大的就可以停下来插入了。
2. 也就是说，相比于选择排序的效率不会因为数据而改变，选择排序的效率则会受到数据的明显影响。数据本身越有序，则插入排序需要比较的次数也就越少。
3. 在最好的情况下，也就是数据已经是按顺序排好的情况下，插入排序的比较根本不会进入 `while` 内部，因此比较次数和交换次数都是 $n-1$。$O(n)$ 级别。
4. 最坏的情况下，也就是数据完全逆序的情况下，`while` 为 `true` 的比较次数是 $\frac{n(n-1)}{2}$，所以 `while` 内部的交换也是 $\frac{n(n-1)}{2}$ 次；每轮 `for` 循环还有一次 `while` 为 `false` 的比较，以及一次最后的赋值交换；所以最坏情况下比较次数和交换次数都是 $\frac{(n-1)(n+2)}{2}$。$O(n^2)$ 级别。
5. 平均的情况下，一个元素移动的步数概率介于完全不用移动和移动到底之间（TODO，直觉是这样，书上也是这么说，但还需要证明一下），所以 `while` 内部的比较和交换是 $\frac{n(n-1)}{2}$ 次，再加上外面 $n-1$ 次的比较和交换，一共是 $\frac{(n-1)(n+4)}{4}$。也是 $O(n^2)$ 级别，不过大概是最坏情况下的一半。
6. 我们要考虑的更一般的情况是 **部分有序** 的数组。**倒置** 指的是数组中的两个顺序颠倒的元素。比如 E X A M P L E 中有 11 对倒置：E-A、X-A、X-M、X-P、X-L、X-E、M-L、M-E、P-L、P-E 以及 L-E。如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。下面是几种典型的部分有序的数组：
    * 数组中每个元素距离它的最终位置都不远；
    * 一个有序的大数组接一个小数组；
    * 数组中只有几个元素的位置不正确。
7. 事实上，当顺序倒置的数量很少时，插入排序很可能比常见的其他任何算法都要快。因此插入排序对于实际应用中常见的某些类型的非随机数组很有效。
8. 插入排序中 `while` 循环的次数等于数组中倒置的数量。
9. 总的来说，插入排序对于部分有序的数组十分高效，也很适合小规模数组。这很重要，因为这些类型的数组在实际应用中经常出现，而且它们也是高级排序算法的中间过程。


* [算法（第4版）](https://book.douban.com/subject/19952400/)
* [学习JavaScript数据结构与算法](https://book.douban.com/subject/26639401/)